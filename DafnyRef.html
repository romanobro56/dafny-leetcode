<!DOCTYPE html>
<!-- This file is used by the Markdown processor, along with the included files head.html and footer.html.
     The script tags below allow rendering of some kinds of inline math in the reference manual.
  -->

<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script type="text/javascript" nonce="57e8d5b2cae940c6b1dab34c2e1" src="//injections.adguard.org?ts=1770136914696&amp;type=content-script&amp;dmn=dafny.org&amp;url=https%3A%2F%2Fdafny.org%2Fdafny%2FDafnyRef%2FDafnyRef&amp;app=com.google.Chrome&amp;css=3&amp;js=1&amp;rel=1&amp;rji=1&amp;sbe=1"></script><script type="text/javascript" nonce="57e8d5b2cae940c6b1dab34c2e1" src="//injections.adguard.org?ts=1770136914696&amp;name=AdGuard%20Extra&amp;type=user-script"></script><link rel="stylesheet" href="/assets/main.css">
  <link rel="icon" type="image/svg+xml" href="/images/dafny-favicon.svg">
  <link rel="icon" type="image/png" href="/images/dafny-favicon.png"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Dafny Documentation</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Dafny Documentation" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://dafny-lang.github.io/dafny/dafny/DafnyRef/DafnyRef.html" />
<meta property="og:url" content="https://dafny-lang.github.io/dafny/dafny/DafnyRef/DafnyRef.html" />
<meta property="og:site_name" content="Dafny Documentation" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Dafny Documentation" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"Dafny Documentation","url":"https://dafny-lang.github.io/dafny/dafny/DafnyRef/DafnyRef.html"}</script>
<!-- End Jekyll SEO tag -->
</head>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript" ></script>
<script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(","\\)"]], displayMath: [ ["$$","$$"], ["\\[","\\]"] ]
        }});
</script>

<body>

  <main class="page-content" aria-label="Content">
    <div class="wrapper">
      <link rel="stylesheet" href="../assets/main.css" />

<link rel="icon" href="../images/dafny-favicon.png" type="image/png" />

<link rel="icon" href="../images/dafny-favicon.svg" type="image/svg+xml" />

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<font size="+4"><p style="text-align: center;">Dafny Reference Manual</p></font>
<p><!-- PDFOMIT --></p>
<p style="text-align: center;">The dafny-lang community</p>
<p><!-- PDFOMIT --></p>
<p style="text-align: center;"><script> document.write(new Date(document.lastModified)); </script></p>
<p><!-- PDFOMIT --></p>
<p style="text-align: center;">
Development version
 <!-- PDFOMIT -->
</p>
<!--PDF NEWPAGE-->

<p><strong>Abstract:</strong>
This is the Dafny reference manual; it describes the Dafny programming
language and how to use the Dafny verification system.
Parts of this manual are more tutorial in nature in order to help the
user understand how to do proofs with Dafny.</p>

<p><a href="https://dafny-lang.github.io/dafny/DafnyRef/DafnyRef">(Link to current document as html)</a></p>

<ul id="markdown-toc">
  <li><a href="#sec-introduction" id="markdown-toc-sec-introduction">1. Introduction</a>    <ul>
      <li><a href="#11-dafny-40" id="markdown-toc-11-dafny-40">1.1. Dafny 4.0</a></li>
      <li><a href="#sec-example" id="markdown-toc-sec-example">1.2. Dafny Example</a></li>
    </ul>
  </li>
  <li><a href="#sec-lexical-grammar" id="markdown-toc-sec-lexical-grammar">2. Lexical and Low Level Grammar</a>    <ul>
      <li><a href="#sec-unicode" id="markdown-toc-sec-unicode">2.1. Dafny Input</a></li>
      <li><a href="#sec-token-types" id="markdown-toc-sec-token-types">2.2. Tokens and whitespace</a></li>
      <li><a href="#sec-character-classes" id="markdown-toc-sec-character-classes">2.3. Character Classes</a></li>
      <li><a href="#sec-comments" id="markdown-toc-sec-comments">2.4. Comments</a></li>
      <li><a href="#sec-documentation-comments" id="markdown-toc-sec-documentation-comments">2.5. Documentation comments</a></li>
      <li><a href="#sec-tokens" id="markdown-toc-sec-tokens">2.6. Tokens (grammar)</a>        <ul>
          <li><a href="#sec-reserved-words" id="markdown-toc-sec-reserved-words">2.6.1. Reserved Words</a></li>
          <li><a href="#sec-identifiers" id="markdown-toc-sec-identifiers">2.6.2. Identifiers</a></li>
          <li><a href="#sec-digits" id="markdown-toc-sec-digits">2.6.3. Digits</a></li>
          <li><a href="#sec-escaped-characters" id="markdown-toc-sec-escaped-characters">2.6.4. Escaped Character</a></li>
          <li><a href="#sec-character-constant-token" id="markdown-toc-sec-character-constant-token">2.6.5. Character Constant Token</a></li>
          <li><a href="#sec-string-constant-token" id="markdown-toc-sec-string-constant-token">2.6.6. String Constant Token</a></li>
          <li><a href="#sec-ellipsis" id="markdown-toc-sec-ellipsis">2.6.7. Ellipsis</a></li>
        </ul>
      </li>
      <li><a href="#sec-grammar" id="markdown-toc-sec-grammar">2.7. Low Level Grammar Productions</a>        <ul>
          <li><a href="#sec-identifier-variations" id="markdown-toc-sec-identifier-variations">2.7.1. Identifier Variations</a>            <ul>
              <li><a href="#2711-identifier" id="markdown-toc-2711-identifier">2.7.1.1. Identifier</a></li>
              <li><a href="#2712-no-underscore-identifier" id="markdown-toc-2712-no-underscore-identifier">2.7.1.2. No-underscore-identifier</a></li>
              <li><a href="#sec-wild-identifier" id="markdown-toc-sec-wild-identifier">2.7.1.3. Wild identifier</a></li>
            </ul>
          </li>
          <li><a href="#272-qualified-names" id="markdown-toc-272-qualified-names">2.7.2. Qualified Names</a></li>
          <li><a href="#273-identifier-type-combinations" id="markdown-toc-273-identifier-type-combinations">2.7.3. Identifier-Type Combinations</a></li>
          <li><a href="#sec-quantifier-domains" id="markdown-toc-sec-quantifier-domains">2.7.4. Quantifier Domains (grammar)</a></li>
          <li><a href="#sec-numeric-literals" id="markdown-toc-sec-numeric-literals">2.7.5. Numeric Literals (grammar)</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#sec-program" id="markdown-toc-sec-program">3. Programs (grammar)</a>    <ul>
      <li><a href="#sec-include-directive" id="markdown-toc-sec-include-directive">3.1. Include Directives (grammar)</a></li>
      <li><a href="#sec-top-level-declaration" id="markdown-toc-sec-top-level-declaration">3.2. Top Level Declarations (grammar)</a></li>
      <li><a href="#sec-declaration-modifier" id="markdown-toc-sec-declaration-modifier">3.3. Declaration Modifiers (grammar)</a></li>
      <li><a href="#sec-user-guide-main" id="markdown-toc-sec-user-guide-main">3.4. Executable programs</a></li>
    </ul>
  </li>
  <li><a href="#sec-modules" id="markdown-toc-sec-modules">4. Modules (grammar)</a>    <ul>
      <li><a href="#sec-module-definition" id="markdown-toc-sec-module-definition">4.1. Declaring New Modules (grammar)</a></li>
      <li><a href="#42-declaring-nested-modules-standalone" id="markdown-toc-42-declaring-nested-modules-standalone">4.2. Declaring nested modules standalone</a></li>
      <li><a href="#sec-importing-modules" id="markdown-toc-sec-importing-modules">4.3. Importing Modules (grammar)</a></li>
      <li><a href="#sec-opening-modules" id="markdown-toc-sec-opening-modules">4.4. Opening Modules</a></li>
      <li><a href="#sec-export-sets" id="markdown-toc-sec-export-sets">4.5. Export Sets and Access Control (grammar)</a>        <ul>
          <li><a href="#sec-provided-and-revealed-names" id="markdown-toc-sec-provided-and-revealed-names">4.5.1. Provided and revealed names</a></li>
          <li><a href="#sec-extends-list" id="markdown-toc-sec-extends-list">4.5.2. Extends list</a></li>
        </ul>
      </li>
      <li><a href="#sec-module-abstraction" id="markdown-toc-sec-module-abstraction">4.6. Module Abstraction</a></li>
      <li><a href="#sec-module-ordering" id="markdown-toc-sec-module-ordering">4.7. Module Ordering and Dependencies</a></li>
      <li><a href="#sec-name-resolution" id="markdown-toc-sec-name-resolution">4.8. Name Resolution</a>        <ul>
          <li><a href="#481-modules-and-name-spaces" id="markdown-toc-481-modules-and-name-spaces">4.8.1. Modules and name spaces</a></li>
          <li><a href="#482-module-id-context-name-resolution" id="markdown-toc-482-module-id-context-name-resolution">4.8.2. Module Id Context Name Resolution</a></li>
          <li><a href="#483-expression-context-name-resolution" id="markdown-toc-483-expression-context-name-resolution">4.8.3. Expression Context Name Resolution</a></li>
          <li><a href="#484-type-context-name-resolution" id="markdown-toc-484-type-context-name-resolution">4.8.4. Type Context Name Resolution</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#sec-types" id="markdown-toc-sec-types">5. Types</a>    <ul>
      <li><a href="#51-kinds-of-types" id="markdown-toc-51-kinds-of-types">5.1. Kinds of types</a>        <ul>
          <li><a href="#511-value-types" id="markdown-toc-511-value-types">5.1.1. Value Types</a></li>
          <li><a href="#sec-reference-types" id="markdown-toc-sec-reference-types">5.1.2. Reference Types</a></li>
          <li><a href="#513-named-types-grammar" id="markdown-toc-513-named-types-grammar">5.1.3. Named Types (grammar)</a></li>
        </ul>
      </li>
      <li><a href="#sec-basic-type" id="markdown-toc-sec-basic-type">5.2. Basic types</a>        <ul>
          <li><a href="#sec-booleans" id="markdown-toc-sec-booleans">5.2.1. Booleans (grammar)</a>            <ul>
              <li><a href="#sec-equivalence-operator" id="markdown-toc-sec-equivalence-operator">5.2.1.1. Equivalence Operator</a></li>
              <li><a href="#sec-conjunction-and-disjunction" id="markdown-toc-sec-conjunction-and-disjunction">5.2.1.2. Conjunction and Disjunction</a></li>
              <li><a href="#sec-implication-and-reverse-implication" id="markdown-toc-sec-implication-and-reverse-implication">5.2.1.3. Implication and  Reverse Implication</a></li>
            </ul>
          </li>
          <li><a href="#sec-numeric-types" id="markdown-toc-sec-numeric-types">5.2.2. Numeric Types (grammar)</a></li>
          <li><a href="#sec-floating-point-type" id="markdown-toc-sec-floating-point-type">5.2.3. Floating-point Types (fp32 and fp64)</a>            <ul>
              <li><a href="#5231-literals" id="markdown-toc-5231-literals">5.2.3.1. Literals</a></li>
              <li><a href="#5232-special-values" id="markdown-toc-5232-special-values">5.2.3.2. Special Values</a></li>
              <li><a href="#5233-classification-predicates" id="markdown-toc-5233-classification-predicates">5.2.3.3. Classification Predicates</a></li>
              <li><a href="#5234-arithmetic-operations" id="markdown-toc-5234-arithmetic-operations">5.2.3.4. Arithmetic Operations</a></li>
              <li><a href="#5235-equality" id="markdown-toc-5235-equality">5.2.3.5. Equality</a></li>
              <li><a href="#5236-unchecked-arithmetic-and-comparison-methods" id="markdown-toc-5236-unchecked-arithmetic-and-comparison-methods">5.2.3.6. Unchecked Arithmetic and Comparison Methods</a></li>
              <li><a href="#5237-mathematical-functions" id="markdown-toc-5237-mathematical-functions">5.2.3.7. Mathematical Functions</a></li>
              <li><a href="#5238-type-conversions" id="markdown-toc-5238-type-conversions">5.2.3.8. Type Conversions</a></li>
              <li><a href="#5239-inexact-conversion-methods" id="markdown-toc-5239-inexact-conversion-methods">5.2.3.9. Inexact Conversion Methods</a></li>
              <li><a href="#52310-comparison-of-numeric-types" id="markdown-toc-52310-comparison-of-numeric-types">5.2.3.10. Comparison of Numeric Types</a></li>
            </ul>
          </li>
          <li><a href="#sec-bit-vector-types" id="markdown-toc-sec-bit-vector-types">5.2.4. Bit-vector Types (grammar)</a></li>
          <li><a href="#sec-ordinals" id="markdown-toc-sec-ordinals">5.2.5. Ordinal type (grammar)</a></li>
          <li><a href="#sec-characters" id="markdown-toc-sec-characters">5.2.6. Characters (grammar)</a></li>
        </ul>
      </li>
      <li><a href="#sec-type-parameters" id="markdown-toc-sec-type-parameters">5.3. Type parameters (grammar)</a>        <ul>
          <li><a href="#sec-type-characteristics" id="markdown-toc-sec-type-characteristics">5.3.1. Declaring restrictions on type parameters</a>            <ul>
              <li><a href="#sec-equality-supporting" id="markdown-toc-sec-equality-supporting">5.3.1.1. Equality-supporting type parameters: <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="o">==</span><span class="p">)</span></code></a></li>
              <li><a href="#sec-auto-init" id="markdown-toc-sec-auto-init">5.3.1.2. Auto-initializable types: <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></code></a></li>
              <li><a href="#sec-nonempty-types" id="markdown-toc-sec-nonempty-types">5.3.1.3. Nonempty types: <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="mi">00</span><span class="p">)</span></code></a></li>
              <li><a href="#sec-non-heap-based" id="markdown-toc-sec-non-heap-based">5.3.1.4. Non-heap based: <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span></code></a></li>
            </ul>
          </li>
          <li><a href="#sec-type-parameter-variance" id="markdown-toc-sec-type-parameter-variance">5.3.2. Type parameter variance</a></li>
        </ul>
      </li>
      <li><a href="#sec-generic-instantiation" id="markdown-toc-sec-generic-instantiation">5.4. Generic Instantiation (grammar)</a></li>
      <li><a href="#sec-collection-types" id="markdown-toc-sec-collection-types">5.5. Collection types</a>        <ul>
          <li><a href="#sec-sets" id="markdown-toc-sec-sets">5.5.1. Sets (grammar)</a></li>
          <li><a href="#sec-multisets" id="markdown-toc-sec-multisets">5.5.2. Multisets (grammar)</a></li>
          <li><a href="#sec-sequences" id="markdown-toc-sec-sequences">5.5.3. Sequences (grammar)</a>            <ul>
              <li><a href="#sec-sequence-displays" id="markdown-toc-sec-sequence-displays">5.5.3.1. Sequence Displays</a></li>
              <li><a href="#5532-sequence-relational-operators" id="markdown-toc-5532-sequence-relational-operators">5.5.3.2. Sequence Relational Operators</a></li>
              <li><a href="#5533-sequence-concatenation" id="markdown-toc-5533-sequence-concatenation">5.5.3.3. Sequence Concatenation</a></li>
              <li><a href="#sec-other-sequence-expressions" id="markdown-toc-sec-other-sequence-expressions">5.5.3.4. Other Sequence Expressions</a></li>
              <li><a href="#sec-strings" id="markdown-toc-sec-strings">5.5.3.5. Strings (grammar)</a></li>
            </ul>
          </li>
          <li><a href="#sec-maps" id="markdown-toc-sec-maps">5.5.4. Finite and Infinite Maps (grammar)</a></li>
          <li><a href="#555-iterating-over-collections" id="markdown-toc-555-iterating-over-collections">5.5.5. Iterating over collections</a>            <ul>
              <li><a href="#5551-sequences-and-arrays" id="markdown-toc-5551-sequences-and-arrays">5.5.5.1. Sequences and arrays</a></li>
              <li><a href="#5552-sets" id="markdown-toc-5552-sets">5.5.5.2. Sets</a></li>
              <li><a href="#5553-maps" id="markdown-toc-5553-maps">5.5.5.3. Maps</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#sec-type-definition" id="markdown-toc-sec-type-definition">5.6. Types that stand for other types (grammar)</a>        <ul>
          <li><a href="#sec-synonym-type" id="markdown-toc-sec-synonym-type">5.6.1. Type synonyms (grammar)</a></li>
          <li><a href="#sec-abstract-types" id="markdown-toc-sec-abstract-types">5.6.2. Abstract types (grammar)</a></li>
          <li><a href="#sec-subset-types" id="markdown-toc-sec-subset-types">5.6.3. Subset types (grammar)</a>            <ul>
              <li><a href="#5631-type-nat" id="markdown-toc-5631-type-nat">5.6.3.1. Type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code></a></li>
              <li><a href="#5632-non-null-types" id="markdown-toc-5632-non-null-types">5.6.3.2. Non-null types</a></li>
              <li><a href="#sec-arrow-subset-types" id="markdown-toc-sec-arrow-subset-types">5.6.3.3. Arrow types: <code class="language-dafny highlighter-rouge"><span class="o">-&gt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">--&gt;</span></code>, and <code class="language-dafny highlighter-rouge"><span class="err">~</span><span class="o">&gt;</span></code></a></li>
              <li><a href="#sec-witness" id="markdown-toc-sec-witness">5.6.3.4. Witness clauses</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#sec-newtypes" id="markdown-toc-sec-newtypes">5.7. Newtypes (grammar)</a>        <ul>
          <li><a href="#sec-conversion" id="markdown-toc-sec-conversion">5.7.1. Conversion operations</a></li>
        </ul>
      </li>
      <li><a href="#sec-class-types" id="markdown-toc-sec-class-types">5.8. Class types (grammar)</a></li>
      <li><a href="#sec-trait-types" id="markdown-toc-sec-trait-types">5.9. Trait types (grammar)</a>        <ul>
          <li><a href="#sec-object-type" id="markdown-toc-sec-object-type">5.9.1. Type <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> (grammar)</a></li>
          <li><a href="#sec-inheritance" id="markdown-toc-sec-inheritance">5.9.2. Inheritance</a></li>
          <li><a href="#593-example-of-traits" id="markdown-toc-593-example-of-traits">5.9.3. Example of traits</a></li>
        </ul>
      </li>
      <li><a href="#sec-array-type" id="markdown-toc-sec-array-type">5.10. Array types (grammar)</a>        <ul>
          <li><a href="#5101-one-dimensional-arrays" id="markdown-toc-5101-one-dimensional-arrays">5.10.1. One-dimensional arrays</a></li>
          <li><a href="#sec-array-to-seq" id="markdown-toc-sec-array-to-seq">5.10.2. Converting arrays to sequences</a></li>
          <li><a href="#sec-multi-dimensional-arrays" id="markdown-toc-sec-multi-dimensional-arrays">5.10.3. Multi-dimensional arrays</a></li>
        </ul>
      </li>
      <li><a href="#sec-iterator-types" id="markdown-toc-sec-iterator-types">5.11. Iterator types (grammar)</a></li>
      <li><a href="#sec-arrow-types" id="markdown-toc-sec-arrow-types">5.12. Arrow types (grammar)</a></li>
      <li><a href="#sec-tuple-types" id="markdown-toc-sec-tuple-types">5.13.  Tuple types</a></li>
      <li><a href="#sec-datatype" id="markdown-toc-sec-datatype">5.14. Algebraic Datatypes (grammar)</a>        <ul>
          <li><a href="#sec-inductive-datatypes" id="markdown-toc-sec-inductive-datatypes">5.14.1. Inductive datatypes</a></li>
          <li><a href="#sec-coinductive-datatypes" id="markdown-toc-sec-coinductive-datatypes">5.14.2. Coinductive datatypes</a></li>
          <li><a href="#sec-coinduction" id="markdown-toc-sec-coinduction">5.14.3. Coinduction</a>            <ul>
              <li><a href="#51431-well-founded-functionmethod-definitions" id="markdown-toc-51431-well-founded-functionmethod-definitions">5.14.3.1. Well-Founded Function/Method Definitions</a></li>
              <li><a href="#51432-defining-coinductive-datatypes" id="markdown-toc-51432-defining-coinductive-datatypes">5.14.3.2. Defining Coinductive Datatypes</a></li>
              <li><a href="#51433-creating-values-of-co-datatypes" id="markdown-toc-51433-creating-values-of-co-datatypes">5.14.3.3. Creating Values of Co-datatypes</a></li>
              <li><a href="#sec-co-equality" id="markdown-toc-sec-co-equality">5.14.3.4. Co-Equality</a></li>
              <li><a href="#sec-copredicates" id="markdown-toc-sec-copredicates">5.14.3.5. Greatest predicates</a></li>
              <li><a href="#51436-coinductive-proofs" id="markdown-toc-51436-coinductive-proofs">5.14.3.6. Coinductive Proofs</a>                <ul>
                  <li><a href="#514361-properties-of-prefix-predicates" id="markdown-toc-514361-properties-of-prefix-predicates">5.14.3.6.1. Properties of Prefix Predicates</a></li>
                  <li><a href="#sec-colemmas" id="markdown-toc-sec-colemmas">5.14.3.6.2. Greatest lemmas</a></li>
                  <li><a href="#sec-prefix-lemmas" id="markdown-toc-sec-prefix-lemmas">5.14.3.6.3. Prefix Lemmas</a></li>
                </ul>
              </li>
              <li><a href="#sec-abstemious" id="markdown-toc-sec-abstemious">5.14.3.7. Abstemious and voracious functions</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#sec-member-declaration" id="markdown-toc-sec-member-declaration">6. Member declarations</a>    <ul>
      <li><a href="#sec-field-declaration" id="markdown-toc-sec-field-declaration">6.1. Field Declarations (grammar)</a></li>
      <li><a href="#sec-constant-field-declaration" id="markdown-toc-sec-constant-field-declaration">6.2. Constant Field Declarations (grammar)</a></li>
      <li><a href="#sec-method-declaration" id="markdown-toc-sec-method-declaration">6.3. Method Declarations (grammar)</a>        <ul>
          <li><a href="#631-ordinary-methods" id="markdown-toc-631-ordinary-methods">6.3.1. Ordinary methods</a></li>
          <li><a href="#sec-constructor-methods" id="markdown-toc-sec-constructor-methods">6.3.2. Constructors</a>            <ul>
              <li><a href="#6321-classes-with-no-explicit-constructors" id="markdown-toc-6321-classes-with-no-explicit-constructors">6.3.2.1. Classes with no explicit constructors</a></li>
              <li><a href="#6322-classes-with-one-or-more-constructors" id="markdown-toc-6322-classes-with-one-or-more-constructors">6.3.2.2. Classes with one or more constructors</a></li>
              <li><a href="#6323-two-phase-constructors" id="markdown-toc-6323-two-phase-constructors">6.3.2.3. Two-phase constructors</a></li>
            </ul>
          </li>
          <li><a href="#sec-lemmas" id="markdown-toc-sec-lemmas">6.3.3. Lemmas</a></li>
          <li><a href="#sec-two-state" id="markdown-toc-sec-two-state">6.3.4. Two-state lemmas and functions</a></li>
        </ul>
      </li>
      <li><a href="#sec-function-declaration" id="markdown-toc-sec-function-declaration">6.4. Function Declarations (grammar)</a>        <ul>
          <li><a href="#641-functions" id="markdown-toc-641-functions">6.4.1. Functions</a></li>
          <li><a href="#642-predicates" id="markdown-toc-642-predicates">6.4.2. Predicates</a></li>
          <li><a href="#sec-function-by-method" id="markdown-toc-sec-function-by-method">6.4.3. Function-by-method</a></li>
          <li><a href="#sec-opaque" id="markdown-toc-sec-opaque">6.4.4. Function Hiding</a></li>
          <li><a href="#645-extreme-least-or-greatest-predicates-and-lemmas" id="markdown-toc-645-extreme-least-or-greatest-predicates-and-lemmas">6.4.5. Extreme (Least or Greatest) Predicates and Lemmas</a></li>
          <li><a href="#sec-older-parameters" id="markdown-toc-sec-older-parameters">6.4.6. <code class="language-dafny highlighter-rouge"><span class="n">older</span></code> parameters in predicates</a></li>
        </ul>
      </li>
      <li><a href="#65-nameonly-formal-parameters-and-default-value-expressions" id="markdown-toc-65-nameonly-formal-parameters-and-default-value-expressions">6.5. Nameonly Formal Parameters and Default-Value Expressions</a></li>
    </ul>
  </li>
  <li><a href="#sec-specifications" id="markdown-toc-sec-specifications">7. Specifications</a>    <ul>
      <li><a href="#sec-specification-clauses" id="markdown-toc-sec-specification-clauses">7.1. Specification Clauses</a>        <ul>
          <li><a href="#sec-requires-clause" id="markdown-toc-sec-requires-clause">7.1.1. Requires Clause (grammar)</a></li>
          <li><a href="#sec-ensures-clause" id="markdown-toc-sec-ensures-clause">7.1.2. Ensures Clause (grammar)</a></li>
          <li><a href="#sec-decreases-clause" id="markdown-toc-sec-decreases-clause">7.1.3. Decreases Clause (grammar)</a></li>
          <li><a href="#sec-frame-expression" id="markdown-toc-sec-frame-expression">7.1.4. Framing (grammar)</a></li>
          <li><a href="#sec-reads-clause" id="markdown-toc-sec-reads-clause">7.1.5. Reads Clause (grammar)</a></li>
          <li><a href="#sec-modifies-clause" id="markdown-toc-sec-modifies-clause">7.1.6. Modifies Clause (grammar)</a></li>
          <li><a href="#sec-invariant-clause" id="markdown-toc-sec-invariant-clause">7.1.7. Invariant Clause (grammar)</a></li>
        </ul>
      </li>
      <li><a href="#sec-method-specification" id="markdown-toc-sec-method-specification">7.2. Method Specification (grammar)</a></li>
      <li><a href="#sec-function-specification" id="markdown-toc-sec-function-specification">7.3. Function Specification (grammar)</a></li>
      <li><a href="#sec-lambda-specification" id="markdown-toc-sec-lambda-specification">7.4. Lambda Specification (grammar)</a></li>
      <li><a href="#sec-iterator-specification" id="markdown-toc-sec-iterator-specification">7.5. Iterator Specification (grammar)</a></li>
      <li><a href="#sec-loop-specification" id="markdown-toc-sec-loop-specification">7.6. Loop Specification (grammar)</a></li>
      <li><a href="#77-auto-generated-boilerplate-specifications" id="markdown-toc-77-auto-generated-boilerplate-specifications">7.7. Auto-generated boilerplate specifications</a></li>
      <li><a href="#sec-well-formedness-specifications" id="markdown-toc-sec-well-formedness-specifications">7.8. Well-formedness of specifications</a></li>
    </ul>
  </li>
  <li><a href="#sec-statements" id="markdown-toc-sec-statements">8. Statements (grammar)</a>    <ul>
      <li><a href="#sec-labeled-statement" id="markdown-toc-sec-labeled-statement">8.1. Labeled Statement (grammar)</a></li>
      <li><a href="#sec-block-statement" id="markdown-toc-sec-block-statement">8.2. Block Statement (grammar)</a></li>
      <li><a href="#sec-return-statement" id="markdown-toc-sec-return-statement">8.3. Return Statement (grammar)</a></li>
      <li><a href="#sec-yield-statement" id="markdown-toc-sec-yield-statement">8.4. Yield Statement (grammar)</a></li>
      <li><a href="#sec-update-and-call-statement" id="markdown-toc-sec-update-and-call-statement">8.5. Update and Call Statements (grammar)</a>        <ul>
          <li><a href="#851-method-call-with-no-out-parameters" id="markdown-toc-851-method-call-with-no-out-parameters">8.5.1. Method call with no out-parameters</a></li>
          <li><a href="#852-method-call-with-out-parameters" id="markdown-toc-852-method-call-with-out-parameters">8.5.2. Method call with out-parameters</a></li>
          <li><a href="#853-parallel-assignment" id="markdown-toc-853-parallel-assignment">8.5.3. Parallel assignment</a></li>
          <li><a href="#sec-havoc-statement" id="markdown-toc-sec-havoc-statement">8.5.4. Havoc assignment</a></li>
          <li><a href="#855-such-that-assignment" id="markdown-toc-855-such-that-assignment">8.5.5. Such-that assignment</a></li>
          <li><a href="#856-method-call-with-a-by-proof" id="markdown-toc-856-method-call-with-a-by-proof">8.5.6. Method call with a <code class="language-dafny highlighter-rouge"><span class="kr">by</span></code> proof</a></li>
        </ul>
      </li>
      <li><a href="#sec-update-with-failure-statement" id="markdown-toc-sec-update-with-failure-statement">8.6. Update with Failure Statement (<code class="language-dafny highlighter-rouge"><span class="o">:-</span></code>) (grammar)</a>        <ul>
          <li><a href="#sec-failure-compatible-types" id="markdown-toc-sec-failure-compatible-types">8.6.1. Failure compatible types</a></li>
          <li><a href="#sec-simple-fc-return" id="markdown-toc-sec-simple-fc-return">8.6.2. Simple status return with no other outputs</a></li>
          <li><a href="#sec-multiple-output-fc" id="markdown-toc-sec-multiple-output-fc">8.6.3. Status return with additional outputs</a></li>
          <li><a href="#sec-value-carrying" id="markdown-toc-sec-value-carrying">8.6.4. Failure-returns with additional data</a></li>
          <li><a href="#sec-failure-expressions" id="markdown-toc-sec-failure-expressions">8.6.5. RHS with expression list</a></li>
          <li><a href="#sec-failure-with-declaration" id="markdown-toc-sec-failure-with-declaration">8.6.6. Failure with initialized declaration.</a></li>
          <li><a href="#sec-failure-return-keyword" id="markdown-toc-sec-failure-return-keyword">8.6.7. Keyword alternative</a></li>
          <li><a href="#868-key-points" id="markdown-toc-868-key-points">8.6.8. Key points</a></li>
          <li><a href="#sec-failure-return-and-exceptions" id="markdown-toc-sec-failure-return-and-exceptions">8.6.9. Failure returns and exceptions</a></li>
        </ul>
      </li>
      <li><a href="#sec-variable-declaration-statement" id="markdown-toc-sec-variable-declaration-statement">8.7. Variable Declaration Statement (grammar)</a></li>
      <li><a href="#sec-guard" id="markdown-toc-sec-guard">8.8. Guards (grammar)</a></li>
      <li><a href="#sec-binding-guards" id="markdown-toc-sec-binding-guards">8.9. Binding Guards (grammar)</a></li>
      <li><a href="#sec-if-statement" id="markdown-toc-sec-if-statement">8.10. If Statement (grammar)</a></li>
      <li><a href="#sec-match-statement" id="markdown-toc-sec-match-statement">8.11. Match Statement (grammar)</a></li>
      <li><a href="#sec-while-statement" id="markdown-toc-sec-while-statement">8.12. While Statement (grammar)</a></li>
      <li><a href="#sec-for-statement" id="markdown-toc-sec-for-statement">8.13. For Loops (grammar)</a></li>
      <li><a href="#sec-break-continue-statement" id="markdown-toc-sec-break-continue-statement">8.14. Break and Continue Statements (grammar)</a></li>
      <li><a href="#sec-loop-specifications" id="markdown-toc-sec-loop-specifications">8.15. Loop Specifications</a>        <ul>
          <li><a href="#sec-loop-invariants" id="markdown-toc-sec-loop-invariants">8.15.1. Loop invariants</a></li>
          <li><a href="#sec-loop-termination" id="markdown-toc-sec-loop-termination">8.15.2. Loop termination</a></li>
          <li><a href="#sec-loop-framing" id="markdown-toc-sec-loop-framing">8.15.3. Loop framing</a></li>
          <li><a href="#sec-bodyless-constructs" id="markdown-toc-sec-bodyless-constructs">8.15.4. Body-less methods, functions, loops, and aggregate statements</a></li>
        </ul>
      </li>
      <li><a href="#sec-print-statement" id="markdown-toc-sec-print-statement">8.16. Print Statement (grammar)</a></li>
      <li><a href="#sec-assert-statement" id="markdown-toc-sec-assert-statement">8.17. Assert statement (grammar)</a></li>
      <li><a href="#sec-assume-statement" id="markdown-toc-sec-assume-statement">8.18. Assume Statement (grammar)</a></li>
      <li><a href="#sec-expect-statement" id="markdown-toc-sec-expect-statement">8.19. Expect Statement (grammar)</a></li>
      <li><a href="#sec-reveal-statement" id="markdown-toc-sec-reveal-statement">8.20. Reveal Statement (grammar)</a>        <ul>
          <li><a href="#sec-reveal-assertions" id="markdown-toc-sec-reveal-assertions">8.20.1. Revealing assertions</a></li>
          <li><a href="#8202-revealing-preconditions" id="markdown-toc-8202-revealing-preconditions">8.20.2. Revealing preconditions</a></li>
          <li><a href="#hide-statement" id="markdown-toc-hide-statement">8.20.3. Hiding and revealing function bodies</a></li>
          <li><a href="#8204-revealing-constants" id="markdown-toc-8204-revealing-constants">8.20.4. Revealing constants</a></li>
        </ul>
      </li>
      <li><a href="#sec-forall-statement" id="markdown-toc-sec-forall-statement">8.21. Forall Statement (grammar)</a></li>
      <li><a href="#sec-modify-statement" id="markdown-toc-sec-modify-statement">8.22. Modify Statement (grammar)</a></li>
      <li><a href="#sec-calc-statement" id="markdown-toc-sec-calc-statement">8.23. Calc Statement (grammar)</a></li>
      <li><a href="#sec-opaque-block" id="markdown-toc-sec-opaque-block">8.24. Opaque Block (grammar)</a></li>
    </ul>
  </li>
  <li><a href="#sec-expressions" id="markdown-toc-sec-expressions">9. Expressions</a>    <ul>
      <li><a href="#sec-top-level-expression" id="markdown-toc-sec-top-level-expression">9.1. Lemma-call expressions (grammar)</a></li>
      <li><a href="#sec-equivalence-expression" id="markdown-toc-sec-equivalence-expression">9.2. Equivalence Expressions (grammar)</a></li>
      <li><a href="#sec-implies-expression" id="markdown-toc-sec-implies-expression">9.3. Implies or Explies Expressions (grammar)</a></li>
      <li><a href="#sec-logical-expression" id="markdown-toc-sec-logical-expression">9.4. Logical Expressions (grammar)</a></li>
      <li><a href="#sec-relational-expression" id="markdown-toc-sec-relational-expression">9.5. Relational Expressions (grammar)</a></li>
      <li><a href="#sec-bit-shift-expression" id="markdown-toc-sec-bit-shift-expression">9.6. Bit Shifts (grammar)</a></li>
      <li><a href="#sec-addition-expression" id="markdown-toc-sec-addition-expression">9.7. Terms (grammar)</a></li>
      <li><a href="#sec-multiplication-expression" id="markdown-toc-sec-multiplication-expression">9.8. Factors (grammar)</a></li>
      <li><a href="#sec-bitvector-expression" id="markdown-toc-sec-bitvector-expression">9.9. Bit-vector Operations (grammar)</a></li>
      <li><a href="#sec-as-is-expression" id="markdown-toc-sec-as-is-expression">9.10. As (Conversion) and Is (type test) Expressions (grammar)</a></li>
      <li><a href="#sec-unary-expression" id="markdown-toc-sec-unary-expression">9.11. Unary Expressions (grammar)</a></li>
      <li><a href="#sec-primary-expression" id="markdown-toc-sec-primary-expression">9.12. Primary Expressions (grammar)</a></li>
      <li><a href="#sec-lambda-expression" id="markdown-toc-sec-lambda-expression">9.13. Lambda expressions (grammar)</a></li>
      <li><a href="#sec-lhs-expression" id="markdown-toc-sec-lhs-expression">9.14. Left-Hand-Side Expressions (grammar)</a></li>
      <li><a href="#sec-rhs-expression" id="markdown-toc-sec-rhs-expression">9.15. Right-Hand-Side Expressions (grammar)</a></li>
      <li><a href="#sec-array-allocation" id="markdown-toc-sec-array-allocation">9.16. Array Allocation (grammar)</a></li>
      <li><a href="#sec-object-allocation" id="markdown-toc-sec-object-allocation">9.17. Object Allocation (grammar)</a></li>
      <li><a href="#sec-havoc-expression" id="markdown-toc-sec-havoc-expression">9.18. Havoc Right-Hand-Side (grammar)</a></li>
      <li><a href="#sec-atomic-expression" id="markdown-toc-sec-atomic-expression">9.19. Constant Or Atomic Expressions (grammar)</a></li>
      <li><a href="#sec-literal-expression" id="markdown-toc-sec-literal-expression">9.20. Literal Expressions (grammar}</a></li>
      <li><a href="#sec-this-expression" id="markdown-toc-sec-this-expression">9.21. <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code> Expression (grammar)</a></li>
      <li><a href="#sec-old-expression" id="markdown-toc-sec-old-expression">9.22. Old and Old@ Expressions (grammar)</a></li>
      <li><a href="#sec-fresh-expression" id="markdown-toc-sec-fresh-expression">9.23. Fresh Expressions (grammar)</a></li>
      <li><a href="#sec-allocated-expression" id="markdown-toc-sec-allocated-expression">9.24. Allocated Expressions (grammar)</a></li>
      <li><a href="#sec-unchanged-expression" id="markdown-toc-sec-unchanged-expression">9.25. Unchanged Expressions (grammar)</a></li>
      <li><a href="#sec-cardinality-expression" id="markdown-toc-sec-cardinality-expression">9.26. Cardinality Expressions (grammar)</a></li>
      <li><a href="#sec-parenthesized-expression" id="markdown-toc-sec-parenthesized-expression">9.27. Parenthesized Expressions (grammar)</a></li>
      <li><a href="#sec-seq-comprehension" id="markdown-toc-sec-seq-comprehension">9.28. Sequence Display Expression (grammar)</a></li>
      <li><a href="#sec-set-display-expression" id="markdown-toc-sec-set-display-expression">9.29. Set Display Expression (grammar)</a></li>
      <li><a href="#sec-map-display-expression" id="markdown-toc-sec-map-display-expression">9.30. Map Display Expression (grammar)</a></li>
      <li><a href="#sec-endless-expression" id="markdown-toc-sec-endless-expression">9.31. Endless Expression (grammar)</a>        <ul>
          <li><a href="#sec-if-expression" id="markdown-toc-sec-if-expression">9.31.1. If Expression (grammar)</a></li>
          <li><a href="#sec-case-pattern" id="markdown-toc-sec-case-pattern">9.31.2. Case and Extended Patterns (grammar)</a></li>
          <li><a href="#sec-match-expression" id="markdown-toc-sec-match-expression">9.31.3. Match Expression (grammar)</a></li>
          <li><a href="#sec-quantifier-expression" id="markdown-toc-sec-quantifier-expression">9.31.4. Quantifier Expression (grammar)</a></li>
          <li><a href="#sec-set-comprehension-expression" id="markdown-toc-sec-set-comprehension-expression">9.31.5. Set Comprehension Expressions (grammar)</a></li>
          <li><a href="#sec-statement-in-an-expression" id="markdown-toc-sec-statement-in-an-expression">9.31.6. Statements in an Expression (grammar)</a></li>
          <li><a href="#sec-let-expression" id="markdown-toc-sec-let-expression">9.31.7. Let and Let or Fail Expression (grammar)</a></li>
          <li><a href="#sec-map-comprehension-expression" id="markdown-toc-sec-map-comprehension-expression">9.31.8. Map Comprehension Expression (grammar)</a></li>
        </ul>
      </li>
      <li><a href="#sec-name-segment" id="markdown-toc-sec-name-segment">9.32. Name Segment (grammar)</a></li>
      <li><a href="#sec-hash-call" id="markdown-toc-sec-hash-call">9.33. Hash call (grammar)</a></li>
      <li><a href="#sec-suffix" id="markdown-toc-sec-suffix">9.34. Suffix (grammar)</a>        <ul>
          <li><a href="#sec-augmented-dot-suffix" id="markdown-toc-sec-augmented-dot-suffix">9.34.1. Augmented Dot Suffix (grammar)</a></li>
          <li><a href="#sec-datatype-update-suffix" id="markdown-toc-sec-datatype-update-suffix">9.34.2. Datatype Update Suffix (grammar)</a></li>
          <li><a href="#sec-subsequence-suffix" id="markdown-toc-sec-subsequence-suffix">9.34.3. Subsequence Suffix (grammar)</a></li>
          <li><a href="#sec-subsequence-slices-suffix" id="markdown-toc-sec-subsequence-slices-suffix">9.34.4. Subsequence Slices Suffix (grammar)</a></li>
          <li><a href="#sec-sequence-update-suffix" id="markdown-toc-sec-sequence-update-suffix">9.34.5. Sequence Update Suffix (grammar)</a></li>
          <li><a href="#sec-selection-suffix" id="markdown-toc-sec-selection-suffix">9.34.6. Selection Suffix (grammar)</a></li>
          <li><a href="#sec-argument-list-suffix" id="markdown-toc-sec-argument-list-suffix">9.34.7. Argument List Suffix (grammar)</a></li>
        </ul>
      </li>
      <li><a href="#sec-expression-list" id="markdown-toc-sec-expression-list">9.35. Expression Lists (grammar)</a></li>
      <li><a href="#sec-parameter-bindings" id="markdown-toc-sec-parameter-bindings">9.36. Parameter Bindings (grammar)</a></li>
      <li><a href="#sec-assigned-expression" id="markdown-toc-sec-assigned-expression">9.37. Assigned Expressions</a></li>
      <li><a href="#sec-termination-ordering-expressions" id="markdown-toc-sec-termination-ordering-expressions">9.38. Termination Ordering Expressions</a></li>
      <li><a href="#sec-compile-time-constants" id="markdown-toc-sec-compile-time-constants">9.39. Compile-Time Constants</a></li>
      <li><a href="#sec-list-of-specification-expressions" id="markdown-toc-sec-list-of-specification-expressions">9.40. List of specification expressions</a></li>
    </ul>
  </li>
  <li><a href="#sec-module-refinement" id="markdown-toc-sec-module-refinement">10. Refinement</a>    <ul>
      <li><a href="#101-export-set-declarations" id="markdown-toc-101-export-set-declarations">10.1. Export set declarations</a></li>
      <li><a href="#102-import-declarations" id="markdown-toc-102-import-declarations">10.2. Import declarations</a></li>
      <li><a href="#103-sub-module-declarations" id="markdown-toc-103-sub-module-declarations">10.3. Sub-module declarations</a></li>
      <li><a href="#104-const-declarations" id="markdown-toc-104-const-declarations">10.4. Const declarations</a></li>
      <li><a href="#105-method-declarations" id="markdown-toc-105-method-declarations">10.5. Method declarations</a></li>
      <li><a href="#106-lemma-declarations" id="markdown-toc-106-lemma-declarations">10.6. Lemma declarations</a></li>
      <li><a href="#107-function-and-predicate-declarations" id="markdown-toc-107-function-and-predicate-declarations">10.7. Function and predicate declarations</a></li>
      <li><a href="#108-class-trait-and-iterator-declarations" id="markdown-toc-108-class-trait-and-iterator-declarations">10.8. Class, trait and iterator declarations</a></li>
      <li><a href="#109-type-declarations" id="markdown-toc-109-type-declarations">10.9. Type declarations</a></li>
      <li><a href="#1010-statements" id="markdown-toc-1010-statements">10.10. Statements</a></li>
    </ul>
  </li>
  <li><a href="#sec-attributes" id="markdown-toc-sec-attributes">11. Attributes</a>    <ul>
      <li><a href="#111-attributes-on-top-level-declarations" id="markdown-toc-111-attributes-on-top-level-declarations">11.1. Attributes on top-level declarations</a>        <ul>
          <li><a href="#sec-attributes-autocontracts" id="markdown-toc-sec-attributes-autocontracts">11.1.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autocontracts</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-nativetype" id="markdown-toc-sec-nativetype">11.1.2. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">nativeType</span><span class="p">}</span></code></a></li>
          <li><a href="#1113-ignore-deprecated" id="markdown-toc-1113-ignore-deprecated">11.1.3. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">ignore</span><span class="p">}</span></code> (deprecated)</a></li>
          <li><a href="#sec-extern" id="markdown-toc-sec-extern">11.1.4. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-disable-nonlinear-arithmetic" id="markdown-toc-sec-disable-nonlinear-arithmetic">11.1.5. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">disableNonlinearArithmetic</span><span class="p">}</span></code></a></li>
        </ul>
      </li>
      <li><a href="#112-attributes-on-functions-and-methods" id="markdown-toc-112-attributes-on-functions-and-methods">11.2. Attributes on functions and methods</a>        <ul>
          <li><a href="#1121-abstemious" id="markdown-toc-1121-abstemious">11.2.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">abstemious</span><span class="p">}</span></code></a></li>
          <li><a href="#1122-autoreq" id="markdown-toc-1122-autoreq">11.2.2. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoReq</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-autorevealdependencies" id="markdown-toc-sec-autorevealdependencies">11.2.3. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="n">k</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-axiom" id="markdown-toc-sec-axiom">11.2.4. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code></a></li>
          <li><a href="#1125-compile" id="markdown-toc-1125-compile">11.2.5. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">compile</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-concurrent-attribute" id="markdown-toc-sec-concurrent-attribute">11.2.6. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">concurrent</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-extern-method" id="markdown-toc-sec-extern-method">11.2.7. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-fuel" id="markdown-toc-sec-fuel">11.2.8. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">fuel</span> <span class="n">X</span><span class="p">}</span></code></a></li>
          <li><a href="#1129-id-string" id="markdown-toc-1129-id-string">11.2.9. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">id</span> <span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-induction" id="markdown-toc-sec-induction">11.2.10. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-induction-trigger" id="markdown-toc-sec-induction-trigger">11.2.11. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">inductionTrigger</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-only-functions-methods" id="markdown-toc-sec-only-functions-methods">11.2.12. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-print" id="markdown-toc-sec-print">11.2.13. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="kr">print</span><span class="p">}</span></code></a></li>
          <li><a href="#11214-priority" id="markdown-toc-11214-priority">11.2.14. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">priority</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-rlimit" id="markdown-toc-sec-rlimit">11.2.15. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">resource_limit</span><span class="p">}</span></code> and <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">rlimit</span><span class="p">}</span></code></a></li>
          <li><a href="#11216-selective_checking" id="markdown-toc-11216-selective_checking">11.2.16. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">selective_checking</span><span class="p">}</span></code></a></li>
          <li><a href="#11217-tailrecursion" id="markdown-toc-11217-tailrecursion">11.2.17. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">tailrecursion</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-test-attribute" id="markdown-toc-sec-test-attribute">11.2.18. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-time-limit" id="markdown-toc-sec-time-limit">11.2.19. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">timeLimit</span> <span class="n">N</span><span class="p">}</span></code></a></li>
          <li><a href="#11220-timelimitmultiplier-x" id="markdown-toc-11220-timelimitmultiplier-x">11.2.20. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">timeLimitMultiplier</span> <span class="n">X</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-transparent" id="markdown-toc-sec-transparent">11.2.21. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">transparent</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-verify" id="markdown-toc-sec-verify">11.2.22. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">verify</span> <span class="kc">false</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-vcs_max_cost" id="markdown-toc-sec-vcs_max_cost">11.2.23. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">vcs_max_cost</span> <span class="n">N</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-vcs_max_keep_going_splits" id="markdown-toc-sec-vcs_max_keep_going_splits">11.2.24. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">vcs_max_keep_going_splits</span> <span class="n">N</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-vcs_max_splits" id="markdown-toc-sec-vcs_max_splits">11.2.25. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">vcs_max_splits</span> <span class="n">N</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-isolate_assertions" id="markdown-toc-sec-isolate_assertions">11.2.26. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-synthesize-attr" id="markdown-toc-sec-synthesize-attr">11.2.27. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">synthesize</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-attr-options" id="markdown-toc-sec-attr-options">11.2.28. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">options</span> <span class="n">OPT0</span><span class="p">,</span> <span class="n">OPT1</span><span class="p">,</span> <span class="o">...</span> <span class="p">}</span></code></a></li>
        </ul>
      </li>
      <li><a href="#113-attributes-on-reads-and-modifies-clauses" id="markdown-toc-113-attributes-on-reads-and-modifies-clauses">11.3. Attributes on reads and modifies clauses</a>        <ul>
          <li><a href="#1131-assume_concurrent" id="markdown-toc-1131-assume_concurrent">11.3.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">assume_concurrent</span><span class="p">}</span></code></a></li>
        </ul>
      </li>
      <li><a href="#sec-verification-attributes-on-assertions" id="markdown-toc-sec-verification-attributes-on-assertions">11.4. Attributes on assertions, preconditions and postconditions</a>        <ul>
          <li><a href="#sec-only" id="markdown-toc-sec-only">11.4.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-focus" id="markdown-toc-sec-focus">11.4.2. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">focus</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-split_here" id="markdown-toc-sec-split_here">11.4.3. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">split_here</span><span class="p">}</span></code></a></li>
          <li><a href="#1144-subsumption-n" id="markdown-toc-1144-subsumption-n">11.4.4. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">subsumption</span> <span class="n">n</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-error-attribute" id="markdown-toc-sec-error-attribute">11.4.5. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">error</span> <span class="s2">"errorMessage"</span><span class="p">,</span> <span class="s2">"successMessage"</span><span class="p">}</span></code></a></li>
          <li><a href="#1146-contradiction" id="markdown-toc-1146-contradiction">11.4.6. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">contradiction</span><span class="p">}</span></code></a></li>
        </ul>
      </li>
      <li><a href="#115-attributes-on-variable-declarations" id="markdown-toc-115-attributes-on-variable-declarations">11.5. Attributes on variable declarations</a>        <ul>
          <li><a href="#sec-assumption" id="markdown-toc-sec-assumption">11.5.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">assumption</span><span class="p">}</span></code></a></li>
        </ul>
      </li>
      <li><a href="#116-attributes-on-quantifier-expressions-forall-exists" id="markdown-toc-116-attributes-on-quantifier-expressions-forall-exists">11.6. Attributes on quantifier expressions (forall, exists)</a>        <ul>
          <li><a href="#1161-heapquantifier" id="markdown-toc-1161-heapquantifier">11.6.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">heapQuantifier</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-induction-quantifier" id="markdown-toc-sec-induction-quantifier">11.6.2. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code></a></li>
          <li><a href="#sec-trigger" id="markdown-toc-sec-trigger">11.6.3. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span><span class="p">}</span></code></a></li>
        </ul>
      </li>
      <li><a href="#117-deprecated-attributes" id="markdown-toc-117-deprecated-attributes">11.7. Deprecated attributes</a></li>
      <li><a href="#118-other-undocumented-verification-attributes" id="markdown-toc-118-other-undocumented-verification-attributes">11.8. Other undocumented verification attributes</a></li>
      <li><a href="#sec-at-attributes" id="markdown-toc-sec-at-attributes">11.9. New attribute syntax</a></li>
    </ul>
  </li>
  <li><a href="#sec-advanced-topics" id="markdown-toc-sec-advanced-topics">12. Advanced Topics</a>    <ul>
      <li><a href="#sec-type-parameter-completion" id="markdown-toc-sec-type-parameter-completion">12.1. Type Parameter Completion</a></li>
      <li><a href="#sec-type-inference" id="markdown-toc-sec-type-inference">12.2. Type Inference</a></li>
      <li><a href="#sec-ghost-inference" id="markdown-toc-sec-ghost-inference">12.3. Ghost Inference</a></li>
      <li><a href="#sec-extreme" id="markdown-toc-sec-extreme">12.4. Well-founded Functions and Extreme Predicates</a>        <ul>
          <li><a href="#1241-function-definitions" id="markdown-toc-1241-function-definitions">12.4.1. Function Definitions</a>            <ul>
              <li><a href="#12411-well-founded-functions" id="markdown-toc-12411-well-founded-functions">12.4.1.1. Well-founded Functions</a></li>
              <li><a href="#sec-fib-example" id="markdown-toc-sec-fib-example">12.4.1.2. Example with Well-founded Functions</a></li>
              <li><a href="#12413-extreme-solutions" id="markdown-toc-12413-extreme-solutions">12.4.1.3. Extreme Solutions</a></li>
            </ul>
          </li>
          <li><a href="#sec-extreme-predicates" id="markdown-toc-sec-extreme-predicates">12.4.2. Working with Extreme Predicates</a>            <ul>
              <li><a href="#sec-example-least-solution" id="markdown-toc-sec-example-least-solution">12.4.2.1. Example with Least Solution</a></li>
              <li><a href="#sec-example-greatest-solution" id="markdown-toc-sec-example-greatest-solution">12.4.2.2. Example with Greatest Solution</a></li>
            </ul>
          </li>
          <li><a href="#1243-other-techniques" id="markdown-toc-1243-other-techniques">12.4.3. Other Techniques</a></li>
        </ul>
      </li>
      <li><a href="#125-functions-in-dafny" id="markdown-toc-125-functions-in-dafny">12.5. Functions in Dafny</a>        <ul>
          <li><a href="#1251-well-founded-functions-in-dafny" id="markdown-toc-1251-well-founded-functions-in-dafny">12.5.1. Well-founded Functions in Dafny</a></li>
          <li><a href="#sec-proofs-in-dafny" id="markdown-toc-sec-proofs-in-dafny">12.5.2. Proofs in Dafny</a></li>
          <li><a href="#sec-friendliness" id="markdown-toc-sec-friendliness">12.5.3. Extreme Predicates in Dafny</a></li>
          <li><a href="#1254-proofs-about-extreme-predicates" id="markdown-toc-1254-proofs-about-extreme-predicates">12.5.4. Proofs about Extreme Predicates</a></li>
          <li><a href="#sec-nicer-proofs-of-extremes" id="markdown-toc-sec-nicer-proofs-of-extremes">12.5.5. Nicer Proofs of Extreme Predicates</a></li>
        </ul>
      </li>
      <li><a href="#sec-definite-assignment" id="markdown-toc-sec-definite-assignment">12.6. Variable Initialization and Definite Assignment</a></li>
      <li><a href="#sec-well-founded-orders" id="markdown-toc-sec-well-founded-orders">12.7. Well-founded Orders</a></li>
      <li><a href="#sec-quantifier-triggers" id="markdown-toc-sec-quantifier-triggers">12.8. Quantifier instantiation rules</a></li>
    </ul>
  </li>
  <li><a href="#sec-user-guide" id="markdown-toc-sec-user-guide">13. Dafny Users Guide</a>    <ul>
      <li><a href="#131-introduction" id="markdown-toc-131-introduction">13.1. Introduction</a></li>
      <li><a href="#132-installing-dafny" id="markdown-toc-132-installing-dafny">13.2. Installing Dafny</a>        <ul>
          <li><a href="#1321-command-line-tools" id="markdown-toc-1321-command-line-tools">13.2.1. Command-line tools</a></li>
          <li><a href="#sec-ides" id="markdown-toc-sec-ides">13.2.2. IDEs for Dafny</a></li>
        </ul>
      </li>
      <li><a href="#133-dafny-programs-and-files" id="markdown-toc-133-dafny-programs-and-files">13.3. Dafny Programs and Files</a>        <ul>
          <li><a href="#sec-doo-files" id="markdown-toc-sec-doo-files">13.3.1. Dafny Verification Artifacts: the Library Backend and .doo Files</a></li>
          <li><a href="#sec-dtr-files" id="markdown-toc-sec-dtr-files">13.3.2. Dafny Translation Artifacts: .dtr Files</a></li>
        </ul>
      </li>
      <li><a href="#sec-dafny-standard-libraries" id="markdown-toc-sec-dafny-standard-libraries">13.4. Dafny Standard Libraries</a></li>
      <li><a href="#135-dafny-code-style" id="markdown-toc-135-dafny-code-style">13.5. Dafny Code Style</a></li>
      <li><a href="#command-line" id="markdown-toc-command-line">13.6. Using Dafny From the Command Line</a>        <ul>
          <li><a href="#sec-dafny-commands" id="markdown-toc-sec-dafny-commands">13.6.1. dafny commands</a>            <ul>
              <li><a href="#13611-options-that-are-not-associated-with-a-command" id="markdown-toc-13611-options-that-are-not-associated-with-a-command">13.6.1.1. Options that are not associated with a command</a></li>
              <li><a href="#sec-dafny-resolve" id="markdown-toc-sec-dafny-resolve">13.6.1.2. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">resolve</span></code></a></li>
              <li><a href="#sec-dafny-verify" id="markdown-toc-sec-dafny-verify">13.6.1.3. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">verify</span></code></a></li>
              <li><a href="#sec-dafny-translate" id="markdown-toc-sec-dafny-translate">13.6.1.4. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span> <span class="o">&lt;</span><span class="n">language</span><span class="o">&gt;</span></code></a></li>
              <li><a href="#sec-dafny-build" id="markdown-toc-sec-dafny-build">13.6.1.5. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code></a></li>
              <li><a href="#sec-dafny-run" id="markdown-toc-sec-dafny-run">13.6.1.6. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code></a></li>
              <li><a href="#sec-dafny-server" id="markdown-toc-sec-dafny-server">13.6.1.7. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">server</span></code></a></li>
              <li><a href="#sec-dafny-audit" id="markdown-toc-sec-dafny-audit">13.6.1.8. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">audit</span></code></a></li>
              <li><a href="#sec-dafny-format" id="markdown-toc-sec-dafny-format">13.6.1.9. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">format</span></code></a></li>
              <li><a href="#sec-dafny-test" id="markdown-toc-sec-dafny-test">13.6.1.10. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">test</span></code></a></li>
              <li><a href="#sec-dafny-doc" id="markdown-toc-sec-dafny-doc">13.6.1.11. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">doc</span></code> [Experimental]</a></li>
              <li><a href="#sec-dafny-generate-tests" id="markdown-toc-sec-dafny-generate-tests">13.6.1.12. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">generate</span><span class="o">-</span><span class="n">tests</span></code></a></li>
              <li><a href="#sec-dafny-generate-tests-inlining" id="markdown-toc-sec-dafny-generate-tests-inlining">13.6.1.13. <code class="language-dafny highlighter-rouge"><span class="n">Inlining</span></code></a></li>
              <li><a href="#sec-dafny-generate-tests-clo" id="markdown-toc-sec-dafny-generate-tests-clo">13.6.1.14. <code class="language-dafny highlighter-rouge"><span class="n">Command</span> <span class="n">Line</span> <span class="n">Options</span></code></a></li>
              <li><a href="#sec-dafny-find-dead-code" id="markdown-toc-sec-dafny-find-dead-code">13.6.1.15. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">find</span><span class="o">-</span><span class="n">dead</span><span class="o">-</span><span class="n">code</span></code></a></li>
              <li><a href="#sec-dafny-measure-complexity" id="markdown-toc-sec-dafny-measure-complexity">13.6.1.16. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">measure</span><span class="o">-</span><span class="n">complexity</span></code></a></li>
              <li><a href="#136117-plugins" id="markdown-toc-136117-plugins">13.6.1.17. Plugins</a></li>
              <li><a href="#136118-legacy-operation" id="markdown-toc-136118-legacy-operation">13.6.1.18. Legacy operation</a></li>
            </ul>
          </li>
          <li><a href="#1362-in-tool-help" id="markdown-toc-1362-in-tool-help">13.6.2. In-tool help</a></li>
          <li><a href="#sec-exit-codes" id="markdown-toc-sec-exit-codes">13.6.3. dafny exit codes</a></li>
          <li><a href="#1364-dafny-output" id="markdown-toc-1364-dafny-output">13.6.4. dafny output</a></li>
          <li><a href="#sec-project-files" id="markdown-toc-sec-project-files">13.6.5. Project files</a></li>
        </ul>
      </li>
      <li><a href="#sec-verification" id="markdown-toc-sec-verification">13.7. Verification</a>        <ul>
          <li><a href="#sec-verification-debugging" id="markdown-toc-sec-verification-debugging">13.7.1. Verification debugging when verification fails</a>            <ul>
              <li><a href="#sec-failing-postconditions" id="markdown-toc-sec-failing-postconditions">13.7.1.1. Failing postconditions</a></li>
              <li><a href="#sec-failing-asserts" id="markdown-toc-sec-failing-asserts">13.7.1.2. Failing asserts</a></li>
              <li><a href="#sec-failing-asserts-special-cases" id="markdown-toc-sec-failing-asserts-special-cases">13.7.1.3. Failing asserts cases</a></li>
              <li><a href="#sec-counterexamples" id="markdown-toc-sec-counterexamples">13.7.1.4. Counterexamples</a></li>
            </ul>
          </li>
          <li><a href="#sec-verification-debugging-slow" id="markdown-toc-sec-verification-debugging-slow">13.7.2. Verification debugging when verification is slow</a>            <ul>
              <li><a href="#sec-assume-false" id="markdown-toc-sec-assume-false">13.7.2.1. <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span></code></a></li>
              <li><a href="#sec-verification-debugging-assert-by" id="markdown-toc-sec-verification-debugging-assert-by">13.7.2.2. <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="o">...</span> <span class="kr">by</span> <span class="p">{}</span></code></a></li>
              <li><a href="#sec-labeling-revealing-assertions" id="markdown-toc-sec-labeling-revealing-assertions">13.7.2.3. Labeling and revealing assertions</a></li>
              <li><a href="#sec-non-opaque-function-method" id="markdown-toc-sec-non-opaque-function-method">13.7.2.4. Non-opaque <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">method</span></code></a></li>
              <li><a href="#sec-conversion-to-and-from-bitvectors" id="markdown-toc-sec-conversion-to-and-from-bitvectors">13.7.2.5. Conversion to and from bitvectors</a></li>
              <li><a href="#sec-nested-loops" id="markdown-toc-sec-nested-loops">13.7.2.6. Nested loops</a></li>
            </ul>
          </li>
          <li><a href="#sec-assertion-batches" id="markdown-toc-sec-assertion-batches">13.7.3. Assertion batches, well-formedness, correctness</a>            <ul>
              <li><a href="#sec-assertion-batches-control" id="markdown-toc-sec-assertion-batches-control">13.7.3.1. Controlling assertion batches</a></li>
            </ul>
          </li>
          <li><a href="#sec-command-line-options-and-attributes-for-verification" id="markdown-toc-sec-command-line-options-and-attributes-for-verification">13.7.4. Command-line options and other attributes to control verification</a></li>
          <li><a href="#sec-proof-dependencies" id="markdown-toc-sec-proof-dependencies">13.7.5. Analyzing proof dependencies</a></li>
          <li><a href="#sec-brittle-verification" id="markdown-toc-sec-brittle-verification">13.7.6. Debugging brittle verification</a>            <ul>
              <li><a href="#13761-measuring-proof-brittleness" id="markdown-toc-13761-measuring-proof-brittleness">13.7.6.1. Measuring proof brittleness</a></li>
              <li><a href="#13762-improving-proof-brittleness" id="markdown-toc-13762-improving-proof-brittleness">13.7.6.2. Improving proof brittleness</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#sec-compilation" id="markdown-toc-sec-compilation">13.8. Compilation</a>        <ul>
          <li><a href="#sec-compilation-built-ins" id="markdown-toc-sec-compilation-built-ins">13.8.1.1 Built-in declarations</a></li>
          <li><a href="#sec-extern-decls" id="markdown-toc-sec-extern-decls">13.8.2. <code class="language-dafny highlighter-rouge"><span class="n">extern</span></code> declarations</a></li>
          <li><a href="#1383-replaceable-modules" id="markdown-toc-1383-replaceable-modules">13.8.3. Replaceable modules</a></li>
          <li><a href="#1384-c" id="markdown-toc-1384-c">13.8.4. C#</a></li>
          <li><a href="#1385-java" id="markdown-toc-1385-java">13.8.5. Java</a></li>
          <li><a href="#1386-javascript" id="markdown-toc-1386-javascript">13.8.6. Javascript</a></li>
          <li><a href="#1387-go" id="markdown-toc-1387-go">13.8.7. Go</a></li>
          <li><a href="#1388-python" id="markdown-toc-1388-python">13.8.8. Python</a></li>
          <li><a href="#1389-c" id="markdown-toc-1389-c">13.8.9. C++</a></li>
          <li><a href="#sec-supported-features-by-target-language" id="markdown-toc-sec-supported-features-by-target-language">13.8.10. Supported features by target language</a></li>
        </ul>
      </li>
      <li><a href="#sec-command-line-options" id="markdown-toc-sec-command-line-options">13.9. Dafny Command Line Options</a>        <ul>
          <li><a href="#sec-controlling-help" id="markdown-toc-sec-controlling-help">13.9.1. Help and version information</a></li>
          <li><a href="#sec-controlling-input" id="markdown-toc-sec-controlling-input">13.9.2. Controlling input</a></li>
          <li><a href="#sec-controlling-plugins" id="markdown-toc-sec-controlling-plugins">13.9.3. Controlling plugins</a></li>
          <li><a href="#sec-controlling-output" id="markdown-toc-sec-controlling-output">13.9.4. Controlling output</a></li>
          <li><a href="#sec-controlling-language" id="markdown-toc-sec-controlling-language">13.9.5. Controlling language features</a></li>
          <li><a href="#sec-controlling-warnings" id="markdown-toc-sec-controlling-warnings">13.9.6. Controlling warnings</a></li>
          <li><a href="#sec-controlling-verification" id="markdown-toc-sec-controlling-verification">13.9.7. Controlling verification</a></li>
          <li><a href="#sec-controlling-compilation" id="markdown-toc-sec-controlling-compilation">13.9.8. Controlling compilation</a></li>
          <li><a href="#sec-controlling-boogie" id="markdown-toc-sec-controlling-boogie">13.9.9. Controlling Boogie</a></li>
          <li><a href="#sec-controlling-prover" id="markdown-toc-sec-controlling-prover">13.9.10. Controlling the prover</a></li>
          <li><a href="#sec-controlling-test-gen" id="markdown-toc-sec-controlling-test-gen">13.9.11. Controlling test generation</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#sec-dafny-language-server-vscode" id="markdown-toc-sec-dafny-language-server-vscode">14. Dafny VSCode extension and the Dafny Language Server</a>    <ul>
      <li><a href="#141-dafny-functionality-within-vscode" id="markdown-toc-141-dafny-functionality-within-vscode">14.1. Dafny functionality within VSCode</a></li>
      <li><a href="#sec-gutter-highlights" id="markdown-toc-sec-gutter-highlights">14.2. Gutter highlights</a></li>
      <li><a href="#sec-old-dafny-server" id="markdown-toc-sec-old-dafny-server">14.3. The Dafny Server</a></li>
    </ul>
  </li>
  <li><a href="#sec-plugins" id="markdown-toc-sec-plugins">15. Plugins to Dafny</a>    <ul>
      <li><a href="#151-language-server-plugin-tutorial" id="markdown-toc-151-language-server-plugin-tutorial">15.1. Language Server plugin tutorial</a>        <ul>
          <li><a href="#1511-create-plugin-project" id="markdown-toc-1511-create-plugin-project">15.1.1. Create plugin project</a></li>
          <li><a href="#1512-implement-plugin" id="markdown-toc-1512-implement-plugin">15.1.2. Implement plugin</a>            <ul>
              <li><a href="#15121-code-actions-plugin" id="markdown-toc-15121-code-actions-plugin">15.1.2.1. Code actions plugin</a></li>
              <li><a href="#15122-request-handler-plugin" id="markdown-toc-15122-request-handler-plugin">15.1.2.2. Request handler plugin</a></li>
            </ul>
          </li>
          <li><a href="#1513-building-plugin" id="markdown-toc-1513-building-plugin">15.1.3. Building plugin</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#16-full-list-of-legacy-command-line-options-sec-full-command-line-options-" id="markdown-toc-16-full-list-of-legacy-command-line-options-sec-full-command-line-options-">16. Full list of legacy command-line options {#sec-full-command-line-options} <!-- PDFOMIT --></a></li>
  <li><a href="#sec-grammar-details" id="markdown-toc-sec-grammar-details">17. Dafny Grammar</a>    <ul>
      <li><a href="#171-dafny-syntax" id="markdown-toc-171-dafny-syntax">17.1. Dafny Syntax</a>        <ul>
          <li><a href="#1711-classes-of-characters" id="markdown-toc-1711-classes-of-characters">17.1.1. Classes of characters</a></li>
          <li><a href="#sec-g-tokens" id="markdown-toc-sec-g-tokens">17.1.2. Definitions of tokens</a></li>
        </ul>
      </li>
      <li><a href="#172-dafny-grammar-productions" id="markdown-toc-172-dafny-grammar-productions">17.2. Dafny Grammar productions</a>        <ul>
          <li><a href="#g-program" id="markdown-toc-g-program">17.2.1. Programs</a>            <ul>
              <li><a href="#g-include-directive" id="markdown-toc-g-include-directive">17.2.1.1. Include directives</a></li>
              <li><a href="#g-top-level-declaration" id="markdown-toc-g-top-level-declaration">17.2.1.2. Top-level declarations</a></li>
              <li><a href="#g-declaration-modifier" id="markdown-toc-g-declaration-modifier">17.2.1.3. Declaration modifiers</a></li>
            </ul>
          </li>
          <li><a href="#g-module" id="markdown-toc-g-module">17.2.2. Modules</a>            <ul>
              <li><a href="#g-module-definition" id="markdown-toc-g-module-definition">17.2.2.1. Module Definitions</a></li>
              <li><a href="#g-module-import" id="markdown-toc-g-module-import">17.2.2.2. Module Imports</a></li>
              <li><a href="#g-module-export" id="markdown-toc-g-module-export">17.2.2.3. Module Export Definitions</a></li>
            </ul>
          </li>
          <li><a href="#g-type" id="markdown-toc-g-type">17.2.3. Types</a>            <ul>
              <li><a href="#g-basic-type" id="markdown-toc-g-basic-type">17.2.3.1. Basic types</a></li>
              <li><a href="#g-generic-instantiation" id="markdown-toc-g-generic-instantiation">17.2.3.2. Generic instantiation</a></li>
              <li><a href="#g-type-parameter" id="markdown-toc-g-type-parameter">17.2.3.3. Type parameter</a></li>
              <li><a href="#g-collection-type" id="markdown-toc-g-collection-type">17.2.3.4. Collection types</a></li>
              <li><a href="#g-type-definition" id="markdown-toc-g-type-definition">17.2.3.5. Type definitions</a></li>
              <li><a href="#g-class-type" id="markdown-toc-g-class-type">17.2.3.6. Class type</a></li>
              <li><a href="#g-trait-type" id="markdown-toc-g-trait-type">17.2.3.7. Trait types</a></li>
              <li><a href="#g-object-type" id="markdown-toc-g-object-type">17.2.3.8. Object type</a></li>
              <li><a href="#g-array-type" id="markdown-toc-g-array-type">17.2.3.9. Array types</a></li>
              <li><a href="#g-iterator-type" id="markdown-toc-g-iterator-type">17.2.3.10. Iterator types</a></li>
              <li><a href="#g-arrow-type" id="markdown-toc-g-arrow-type">17.2.3.11. Arrow types</a></li>
              <li><a href="#g-datatype" id="markdown-toc-g-datatype">17.2.3.12. Algebraic datatypes</a></li>
            </ul>
          </li>
          <li><a href="#g-member-declaration" id="markdown-toc-g-member-declaration">17.2.4. Type member declarations</a>            <ul>
              <li><a href="#g-field-declaration" id="markdown-toc-g-field-declaration">17.2.4.1. Fields</a></li>
              <li><a href="#g-const-declaration" id="markdown-toc-g-const-declaration">17.2.4.2. Constant fields</a></li>
              <li><a href="#g-method-declaration" id="markdown-toc-g-method-declaration">17.2.4.3. Method declarations</a></li>
              <li><a href="#g-function-declaration" id="markdown-toc-g-function-declaration">17.2.4.4. Function declarations</a></li>
            </ul>
          </li>
          <li><a href="#1725-specifications" id="markdown-toc-1725-specifications">17.2.5. Specifications</a>            <ul>
              <li><a href="#g-method-specification" id="markdown-toc-g-method-specification">17.2.5.1. Method specifications</a></li>
              <li><a href="#g-function-specification" id="markdown-toc-g-function-specification">17.2.5.2. Function specifications</a></li>
              <li><a href="#g-lambda-specification" id="markdown-toc-g-lambda-specification">17.2.5.3. Lambda function specifications</a></li>
              <li><a href="#g-iterator-specification" id="markdown-toc-g-iterator-specification">17.2.5.4. Iterator specifications</a></li>
              <li><a href="#g-loop-specification" id="markdown-toc-g-loop-specification">17.2.5.5. Loop specifications</a></li>
              <li><a href="#g-requires-clause" id="markdown-toc-g-requires-clause">17.2.5.6. Requires clauses</a></li>
              <li><a href="#g-ensures-clause" id="markdown-toc-g-ensures-clause">17.2.5.7. Ensures clauses</a></li>
              <li><a href="#g-decreases-clause" id="markdown-toc-g-decreases-clause">17.2.5.8. Decreases clauses</a></li>
              <li><a href="#g-modifies-clause" id="markdown-toc-g-modifies-clause">17.2.5.9. Modifies clauses</a></li>
              <li><a href="#g-invariant-clause" id="markdown-toc-g-invariant-clause">17.2.5.10. Invariant clauses</a></li>
              <li><a href="#g-reads-clause" id="markdown-toc-g-reads-clause">17.2.5.11. Reads clauses</a></li>
              <li><a href="#g-frame-expression" id="markdown-toc-g-frame-expression">17.2.5.12. Frame expressions</a></li>
            </ul>
          </li>
          <li><a href="#g-statement" id="markdown-toc-g-statement">17.2.6. Statements</a>            <ul>
              <li><a href="#g-labeled-statement" id="markdown-toc-g-labeled-statement">17.2.6.1. Labeled statement</a></li>
              <li><a href="#g-nonlabeled-statement" id="markdown-toc-g-nonlabeled-statement">17.2.6.2. Non-Labeled statement</a></li>
              <li><a href="#g-break-continue-statement" id="markdown-toc-g-break-continue-statement">17.2.6.3. Break and continue statements</a></li>
              <li><a href="#g-block-statement" id="markdown-toc-g-block-statement">17.2.6.4. Block statement</a></li>
              <li><a href="#g-return-statement" id="markdown-toc-g-return-statement">17.2.6.5. Return statement</a></li>
              <li><a href="#g-yield-statement" id="markdown-toc-g-yield-statement">17.2.6.6. Yield statement</a></li>
              <li><a href="#g-update-and-call-statement" id="markdown-toc-g-update-and-call-statement">17.2.6.7. Update and call statement</a></li>
              <li><a href="#g-update-with-failure-statement" id="markdown-toc-g-update-with-failure-statement">17.2.6.8. Update with failure statement</a></li>
              <li><a href="#g-variable-declaration-statement" id="markdown-toc-g-variable-declaration-statement">17.2.6.9. Variable declaration statement</a></li>
              <li><a href="#g-guard" id="markdown-toc-g-guard">17.2.6.10. Guards</a></li>
              <li><a href="#g-binding-guard" id="markdown-toc-g-binding-guard">17.2.6.11. Binding guards</a></li>
              <li><a href="#g-if-statement" id="markdown-toc-g-if-statement">17.2.6.12. If statement</a></li>
              <li><a href="#g-while-statement" id="markdown-toc-g-while-statement">17.2.6.13. While Statement</a></li>
              <li><a href="#g-for-statement" id="markdown-toc-g-for-statement">17.2.6.14. For statement</a></li>
              <li><a href="#g-match-statement" id="markdown-toc-g-match-statement">17.2.6.15. Match statement</a></li>
              <li><a href="#g-assert-statement" id="markdown-toc-g-assert-statement">17.2.6.16. Assert statement</a></li>
              <li><a href="#g-assume-statement" id="markdown-toc-g-assume-statement">17.2.6.17. Assume statement</a></li>
              <li><a href="#g-expect-statement" id="markdown-toc-g-expect-statement">17.2.6.18. Expect statement</a></li>
              <li><a href="#g-print-statement" id="markdown-toc-g-print-statement">17.2.6.19. Print statement</a></li>
              <li><a href="#g-reveal-statement" id="markdown-toc-g-reveal-statement">17.2.6.20. Reveal statement</a></li>
              <li><a href="#g-forall-statement" id="markdown-toc-g-forall-statement">17.2.6.21. Forall statement</a></li>
              <li><a href="#g-modify-statement" id="markdown-toc-g-modify-statement">17.2.6.22. Modify statement</a></li>
              <li><a href="#g-calc-statement" id="markdown-toc-g-calc-statement">17.2.6.23. Calc statement</a></li>
              <li><a href="#g-opaque-block" id="markdown-toc-g-opaque-block">17.2.6.24. Opaque block</a></li>
            </ul>
          </li>
          <li><a href="#1727-expressions" id="markdown-toc-1727-expressions">17.2.7. Expressions</a>            <ul>
              <li><a href="#g-top-level-expression" id="markdown-toc-g-top-level-expression">17.2.7.1. Top-level expression</a></li>
              <li><a href="#g-equivalence-expression" id="markdown-toc-g-equivalence-expression">17.2.7.2. Equivalence expression</a></li>
              <li><a href="#g-implies-expression" id="markdown-toc-g-implies-expression">17.2.7.3. Implies expression</a></li>
              <li><a href="#g-logical-expression" id="markdown-toc-g-logical-expression">17.2.7.4. Logical expression</a></li>
              <li><a href="#g-relational-expression" id="markdown-toc-g-relational-expression">17.2.7.5. Relational expression</a></li>
              <li><a href="#g-bit-shift-expression" id="markdown-toc-g-bit-shift-expression">17.2.7.6. Bit-shift expression</a></li>
              <li><a href="#g-term" id="markdown-toc-g-term">17.2.7.7. Term (addition operations)</a></li>
              <li><a href="#g-factor" id="markdown-toc-g-factor">17.2.7.8. Factor (multiplication operations)</a></li>
              <li><a href="#g-bit-vector-expression" id="markdown-toc-g-bit-vector-expression">17.2.7.9. Bit-vector expression</a></li>
              <li><a href="#g-as-is-expression" id="markdown-toc-g-as-is-expression">17.2.7.10. As/Is expression</a></li>
              <li><a href="#g-unary-expression" id="markdown-toc-g-unary-expression">17.2.7.11. Unary expression</a></li>
              <li><a href="#g-primary-expression" id="markdown-toc-g-primary-expression">17.2.7.12. Primary expression</a></li>
              <li><a href="#g-lambda-expression" id="markdown-toc-g-lambda-expression">17.2.7.13. Lambda expression</a></li>
              <li><a href="#g-lhs-expression" id="markdown-toc-g-lhs-expression">17.2.7.14. Left-hand-side expression</a></li>
              <li><a href="#g-rhs-expression" id="markdown-toc-g-rhs-expression">17.2.7.15. Right-hand-side expression</a></li>
              <li><a href="#g-array-allocation-expression" id="markdown-toc-g-array-allocation-expression">17.2.7.16. Array allocation right-hand-side expression</a></li>
              <li><a href="#g-object-allocation-expression" id="markdown-toc-g-object-allocation-expression">17.2.7.17. Object allocation right-hand-side expression</a></li>
              <li><a href="#g-havoc-expression" id="markdown-toc-g-havoc-expression">17.2.7.18. Havoc right-hand-side expression</a></li>
              <li><a href="#g-atomic-expression" id="markdown-toc-g-atomic-expression">17.2.7.19. Atomic expressions</a></li>
              <li><a href="#g-literal-expression" id="markdown-toc-g-literal-expression">17.2.7.20. Literal expressions</a></li>
              <li><a href="#g-this-expression" id="markdown-toc-g-this-expression">17.2.7.21. This expression</a></li>
              <li><a href="#g-old-expression" id="markdown-toc-g-old-expression">17.2.7.22. Old and Old@ Expressions</a></li>
              <li><a href="#g-fresh-expression" id="markdown-toc-g-fresh-expression">17.2.7.23. Fresh Expressions</a></li>
              <li><a href="#g-allocated-expression" id="markdown-toc-g-allocated-expression">17.2.7.24. Allocated Expressions</a></li>
              <li><a href="#g-unchanged-expression" id="markdown-toc-g-unchanged-expression">17.2.7.25. Unchanged Expressions</a></li>
              <li><a href="#g-cardinality-expression" id="markdown-toc-g-cardinality-expression">17.2.7.26. Cardinality Expressions</a></li>
              <li><a href="#g-parenthesized-expression" id="markdown-toc-g-parenthesized-expression">17.2.7.27. Parenthesized Expression</a></li>
              <li><a href="#g-sequence-display-expression" id="markdown-toc-g-sequence-display-expression">17.2.7.28. Sequence Display Expression</a></li>
              <li><a href="#g-set-display-expression" id="markdown-toc-g-set-display-expression">17.2.7.29. Set Display Expression</a></li>
              <li><a href="#g-map-display-expression" id="markdown-toc-g-map-display-expression">17.2.7.30. Map Display Expression</a></li>
              <li><a href="#g-endless-expression" id="markdown-toc-g-endless-expression">17.2.7.31. Endless Expression</a></li>
              <li><a href="#g-if-expression" id="markdown-toc-g-if-expression">17.2.7.32. If expression</a></li>
              <li><a href="#g-match-expression" id="markdown-toc-g-match-expression">17.2.7.33. Match Expression</a></li>
              <li><a href="#g-pattern" id="markdown-toc-g-pattern">17.2.7.34. Case and Extended Patterns</a></li>
              <li><a href="#g-quantifier-expression" id="markdown-toc-g-quantifier-expression">17.2.7.35. Quantifier expression</a></li>
              <li><a href="#g-set-comprehension-expression" id="markdown-toc-g-set-comprehension-expression">17.2.7.36. Set Comprehension Expressions</a></li>
              <li><a href="#g-map-comprehension-expression" id="markdown-toc-g-map-comprehension-expression">17.2.7.37. Map Comprehension Expression</a></li>
              <li><a href="#g-statement-in-expression" id="markdown-toc-g-statement-in-expression">17.2.7.38. Statements in an Expression</a></li>
              <li><a href="#g-let-expression" id="markdown-toc-g-let-expression">17.2.7.39. Let and Let or Fail Expression</a></li>
              <li><a href="#g-name-segment" id="markdown-toc-g-name-segment">17.2.7.40. Name Segment</a></li>
              <li><a href="#g-hash-call" id="markdown-toc-g-hash-call">17.2.7.41. Hash Call</a></li>
              <li><a href="#g-suffix" id="markdown-toc-g-suffix">17.2.7.42. Suffix</a></li>
              <li><a href="#g-augmented-dot-suffix" id="markdown-toc-g-augmented-dot-suffix">17.2.7.43. Augmented Dot Suffix</a></li>
              <li><a href="#g-datatype-update-suffix" id="markdown-toc-g-datatype-update-suffix">17.2.7.44. Datatype Update Suffix</a></li>
              <li><a href="#g-subsequence-suffix" id="markdown-toc-g-subsequence-suffix">17.2.7.45. Subsequence Suffix</a></li>
              <li><a href="#g-subsequence-slices-suffix" id="markdown-toc-g-subsequence-slices-suffix">17.2.7.46. Subsequence Slices Suffix</a></li>
              <li><a href="#g-sequence-update-suffix" id="markdown-toc-g-sequence-update-suffix">17.2.7.47. Sequence Update Suffix</a></li>
              <li><a href="#g-selection-suffix" id="markdown-toc-g-selection-suffix">17.2.7.48. Selection Suffix</a></li>
              <li><a href="#g-argument-list-suffix" id="markdown-toc-g-argument-list-suffix">17.2.7.49. Argument List Suffix</a></li>
              <li><a href="#g-expression-list" id="markdown-toc-g-expression-list">17.2.7.50. Expression Lists</a></li>
              <li><a href="#g-parameter-bindings" id="markdown-toc-g-parameter-bindings">17.2.7.51. Parameter Bindings</a></li>
              <li><a href="#g-quantifier-domain" id="markdown-toc-g-quantifier-domain">17.2.7.52. Quantifier domains</a></li>
              <li><a href="#172753-basic-name-and-type-combinations" id="markdown-toc-172753-basic-name-and-type-combinations">17.2.7.53. Basic name and type combinations</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#18-testing-syntax-rendering" id="markdown-toc-18-testing-syntax-rendering">18. Testing syntax rendering</a></li>
  <li><a href="#19-references" id="markdown-toc-19-references">19. References</a></li>
</ul>

<h2 id="sec-introduction">1. Introduction</h2>

<p>Dafny [@Leino:Dafny:LPAR16] is a programming language with built-in specification constructs,
so that verifying a programs correctness with respect to those specifications
is a natural part of writing software.
The Dafny static program verifier can be used to verify the functional
correctness of programs.
This document is a reference manual for the programming language and a user guide
for the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool that performs verification and compilation to an
executable form.</p>

<p>The Dafny programming language is designed to support the static
verification of programs. It is imperative, sequential, supports generic
classes, inheritance and abstraction, methods and functions, dynamic allocation, inductive and
coinductive datatypes, and specification constructs. The
specifications include pre- and postconditions, frame specifications
(read and write sets), and termination metrics. To further support
specifications, the language also offers updatable ghost variables,
recursive functions, and types like sets and sequences. Specifications
and ghost constructs are used only during verification; the compiler
omits them from the executable code.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> verifier is run as part of the compiler. As such, a programmer
interacts with it in much the same way as with the static type
checkerwhen the tool produces errors, the programmer responds by
changing the programs type declarations, specifications, and statements.</p>

<p>(This document typically uses Dafny to refer to the programming language
and <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> to refer to the software tool that verifies and compiles programs
in the Dafny language.)</p>

<p>The easiest way to try out the Dafny language is to <a href="https://github.com/dafny-lang/dafny/releases">download the supporting tools and documentation</a> and
run <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> on your machine as you follow along with the <a href="../OnlineTutorial/guide">Dafny tutorial</a>.
The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool can be run from the command line (on Linux, MacOS, Windows or other platforms) or from IDEs
such as emacs and VSCode, which can provide syntax highlighting and code manipulation capabilities.</p>

<p>The verifier is powered
by <a href="http://research.microsoft.com/boogie">Boogie</a>
[@Boogie:Architecture;@Leino:Boogie2-RefMan;@LeinoRuemmer:Boogie2]
and <a href="https://github.com/z3prover">Z3</a> [@deMouraBjorner:Z3:overview].</p>

<p>From verified programs, the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> compiler can produce code for a number
of different backends:
the .NET platform via intermediate C# files, Java, Javascript, Go, and C++.
Each language provides a basic Foreign Function Interface (through uses of <code class="language-dafny highlighter-rouge"><span class="o">:</span><span class="n">extern</span></code>)
and a supporting runtime library.</p>

<p>This reference manual for the Dafny verification system is
based on the following references:
[@Leino:Dafny:LPAR16],
[@MSR:dafny:main],
[@LEINO:Dafny:Calc],
[@LEINO:Dafny:Coinduction],
<a href="http://research.microsoft.com/en-us/um/people/leino/papers/krml230.pdf">Co-induction Simply</a>.</p>

<p>The main part of the reference manual is in top down order except for an
initial section that deals with the lowest level constructs.</p>

<p>The details of using (and contributing to) the dafny tool are described in the User Guide (<a href="#sec-user-guide">Section 13</a>).</p>

<h3 id="11-dafny-40">1.1. Dafny 4.0</h3>

<p>The most recent major version of the Dafny language is Dafny 4.0, released in February 2023.
It has some backwards incompatibilities with Dafny 3, as decribed in the <a href="https://github.com/dafny-lang/ide-vscode/wiki/Quick-migration-guide-from-Dafny-3.X-to-Dafny-4.0">migration guide</a>.</p>

<p>The user documentation has been expanded with more examples, a FAQ, and an error explanation catalog.
There is even a new book, <a href="https://mitpress.mit.edu/9780262546232/program-proofs/">Program Proofs</a> by Dafny designer Rustan Leino.</p>

<p>The IDE now has a framework for showing error explanation information and corresponding quick fixes are
being added, with refactoring operations on the horizon.</p>

<p>More details of 4.0 functionality are described in the release notes.</p>
<h3 id="sec-example">1.2. Dafny Example</h3>
<p>To give a flavor of Dafny, here is the solution to a competition problem.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// VSComp 2010, problem 3, find a 0 in a linked list and return</span>
<span class="c1">// how many nodes were skipped until the first 0 (or end-of-list)</span>
<span class="c1">// was found.</span>
<span class="c1">// Rustan Leino, 18 August 2010.</span>
<span class="c1">//</span>
<span class="c1">// The difficulty in this problem lies in specifying what the</span>
<span class="c1">// return value 'r' denotes and in proving that the program</span>
<span class="c1">// terminates.  Both of these are addressed by declaring a ghost</span>
<span class="c1">// field 'List' in each linked-list node, abstractly representing</span>
<span class="c1">// the linked-list elements from the node to the end of the linked</span>
<span class="c1">// list.  The specification can now talk about that sequence of</span>
<span class="c1">// elements and can use 'r' as an index into the sequence, and</span>
<span class="c1">// termination can be proved from the fact that all sequences in</span>
<span class="c1">// Dafny are finite.</span>
<span class="c1">//</span>
<span class="c1">// We only want to deal with linked lists whose 'List' field is</span>
<span class="c1">// properly filled in (which can only happen in an acyclic list,</span>
<span class="c1">// for example).  To that end, the standard idiom in Dafny is to</span>
<span class="c1">// declare a predicate 'Valid()' that is true of an object when</span>
<span class="c1">// the data structure representing that object's abstract value</span>
<span class="c1">// is properly formed.  The definition of 'Valid()' is what one</span>
<span class="c1">// intuitively would think of as the ''object invariant'', and</span>
<span class="c1">// it is mentioned explicitly in method pre- and postconditions.</span>
<span class="c1">//</span>
<span class="c1">// As part of this standard idiom, one also declares a ghost</span>
<span class="c1">// variable 'Repr' that is maintained as the set of objects that</span>
<span class="c1">// make up the representation of the aggregate object--in this</span>
<span class="c1">// case, the Node itself and all its successors.</span>
<span class="kr">module</span> <span class="p">{</span><span class="o">:</span><span class="n">options</span> <span class="s2">"--function-syntax:4"</span><span class="p">}</span> <span class="n">M</span> <span class="p">{</span>
<span class="kr">class</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">List</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">Repr</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span>
  <span class="kr">var</span> <span class="n">head</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">next</span><span class="o">:</span> <span class="n">Node?</span> <span class="c1">// Node? means a Node value or null</span>

  <span class="kr">ghost</span> <span class="kr">predicate</span> <span class="n">Valid</span><span class="p">()</span>
    <span class="kr">reads</span> <span class="kr">this</span><span class="p">,</span> <span class="n">Repr</span>
  <span class="p">{</span>
    <span class="kr">this</span> <span class="ow">in</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span>
    <span class="mi">1</span> <span class="o">&lt;=</span> <span class="o">|</span><span class="n">List</span><span class="o">|</span> <span class="o">&amp;&amp;</span> <span class="n">List</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">==&gt;</span> <span class="o">|</span><span class="n">List</span><span class="o">|</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">==&gt;</span>
      <span class="n">next</span> <span class="ow">in</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">.</span><span class="n">Repr</span> <span class="o">&lt;=</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="kr">this</span> <span class="o">!</span><span class="ow">in</span> <span class="n">next</span><span class="o">.</span><span class="n">Repr</span> <span class="o">&amp;&amp;</span>
      <span class="n">next</span><span class="o">.</span><span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="o">.</span><span class="n">List</span> <span class="o">==</span> <span class="n">List</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>
  <span class="p">}</span>

  <span class="kr">static</span> <span class="kr">method</span> <span class="n">Cons</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">Node?</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Node</span><span class="p">)</span>
    <span class="kr">requires</span> <span class="n">tail</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">tail</span><span class="o">.</span><span class="n">Valid</span><span class="p">()</span>
    <span class="kr">ensures</span> <span class="n">n</span><span class="o">.</span><span class="n">Valid</span><span class="p">()</span>
    <span class="kr">ensures</span> <span class="kr">if</span> <span class="n">tail</span> <span class="o">==</span> <span class="kc">null</span> <span class="kr">then</span> <span class="n">n</span><span class="o">.</span><span class="n">List</span> <span class="o">==</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
                            <span class="kr">else</span> <span class="n">n</span><span class="o">.</span><span class="n">List</span> <span class="o">==</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">List</span>
  <span class="p">{</span>
    <span class="n">n</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Node</span><span class="p">;</span>
    <span class="n">n</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">next</span> <span class="o">:=</span> <span class="n">x</span><span class="p">,</span> <span class="n">tail</span><span class="p">;</span>
    <span class="kr">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">n</span><span class="o">.</span><span class="n">List</span> <span class="o">:=</span> <span class="p">[</span><span class="n">x</span><span class="p">];</span>
      <span class="n">n</span><span class="o">.</span><span class="n">Repr</span> <span class="o">:=</span> <span class="p">{</span><span class="n">n</span><span class="p">};</span>
    <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
      <span class="n">n</span><span class="o">.</span><span class="n">List</span> <span class="o">:=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">List</span><span class="p">;</span>
      <span class="n">n</span><span class="o">.</span><span class="n">Repr</span> <span class="o">:=</span> <span class="p">{</span><span class="n">n</span><span class="p">}</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">Repr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Search</span><span class="p">(</span><span class="n">ll</span><span class="o">:</span> <span class="n">Node?</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">ll</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">ll</span><span class="o">.</span><span class="n">Valid</span><span class="p">()</span>
  <span class="kr">ensures</span> <span class="n">ll</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">==&gt;</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="kr">ensures</span> <span class="n">ll</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">==&gt;</span>
            <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="o">|</span><span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="o">|</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="o">|</span> <span class="o">==&gt;</span>
              <span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">!</span><span class="ow">in</span> <span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="o">..</span><span class="n">r</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">|</span><span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="o">|</span> <span class="o">==&gt;</span> <span class="mi">0</span> <span class="o">!</span><span class="ow">in</span> <span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">jj</span><span class="p">,</span><span class="n">i</span> <span class="o">:=</span> <span class="n">ll</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span>
    <span class="kr">while</span> <span class="p">(</span><span class="n">jj</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">jj</span><span class="o">.</span><span class="n">head</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="kr">invariant</span> <span class="n">jj</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">==&gt;</span>
            <span class="n">jj</span><span class="o">.</span><span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
            <span class="n">i</span> <span class="o">+</span> <span class="o">|</span><span class="n">jj</span><span class="o">.</span><span class="n">List</span><span class="o">|</span> <span class="o">==</span> <span class="o">|</span><span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="o">|</span> <span class="o">&amp;&amp;</span>
            <span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">]</span> <span class="o">==</span> <span class="n">jj</span><span class="o">.</span><span class="n">List</span>
      <span class="kr">invariant</span> <span class="n">jj</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">==&gt;</span> <span class="n">i</span> <span class="o">==</span> <span class="o">|</span><span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="o">|</span>
      <span class="kr">invariant</span> <span class="mi">0</span> <span class="o">!</span><span class="ow">in</span> <span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="o">..</span><span class="n">i</span><span class="p">]</span>
      <span class="kr">decreases</span> <span class="o">|</span><span class="n">ll</span><span class="o">.</span><span class="n">List</span><span class="o">|</span> <span class="o">-</span> <span class="n">i</span>
    <span class="p">{</span>
      <span class="n">jj</span> <span class="o">:=</span> <span class="n">jj</span><span class="o">.</span><span class="n">next</span><span class="p">;</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">list</span><span class="o">:</span> <span class="n">Node?</span> <span class="o">:=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="n">list</span> <span class="o">:=</span> <span class="n">list</span><span class="o">.</span><span class="n">Cons</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
  <span class="n">list</span> <span class="o">:=</span> <span class="n">list</span><span class="o">.</span><span class="n">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
  <span class="n">list</span> <span class="o">:=</span> <span class="n">list</span><span class="o">.</span><span class="n">Cons</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
  <span class="n">list</span> <span class="o">:=</span> <span class="n">list</span><span class="o">.</span><span class="n">Cons</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">Search</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
  <span class="kr">print</span> <span class="s2">"Search returns "</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="s2">"\n"</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<!--PDF NEWPAGE-->
<h2 id="sec-lexical-grammar">2. Lexical and Low Level Grammar</h2>

<p>As with most languages, Dafny syntax is defined in two levels. First the stream
of input characters is broken up into <em>tokens</em>. Then these tokens are parsed
using the Dafny grammar.</p>

<p>The Dafny grammar is designed as an <em>attributed grammar</em>, which is a 
conventional BNF-style set of productions, but in which the productions can
have arguments. The arguments control some alternatives within
the productions, such as whether an alternative is allowed or not in a specific context.
These arguments allow for a more compact and understandable grammar.</p>

<p>The precise, technical details of the grammar are presented together in <a href="#sec-grammar-details">Section 17</a>.
The expository parts of this manual present the language structure less formally.
Throughout this document there are embedded hyperlinks to relevant grammar sections, 
marked as <a href="#sec-grammar-details">grammar</a>.</p>

<h3 id="sec-unicode">2.1. Dafny Input</h3>

<p>Dafny source code files are readable text encoded in UTF-8.
All program text other than the contents of comments, character, string and verbatim string literals
consists of printable and white-space ASCII characters,
that is, ASCII characters in the range <code class="language-dafny highlighter-rouge"><span class="o">!</span></code> to <code class="language-dafny highlighter-rouge"><span class="err">~</span></code>, plus space, tab, 
carriage return and newline (ASCII 9, 10, 13, 32) characters.
(In some past versions of Dafny, non-ASCII, unicode representations of some mathematical symbols were
permitted in Dafny source text; these are no longer recognized.)</p>

<p>String and character literals and comments may contain any unicode character,
either directly or as an escape sequence.</p>

<h3 id="sec-token-types">2.2. Tokens and whitespace</h3>
<p>The characters used in a Dafny program fall into four groups:</p>

<ul>
  <li>White space characters: space, tab, carriage return and newline</li>
  <li>alphanumerics: letters, digits, underscore (<code class="language-dafny highlighter-rouge"><span class="n">_</span></code>), apostrophe (<code class="language-dafny highlighter-rouge"><span class="err">'</span></code>), and question mark (<code class="language-dafny highlighter-rouge"><span class="n">?</span></code>)</li>
  <li>punctuation: <code class="language-dafny highlighter-rouge"><span class="p">(){}[],</span><span class="o">.</span><span class="p">`;</span></code></li>
  <li>operator characters (the other printable characters)</li>
</ul>

<p>Except for string and character literals, each Dafny token consists of a 
sequence of consecutive characters from just one of these
groups, excluding white-space. White-space is ignored except that it
separates tokens and except in the bodies of character and string literals.</p>

<p>A sequence of alphanumeric characters (with no preceding or following additional
alphanumeric characters) is a <em>single</em> token. This is true even if the token
is syntactically or semantically invalid and the sequence could be separated into
more than one valid token. For example, <code class="language-dafny highlighter-rouge"><span class="n">assert56</span></code> is one identifier token,
not a keyword <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> followed by a number; <code class="language-dafny highlighter-rouge"><span class="n">ifb</span><span class="o">!=</span><span class="mi">0</span></code> begins with the token
<code class="language-dafny highlighter-rouge"><span class="n">ifb</span></code> and not with the keyword <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> and token <code class="language-dafny highlighter-rouge"><span class="n">b</span></code>; <code class="language-dafny highlighter-rouge"><span class="err">0xFFFFZZ</span></code> is an illegal
token, not a valid hex number <code class="language-dafny highlighter-rouge"><span class="mh">0xFFFF</span></code> followed by an identifier <code class="language-dafny highlighter-rouge"><span class="n">ZZ</span></code>.
White-space must be used to separate two such tokens in a program.</p>

<p>Somewhat differently, operator tokens need not be separated.
Only specific sequences of operator characters are recognized and these
are somewhat context-sensitive. For example, in <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span></code>, the grammar
knows that <code class="language-dafny highlighter-rouge"><span class="o">&gt;&gt;</span></code> is two individual <code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code> tokens terminating the nested
type parameter lists; the right shift operator <code class="language-dafny highlighter-rouge"><span class="o">&gt;&gt;</span></code> would never be valid here. Similarly, the
sequence <code class="language-dafny highlighter-rouge"><span class="o">==&gt;</span></code> is always one token; even if it were invalid in its context,
separating it into <code class="language-dafny highlighter-rouge"><span class="o">==</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code> would always still be invalid.</p>

<p>In summary, except for required white space between alphanumeric tokens,
adding or removing white space between tokens can never result in changing the meaning of a Dafny program.
For most of this document, we consider Dafny programs as sequences of tokens.</p>

<h3 id="sec-character-classes">2.3. Character Classes</h3>

<p>This section defines character classes used later in the token definitions.
In this section</p>

<ul>
  <li>a backslash is used to start an escape sequence (so for example
<code class="language-dafny highlighter-rouge"><span class="sc">'\n'</span></code> denotes the single linefeed character)</li>
  <li>double quotes
enclose the set of characters constituting a character class</li>
  <li>enclosing single
quotes are used when there is just one character in the class
(perhaps expressed with a <code class="language-dafny highlighter-rouge"><span class="err">\</span></code> escape character)</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">+</span></code> indicates
the union of two character classes</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">-</span></code> is the set-difference between the
two classes</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">ANY</span></code> designates all <a href="#sec-unicode">unicode characters</a>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>name</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>letter</td>
      <td>ASCII upper or lower case letter; no unicode characters</td>
    </tr>
    <tr>
      <td>digit</td>
      <td>base-ten digit (0123456789)</td>
    </tr>
    <tr>
      <td>posDigit</td>
      <td>digits, excluding 0 (123456789)</td>
    </tr>
    <tr>
      <td>posDigitFrom2</td>
      <td>digits excluding 0 and 1 (23456789)</td>
    </tr>
    <tr>
      <td>hexdigit</td>
      <td>a normal hex digit (0123456789abcdefABCDEF)</td>
    </tr>
    <tr>
      <td>special</td>
      <td>`?_</td>
    </tr>
    <tr>
      <td>cr</td>
      <td>carriage return character (ASCII 10)</td>
    </tr>
    <tr>
      <td>lf</td>
      <td>line feed character (ASCII 13)</td>
    </tr>
    <tr>
      <td>tab</td>
      <td>tab character (ASCII 9)</td>
    </tr>
    <tr>
      <td>space</td>
      <td>space character (ASCII 32)</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>nondigitIdChar</td>
      <td>characters allowed in an identifier, except digits (letter + special)</td>
    </tr>
    <tr>
      <td>idchar</td>
      <td>characters allowed in an identifier (nondigitIdChar + digits)</td>
    </tr>
    <tr>
      <td>nonidchar</td>
      <td>characters not in identifiers (ANY - idchar)</td>
    </tr>
    <tr>
      <td>charChar</td>
      <td>characters allowed in a character constant (ANY - ' - \ - cr - lf)</td>
    </tr>
    <tr>
      <td>stringChar</td>
      <td>characters allowed in a string constant (ANY -  - \ - cr - lf)</td>
    </tr>
    <tr>
      <td>verbatimStringChar</td>
      <td>characters allowed in a verbatim string constant (ANY - )</td>
    </tr>
  </tbody>
</table>

<p>The <em>special</em> characters are the characters in addition to alphanumeric characters
that are allowed to appear in a Dafny identifier. These are</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="err">'</span></code> because mathematicians like to put primes on identifiers and some ML
programmers like to start names of type parameters with a <code class="language-dafny highlighter-rouge"><span class="err">'</span></code>,</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">_</span></code> because computer scientists expect to be able to have underscores in identifiers, and</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">?</span></code> because it is useful to have <code class="language-dafny highlighter-rouge"><span class="n">?</span></code> at the end of names of predicates,
e.g., <code class="language-dafny highlighter-rouge"><span class="n">Cons?</span></code>.</li>
</ul>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">nonidchar</span></code> is any character except those that can be used in an identifier.
Here the scanner generator will interpret <code class="language-dafny highlighter-rouge"><span class="n">ANY</span></code> as any unicode character.
However, <code class="language-dafny highlighter-rouge"><span class="n">nonidchar</span></code> is used only to mark the end of the <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="ow">in</span></code> token;
in this context any character other than <a href="#sec-unicode">whitespace or printable ASCII</a>
will trigger a subsequent scanning or parsing error.</p>

<h3 id="sec-comments">2.4. Comments</h3>
<p>Comments are in two forms.</p>

<ul>
  <li>They may go from <code class="language-dafny highlighter-rouge"><span class="cm">/*</span></code> to <code class="language-dafny highlighter-rouge"><span class="err">*/</span></code> .</li>
  <li>They may go from <code class="language-dafny highlighter-rouge"><span class="c1">//</span></code> to the end of the line.</li>
</ul>

<p>A comment is identified as a token during the tokenization of 
input text and is then discarded for the purpose of interpreting the 
Dafny program. (It is retained to enable auto-formatting
and provide accurate source locations for error messages.)
Thus comments are token separators: <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="cm">/*x*/</span><span class="n">b</span></code> becomes two tokens
<code class="language-dafny highlighter-rouge"><span class="n">a</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">b</span></code>.</p>

<p>Comments may be nested,
but note that the nesting of multi-line comments is behavior that is different
from most programming languages. In Dafny,
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* comment
     /* nested comment
     */
     rest of outer comment
  */</span>
<span class="p">}</span>
</code></pre></div></div>
<p>is permitted; this feature is convenient for commenting out blocks of
program statements that already have multi-line comments within them.
Other than looking for end-of-comment delimiters,
the contents of a comment are not interpreted.
Comments may contain any characters.</p>

<p>Note that the nesting is not fool-proof. In
<!-- %check-resolve Grammar.1.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* var i: int;
     // */</span> <span class="n">line</span> <span class="n">comment</span>
     <span class="kr">var</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="err">*/</span>
<span class="p">}</span>
</code></pre></div></div>
<p>and
<!-- %check-resolve Grammar.2.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* var i: int;
     var s: string := "a*/</span><span class="n">b</span><span class="err">";</span>
     <span class="kr">var</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
   <span class="err">*/</span>
<span class="p">}</span>
</code></pre></div></div>
<p>the <code class="language-dafny highlighter-rouge"><span class="err">*/</span></code> inside the line comment and the string are seen as the end of the outer
comment, leaving trailing text that will provoke parsing errors.</p>

<h3 id="sec-documentation-comments">2.5. Documentation comments</h3>

<p>Like many other languages, Dafny permits <em>documentation comments</em> in a program file.
Such comments contain natural language descriptions of program elements and may be used
by IDEs and documentation generation tools to present information to users.</p>

<p>In Dafny programs.</p>
<ul>
  <li>Documentation comments (a) either begin with <code class="language-dafny highlighter-rouge"><span class="cm">/**</span></code> or (b) begin with <code class="language-dafny highlighter-rouge"><span class="c1">//</span></code> or /*` in specific locations</li>
  <li>Documentation comments may be associated with any declaration, including type definitions, export declarations, and datatype constructors.</li>
  <li>They may be placed before the declaration, between the declaration and the definition or after the definition. The priority of these comments is the following:
    <ul>
      <li>If there is a comment starting with <code class="language-dafny highlighter-rouge"><span class="cm">/**</span></code> right before the definition, its the documentation comment.</li>
      <li>Otherwise, if one or more comments appear between a declaration and its definition  which is uncommon in other programming languages  they are treated as documentation comments, regardless of whether they start with //, /<em>*, or /</em>. This is because there is no other plausible reason for a comment to be placed in this position.</li>
      <li>Otherwise, if there is a single comment starting with <code class="language-dafny highlighter-rouge"><span class="c1">//</span></code> or <code class="language-dafny highlighter-rouge"><span class="cm">/**</span></code> or <code class="language-dafny highlighter-rouge"><span class="cm">/*</span></code> at the end of the definition, its the documentation comment. In this case, multi-line documentation comments must be starting with <code class="language-dafny highlighter-rouge"><span class="cm">/*</span></code></li>
    </ul>
  </li>
  <li>The extraction of the doc-string from a documentation comment follows the following rules
    <ul>
      <li>On the first line, an optional <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> right after <code class="language-dafny highlighter-rouge"><span class="cm">/*</span></code> and an optional space are removed, if present</li>
      <li>On other lines, the indentation space (with possibly one star in it) is removed, as if the content was supposed to align with A if the comment started with <code class="language-dafny highlighter-rouge"><span class="cm">/** A</span></code> for example.</li>
    </ul>
  </li>
  <li>The documentation string is interpreted as plain text, but it is possible to provide a user-written
plugin that provides other interpretations. VSCode as used by Dafny interprets any markdown
syntax in the doc-string.</li>
</ul>

<p>Here are examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="cm">/* Just a comment */</span>
<span class="kr">const</span> <span class="n">c0</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">8</span> <span class="c1">// docstring about c0</span>
<span class="c1">// Just a comment</span>

<span class="cm">/** docstring about c1 */</span>
<span class="kr">newtype</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="c1">// Just a comment</span>

<span class="cm">/* Just a comment */</span>
<span class="kr">function</span> <span class="n">c2</span><span class="p">()</span><span class="o">:</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// Docstring about c2</span>
  <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="p">{</span> <span class="mi">8</span> <span class="p">}</span> <span class="c1">// Just a comment</span>

<span class="c1">// just a comment</span>
<span class="kr">const</span> <span class="n">c5</span> <span class="o">:=</span> <span class="mi">8</span>
</code></pre></div></div>

<p>Datatype constructors may also have comments:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">T</span> <span class="c1">// Docstring for T</span>
<span class="o">=</span> <span class="o">|</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span>
      <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// Docstring for A</span>
  <span class="o">|</span> <span class="n">B</span><span class="p">()</span>       <span class="cm">/* Docstring for B */</span> <span class="o">|</span>
    <span class="n">C</span><span class="p">()</span>       <span class="c1">// Docstring for C</span>

<span class="cm">/** Docstring for T0 */</span>
<span class="kr">datatype</span> <span class="n">T0</span> <span class="o">=</span>
  <span class="o">|</span> <span class="cm">/** Docstring for A */</span>
    <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span>
      <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="o">|</span> <span class="cm">/** Docstring for B */</span>
    <span class="n">B</span><span class="p">()</span>
  <span class="o">|</span> <span class="cm">/** Docstring for C */</span>
    <span class="n">C</span><span class="p">()</span>
</code></pre></div></div>

<p>As can <code class="language-dafny highlighter-rouge"><span class="kr">export</span></code> declarations:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">A</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">const</span> <span class="n">B</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">const</span> <span class="n">C</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">const</span> <span class="n">D</span><span class="o">:</span> <span class="kt">int</span>

  <span class="kr">export</span>
    <span class="c1">// This is the docstring of the eponymous export set intended for most clients</span>
    <span class="kr">provides</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>

  <span class="cm">/** This is the docstring */</span>
  <span class="kr">export</span> <span class="n">AB</span> <span class="kr">provides</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>

  <span class="kr">export</span> <span class="n">Friends</span> <span class="kr">extends</span> <span class="n">AB</span>
    <span class="c1">// This is the docstring of the export set is for clients who need to know more of the</span>
    <span class="c1">// details of the module's definitions.</span>
    <span class="kr">reveals</span> <span class="n">A</span>
    <span class="kr">provides</span> <span class="n">D</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="sec-tokens">2.6. Tokens (<a href="#sec-g-tokens">grammar</a>)</h3>

<p>The Dafny tokens are defined in this section.</p>

<h4 id="sec-reserved-words">2.6.1. Reserved Words</h4>

<p>Dafny has a set of reserved words that may not
be used as identifiers of user-defined entities.
These are listed <a href="#sec-g-tokens">here</a>.</p>

<p>In particular note that</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="kt">array</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">array2</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">array3</span></code>, etc. are reserved words, denoting array types of given rank.
However,  <code class="language-dafny highlighter-rouge"><span class="n">array1</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">array0</span></code> are ordinary identifiers.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kt">array?</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">array2?</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">array3?</span></code>, etc. are reserved words, 
denoting possibly-null array types of given rank,
but not <code class="language-dafny highlighter-rouge"><span class="n">array1?</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">array0?</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kt">bv0</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">bv1</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">bv2</span></code>, etc. are reserved words that denote the types of
bitvectors of given length.
The sequence of digits after array or bv may not have leading zeros: 
for example, <code class="language-dafny highlighter-rouge"><span class="n">bv02</span></code> is an ordinary identifier.</li>
</ul>

<h4 id="sec-identifiers">2.6.2. Identifiers</h4>

<p>In general, an <code class="language-dafny highlighter-rouge"><span class="n">ident</span></code> token (an identifier) is a sequence of <code class="language-dafny highlighter-rouge"><span class="n">idchar</span></code> characters where
the first character is a <code class="language-dafny highlighter-rouge"><span class="n">nondigitIdChar</span></code>. However tokens that fit this pattern
are not identifiers if they look like a character literal
or a reserved word (including array or bit-vector type tokens).
Also, <code class="language-dafny highlighter-rouge"><span class="n">ident</span></code> tokens that begin with an <code class="language-dafny highlighter-rouge"><span class="n">_</span></code> are not permitted as user identifiers.</p>

<h4 id="sec-digits">2.6.3. Digits</h4>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">digits</span></code> token is a sequence of decimal digits (<code class="language-dafny highlighter-rouge"><span class="n">digit</span></code>), possibly interspersed with 
underscores for readability (but not beginning or ending with an underscore).
Example: <code class="language-dafny highlighter-rouge"><span class="mi">1_234_567</span></code>.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">hexdigits</span></code> token denotes a hexadecimal constant, and is a sequence of hexadecimal digits (<code class="language-dafny highlighter-rouge"><span class="n">hexdigit</span></code>)
prefaced by <code class="language-dafny highlighter-rouge"><span class="err">0x</span></code> and
possibly interspersed with underscores for readability (but not beginning or ending with an underscore).
Example: <code class="language-dafny highlighter-rouge"><span class="mh">0xffff_ffff</span></code>.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">realnumber</span></code> token is a real number literal, possibly interspersed with
underscores for readability (but not beginning or ending with an underscore).
Real numbers can be written as decimal fractions (like <code class="language-dafny highlighter-rouge"><span class="mf">123.456</span></code>) or using 
scientific notation (like <code class="language-dafny highlighter-rouge"><span class="mi">1</span><span class="o">.</span><span class="err">23e5</span></code> or <code class="language-dafny highlighter-rouge"><span class="err">123e5</span></code>). Real number literals can use
trailing-dot shorthand (like <code class="language-dafny highlighter-rouge"><span class="mi">1</span><span class="o">.</span></code> for <code class="language-dafny highlighter-rouge"><span class="mf">1.0</span></code>). They also support
leading-dot shorthand (like <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="mi">5</span></code> for <code class="language-dafny highlighter-rouge"><span class="mf">0.5</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="err">5e2</span></code> for <code class="language-dafny highlighter-rouge"><span class="mf">50.0</span></code>). All produce real number values.
Examples: <code class="language-dafny highlighter-rouge"><span class="mf">123_456.789_123</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">1</span><span class="o">.</span><span class="err">23e5</span></code>, <code class="language-dafny highlighter-rouge"><span class="err">123e</span><span class="o">-</span><span class="mi">2</span></code>, <code class="language-dafny highlighter-rouge"><span class="err">5e10</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">1</span><span class="o">.</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="mi">5</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="err">25e</span><span class="o">-</span><span class="mi">3</span></code>.</p>

<h4 id="sec-escaped-characters">2.6.4. Escaped Character</h4>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">escapedChar</span></code> token is a multi-character sequence that denotes a non-printable or non-ASCII character.
Such tokens begin with a backslash characcter (<code class="language-dafny highlighter-rouge"><span class="err">\</span></code>) and denote
 a single- or double-quote character, backslash,
null, new line, carriage return, tab, or a
Unicode character with given hexadecimal representation.
Which Unicode escape form is allowed depends on the value of the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span></code> option.</p>

<p>If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span><span class="o">:</span><span class="kc">false</span></code> is stipulated,
<code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">uXXXX</span></code> escapes can be used to specify any UTF-16 code unit.</p>

<p>If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span><span class="o">:</span><span class="kc">true</span></code> is stipulated,
<code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">U</span><span class="p">{</span><span class="n">X</span><span class="o">..</span><span class="n">X</span><span class="p">}</span></code> escapes can be used to specify any Unicode scalar value.
There must be at least one hex digit in between the braces, and at most six.
Surrogate code points are not allowed.
The hex digits may be interspersed with underscores for readability 
(but not beginning or ending with an underscore), as in <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">U</span><span class="p">{</span><span class="err">1_F680</span><span class="p">}</span></code>.
The braces are part of the required character sequence.</p>

<p>Note that although Unicode
letters are not allowed in Dafny identifiers, Dafny does support <a href="#sec-unicode">Unicode
in its character, string, and verbatim strings constants and in its comments</a>.</p>

<h4 id="sec-character-constant-token">2.6.5. Character Constant Token</h4>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">charToken</span></code> token denotes a character constant.
It is either a <code class="language-dafny highlighter-rouge"><span class="n">charChar</span></code> or an <code class="language-dafny highlighter-rouge"><span class="n">escapedChar</span></code> enclosed in single quotes.</p>

<h4 id="sec-string-constant-token">2.6.6. String Constant Token</h4>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">stringToken</span></code> denotes a string constant.
It consists of a sequence of <code class="language-dafny highlighter-rouge"><span class="n">stringChar</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">escapedChar</span></code> characters enclosed in 
double quotes.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">verbatimStringToken</span></code> token also denotes a string constant.
It is a sequence of any <code class="language-dafny highlighter-rouge"><span class="n">verbatimStringChar</span></code> characters (which includes newline characters),
enclosed between <code class="language-dafny highlighter-rouge"><span class="err">@"</span></code> and <code class="language-dafny highlighter-rouge"><span class="err">"</span></code>, except that two
successive double quotes represent one quote character inside
the string. This is the mechanism for escaping a double quote character,
which is the only character needing escaping in a verbatim string.
Within a verbatim string constant, a backslash character represents itself 
and is not the first character of an <code class="language-dafny highlighter-rouge"><span class="n">escapedChar</span></code>.</p>

<h4 id="sec-ellipsis">2.6.7. Ellipsis</h4>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">ellipsisToken</span></code> is the character sequence <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> and is typically used to designate something missing that will
later be inserted through refinement or is already present in a parent declaration.</p>

<h3 id="sec-grammar">2.7. Low Level Grammar Productions</h3>

<h4 id="sec-identifier-variations">2.7.1. Identifier Variations</h4>

<h5 id="2711-identifier">2.7.1.1. Identifier</h5>

<p>A basic ordinary identifier is just an <code class="language-dafny highlighter-rouge"><span class="n">ident</span></code> token.</p>

<p>It may be followed by a sequence of suffixes to denote compound entities.
Each suffix is a dot (<code class="language-dafny highlighter-rouge"><span class="o">.</span></code>) and another token, which may be</p>

<ul>
  <li>another <code class="language-dafny highlighter-rouge"><span class="n">ident</span></code> token</li>
  <li>a <code class="language-dafny highlighter-rouge"><span class="n">digits</span></code> token</li>
  <li>the <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> reserved word</li>
  <li>the <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> reserved word</li>
</ul>

<p>Note that</p>

<ul>
  <li>Digits can be used to name fields of classes and destructors of
datatypes. For example, the built-in tuple datatypes have destructors
named 0, 1, 2, etc. Note that as a field or destructor name, a digit sequence
is treated as a string, not a number: internal
underscores matter, so <code class="language-dafny highlighter-rouge"><span class="mi">10</span></code> is different from <code class="language-dafny highlighter-rouge"><span class="mi">1_0</span></code> and from <code class="language-dafny highlighter-rouge"><span class="mi">010</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="kr">requires</span></code> is used to denote the <a href="#sec-requires-clause">precondition</a> for method <code class="language-dafny highlighter-rouge"><span class="n">m</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="kr">reads</span></code> is used to denote the things that method <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> may <a href="#sec-reads-clause">read</a>.</li>
</ul>

<h5 id="2712-no-underscore-identifier">2.7.1.2. No-underscore-identifier</h5>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">NoUSIdent</span></code> is an identifier except that identifiers with a <strong>leading</strong>
underscore are not allowed. The names of user-defined entities are
required to be <code class="language-dafny highlighter-rouge"><span class="n">NoUSIdent</span></code>s or, in some contexts, a <code class="language-dafny highlighter-rouge"><span class="n">digits</span></code>.
 We introduce more mnemonic names
for these below (e.g. <code class="language-dafny highlighter-rouge"><span class="n">ClassName</span></code>).</p>

<p>A no-underscore-identifier is required for the following:</p>

<ul>
  <li>module name</li>
  <li>class or trait name</li>
  <li>datatype name</li>
  <li>newtype name</li>
  <li>synonym (and subset) type name</li>
  <li>iterator name</li>
  <li>type variable name</li>
  <li>attribute name</li>
</ul>

<p>A variation, a no-underscore-identifier or a <code class="language-dafny highlighter-rouge"><span class="n">digits</span></code>, is allowed for</p>

<ul>
  <li>datatype member name</li>
  <li>method or function or constructor name</li>
  <li>label name</li>
  <li>export id</li>
  <li>suffix that is a typename or constructor</li>
</ul>

<p>All <em>user-declared</em> names do not start with underscores, but there are
internally generated names that a user program might <em>use</em> that begin
with an underscore or are just an underscore.</p>

<h5 id="sec-wild-identifier">2.7.1.3. Wild identifier</h5>

<p>A wild identifier is a no-underscore-identifier except that the singleton
<code class="language-dafny highlighter-rouge"><span class="n">_</span></code> is allowed. The <code class="language-dafny highlighter-rouge"><span class="n">_</span></code> is replaced conceptually by a unique
identifier distinct from all other identifiers in the program.
A <code class="language-dafny highlighter-rouge"><span class="n">_</span></code> is used when an identifier is needed, but its content is discarded.
Such identifiers are not used in expressions.</p>

<p>Wild identifiers may be used in these contexts:</p>

<ul>
  <li>formal parameters of a lambda expression</li>
  <li>the local formal parameter of a quantifier</li>
  <li>the local formal parameter of a subset type or newtype declaration</li>
  <li>a variable declaration</li>
  <li>a case pattern formal parameter</li>
  <li>binding guard parameter</li>
  <li>for loop parameter</li>
  <li>LHS of update statements</li>
</ul>

<h4 id="272-qualified-names">2.7.2. Qualified Names</h4>

<p>A qualified name starts with the name of a top-level entity and then is followed by
zero or more <code class="language-dafny highlighter-rouge"><span class="n">DotSuffix</span></code>s which denote a component. Examples:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">Module</span><span class="o">.</span><span class="n">MyType1</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">MyTuple</span><span class="o">.</span><span class="mi">1</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">MyMethod</span><span class="o">.</span><span class="kr">requires</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">D</span></code></li>
</ul>

<p>The identifiers and dots are separate tokens and so may optionally be
separated by whitespace.</p>

<h4 id="273-identifier-type-combinations">2.7.3. Identifier-Type Combinations</h4>

<p>Identifiers are typically declared in combination with a type, as in
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span>
</code></pre></div></div>

<p>However, Dafny infers types in many circumstances, and in those, the type can be omitted. The type is required
for field declarations and formal parameters of methods, functions and constructors (because there is no initializer).
It may be omitted (if the type can be inferred) for local variable declarations, pattern matching variables, 
quantifiers,</p>

<p>Similarly, there are circumstances in which the identifier name is not needed, because it is not used.
This is allowed in defining algebraic datatypes.</p>

<p>In some other situations a wild identifier can be used, as described <a href="#sec-wild-identifier">above</a>.</p>

<h4 id="sec-quantifier-domains">2.7.4. Quantifier Domains (<a href="#g-quantifier-domain">grammar</a>)</h4>

<p>Several Dafny constructs bind one or more variables to a range of possible values.
For example, the quantifier <code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">25</span></code> has the meaning
for all integers x between 0 and 5 inclusive, the square of x is at most 25.
Similarly, the set comprehension <code class="language-dafny highlighter-rouge"><span class="kt">set</span> <span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="o">::</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> can be read as
the set containing the result of applying f to x, for each integer x from 0 to 5 inclusive.
The common syntax that specifies the bound variables and what values they take on
is known as the <em>quantifier domain</em>; in the previous examples this is <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span></code>, 
which binds the variable <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> to the values <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">2</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">3</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">4</span></code>, and <code class="language-dafny highlighter-rouge"><span class="mi">5</span></code>.</p>

<p>Here are some more examples.</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">:</span> <span class="n">byte</span></code> (where a value of type <code class="language-dafny highlighter-rouge"><span class="n">byte</span></code> is an int-based number <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> in the range <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">256</span></code>)</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">&lt;-</span> <span class="n">integerSet</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">&lt;-</span> <span class="n">integerSet</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">&lt;-</span> <span class="n">integerSet</span> <span class="o">|</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">2</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">y</span></code></li>
</ul>

<p>A quantifier domain declares one or more <em>quantified variables</em>, separated by commas.
Each variable declaration can be nothing more than a variable name, but it 
may also include any of three optional elements:</p>

<ol>
  <li>
    <p>The optional syntax <code class="language-dafny highlighter-rouge"><span class="o">:</span> <span class="n">T</span></code> declares the type of the quantified variable.
If not provided, it will be inferred from context.</p>
  </li>
  <li>
    <p>The optional syntax <code class="language-dafny highlighter-rouge"><span class="o">&lt;-</span> <span class="n">C</span></code> attaches a collection expression <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> as a <em>quantified variable domain</em>.
Here a collection is any value of a type that supports the <code class="language-dafny highlighter-rouge"><span class="ow">in</span></code> operator, namely sets, multisets, maps, and sequences.
The domain restricts the bindings to the elements of the collection: <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">&lt;-</span> <span class="n">C</span></code> implies <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">in</span> <span class="n">C</span></code>.
The example above can also be expressed as <code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">c</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span> <span class="kr">forall</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">c</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">25</span></code>.</p>
  </li>
  <li>
    <p>The optional syntax <code class="language-dafny highlighter-rouge"><span class="o">|</span> <span class="n">E</span></code> attaches a boolean expression <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> as a <em>quantified variable range</em>,
which restricts the bindings to values that satisfy this expression.
In the example above <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span></code> is the range attached to the <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> variable declaration.</p>
  </li>
</ol>

<p>Note that a variables domain expression may reference any variable declared before it,
and a variables range expression may reference the attached variable (and usually does) and any variable declared before it.
For example, in the quantifier domain <code class="language-dafny highlighter-rouge"><span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">y</span></code>, the expression <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></code> is always <a href="#sec-assertion-batches">well-formed</a>
because the range attached to <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> ensures <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> is a valid index in the sequence <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>.</p>

<p>Allowing per-variable ranges is not fully backwards compatible, and so it is not yet allowed by default;
the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">quantifier</span><span class="o">-</span><span class="n">syntax</span><span class="o">:</span><span class="mi">4</span></code> option needs to be provided to enable this feature (See <a href="#sec-controlling-language">Section 13.9.5</a>).</p>

<h4 id="sec-numeric-literals">2.7.5. Numeric Literals (<a href="#g-literal-expression">grammar</a>)</h4>

<p>Integer and bitvector literals may be expressed in either decimal or hexadecimal (<code class="language-dafny highlighter-rouge"><span class="n">digits</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">hexdigits</span></code>).</p>

<p>Real number literals are written as real number tokens (<code class="language-dafny highlighter-rouge"><span class="n">realnumber</span></code>).</p>

<!--PDF NEWPAGE-->
<h2 id="sec-program">3. Programs (<a href="#g-program">grammar</a>)</h2>

<p>At the top level, a Dafny program (stored as files with extension <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code>)
is a set of declarations. The declarations introduce (module-level)
constants, methods, functions, lemmas, types (classes, traits, inductive and
coinductive datatypes, newtypes, type synonyms, abstract types, and
iterators) and modules, where the order of introduction is irrelevant. 
Some types, notably classes, also may contain a set of declarations, introducing fields, methods,
and functions.</p>

<p>When asked to compile a program, Dafny looks for the existence of a
<code class="language-dafny highlighter-rouge"><span class="n">Main</span><span class="p">()</span></code> method. If a legal <code class="language-dafny highlighter-rouge"><span class="n">Main</span><span class="p">()</span></code> method is found, the compiler will emit
an executable appropriate to the target language; otherwise it will emit
a library or individual files.
The conditions for a legal <code class="language-dafny highlighter-rouge"><span class="n">Main</span><span class="p">()</span></code> method are described in the User Guide
(<a href="#sec-user-guide-main">Section 3.4</a>).
If there is more than one <code class="language-dafny highlighter-rouge"><span class="n">Main</span><span class="p">()</span></code>, Dafny will emit an error message.</p>

<p>An invocation of Dafny may specify a number of source files.
Each Dafny file follows the grammar of the <code class="language-dafny highlighter-rouge"><span class="n">Dafny</span></code> non-terminal.</p>

<p>A file consists of</p>
<ul>
  <li>a sequence of optional <em>include</em> directives, followed by</li>
  <li>top level declarations, followed by</li>
  <li>the end of the file.</li>
</ul>

<h3 id="sec-include-directive">3.1. Include Directives (<a href="#g-include-directive">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">include</span> <span class="s2">"MyProgram.dfy"</span>
<span class="kr">include</span> <span class="sx">@"/home/me/MyFile.dfy"</span>
</code></pre></div></div>

<p>Include directives have the form <code class="language-dafny highlighter-rouge"><span class="s2">"include"</span> <span class="n">stringToken</span></code> where
the string token is either a normal string token or a
verbatim string token. The <code class="language-dafny highlighter-rouge"><span class="n">stringToken</span></code> is interpreted as the name of
a file that will be included in the Dafny source. These included
files also obey the <code class="language-dafny highlighter-rouge"><span class="n">Dafny</span></code> grammar. Dafny parses and processes the
transitive closure of the original source files and all the included files,
but will not invoke the verifier on the included files unless they have been listed
explicitly on the command line or the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verify</span><span class="o">-</span><span class="n">included</span><span class="o">-</span><span class="n">files</span></code> option is
specified.</p>

<p>The file name may be a path using the customary <code class="language-dafny highlighter-rouge"><span class="o">/</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">.</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">..</span></code> punctuation.
The interpretation of the name (e.g., case-sensitivity) will depend on the
underlying operating system. A path not beginning with <code class="language-dafny highlighter-rouge"><span class="o">/</span></code> is looked up in
the underlying file system relative to the 
<em>location of the file in which the include directive is stated</em>. 
Paths beginning with a device
designator (e.g., <code class="language-dafny highlighter-rouge"><span class="n">C</span><span class="o">:</span></code>) are only permitted on Windows systems.
Better style advocates using relative paths in include directives so that
groups of files may be moved as a whole to a new location.</p>

<p>Paths of files on the command-line or named in <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">library</span></code> options are 
relative the the current working directory.</p>

<h3 id="sec-top-level-declaration">3.2. Top Level Declarations (<a href="#g-top-level-declaration">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">M</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">trait</span> <span class="n">R</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">class</span> <span class="n">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">datatype</span> <span class="n">D</span> <span class="o">=</span> <span class="n">A</span> <span class="o">|</span> <span class="n">B</span>
<span class="kr">newtype</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="kr">type</span> <span class="n">T</span> <span class="o">=</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span>
<span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{}</span>
<span class="kr">function</span> <span class="n">f</span><span class="p">()</span><span class="o">:</span> <span class="kt">int</span>
<span class="kr">const</span> <span class="n">c</span><span class="o">:</span> <span class="kt">bool</span>
</code></pre></div></div>

<p>Top-level declarations may appear either at the top level of a Dafny file,
or within a (sub)module declaration. A top-level declaration is one of
various kinds of declarations described later. Top-level declarations are
implicitly members of a default (unnamed) top-level module.</p>

<p>Declarations within a module or at the top-level all begin with reserved keywords and do not end with semicolons.</p>

<p>These declarations are one of these kinds:</p>
<ul>
  <li>methods and functions, encapsulating computations or actions</li>
  <li>const declarations, which are names (of a given type) initialized to an unchanging value;
declarations of variables and mutable fields are not allowed at the module level</li>
  <li>type declarations of various kinds (<a href="#sec-types">Section 5</a> and the following sections)</li>
</ul>

<p>Methods, functions and const declarations are placed in an implicit class declaration
that is in the top-level implicit module. These declarations are all implicitly
<code class="language-dafny highlighter-rouge"><span class="kr">static</span></code> (and may not be declared explicitly static).</p>

<h3 id="sec-declaration-modifier">3.3. Declaration Modifiers (<a href="#g-declaration-modifier">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kr">static</span> <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">ghost</span> <span class="n">opaque</span> <span class="kr">const</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">int</span>
</code></pre></div></div>

<p>Top level declarations may be preceded by zero or more declaration
modifiers. Not all of these are allowed in all contexts.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">abstract</span></code> modifier may only be used for module declarations.
An abstract module can leave some entities underspecified.
Abstract modules are not compiled.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> modifier is used to mark entities as being used for
specification only, not for compilation to code.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code> modifier may be used on const declarations and functions.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code> modifier is used for class members that
are associated with the class as a whole rather than with
an instance of the class. This modifier may not be used with
declarations that are implicitly static, as are members of the 
top-level, unnamed implicit class.</p>

<p>The following table shows modifiers that are available
for each of the kinds of declaration. In the table
we use already-ghost (already-non-ghost) to denote that the item is not
allowed to have the ghost modifier because it is already
implicitly ghost (non-ghost).</p>

<table>
  <thead>
    <tr>
      <th>Declaration</th>
      <th>allowed modifiers</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>module</td>
      <td>abstract</td>
    </tr>
    <tr>
      <td>class</td>
      <td>-</td>
    </tr>
    <tr>
      <td>trait</td>
      <td>-</td>
    </tr>
    <tr>
      <td>datatype or codatatype</td>
      <td>-</td>
    </tr>
    <tr>
      <td>field (const)</td>
      <td>ghost opaque</td>
    </tr>
    <tr>
      <td>newtype</td>
      <td>-</td>
    </tr>
    <tr>
      <td>synonym types</td>
      <td>-</td>
    </tr>
    <tr>
      <td>iterators</td>
      <td>-</td>
    </tr>
    <tr>
      <td>method</td>
      <td>ghost static</td>
    </tr>
    <tr>
      <td>lemma</td>
      <td>already-ghost static</td>
    </tr>
    <tr>
      <td>least lemma</td>
      <td>already-ghost static</td>
    </tr>
    <tr>
      <td>greatest lemma</td>
      <td>already-ghost static</td>
    </tr>
    <tr>
      <td>constructor</td>
      <td>ghost</td>
    </tr>
    <tr>
      <td>function</td>
      <td>ghost static opaque             (Dafny 4)</td>
    </tr>
    <tr>
      <td>function method</td>
      <td>already-non-ghost static opaque (Dafny 3)</td>
    </tr>
    <tr>
      <td>function (non-method)</td>
      <td>already-ghost static opaque     (Dafny 3)</td>
    </tr>
    <tr>
      <td>predicate</td>
      <td>ghost static opaque             (Dafny 4)</td>
    </tr>
    <tr>
      <td>predicate method</td>
      <td>already-non-ghost static opaque (Dafny 3)</td>
    </tr>
    <tr>
      <td>predicate (non-method)</td>
      <td>already-ghost static opaque     (Dafny 3)</td>
    </tr>
    <tr>
      <td>least predicate</td>
      <td>already-ghost static opaque</td>
    </tr>
    <tr>
      <td>greatest predicate</td>
      <td>already-ghost static opaque</td>
    </tr>
  </tbody>
</table>

<h3 id="sec-user-guide-main">3.4. Executable programs</h3>

<p>Dafny programs have an important emphasis on verification, but the programs 
may also be executable.</p>

<p>To be executable, the program must have exactly one <code class="language-dafny highlighter-rouge"><span class="n">Main</span></code> method and that 
method must be a legal main entry point.</p>

<ul>
  <li>The program is searched for a method with the attribute <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">main</span><span class="p">}</span></code>.
If exactly one is found, that method is used as the entry point; if more
than one method has the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">main</span><span class="p">}</span></code> attribute, an error message is issued.</li>
  <li>Otherwise, the program is searched for a method with the name <code class="language-dafny highlighter-rouge"><span class="n">Main</span></code>.
If more than one is found an error message is issued.</li>
</ul>

<p>Any abstract modules are not searched for candidate entry points,
but otherwise the entry point may be in any module or type. In addition,
an entry-point candidate must satisfy the following conditions:</p>

<ul>
  <li>The method has no type parameters and either has no parameters or one non-ghost parameter of type <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span></code>.</li>
  <li>The method has no non-ghost out-parameters.</li>
  <li>The method is not a ghost method.</li>
  <li>The method has no requires or modifies clauses, unless it is marked <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">main</span><span class="p">}</span></code>.</li>
  <li>If the method is an instance (that is, non-static) method and the
enclosing type is a class,
then that class must not declare any constructor.
In this case, the runtime system will
allocate an object of the enclosing class and will invoke
the entry-point method on it.</li>
  <li>If the method is an instance (that is, non-static) method and the
enclosing type is not a class,
then the enclosing type must, when instantiated with auto-initializing
type parameters, be an auto-initializing type.
In this case, the runtime system will
invoke the entry-point method on a value of the enclosing type.</li>
</ul>

<p>Note, however, that the following are allowed:</p>

<ul>
  <li>The method is allowed to have <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses</li>
  <li>The method is allowed to have <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clauses, including a
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="o">*</span></code>. (If <code class="language-dafny highlighter-rouge"><span class="n">Main</span><span class="p">()</span></code> has a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="o">*</span></code>, then its execution may
go on forever, but in the absence of a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="o">*</span></code> on <code class="language-dafny highlighter-rouge"><span class="n">Main</span><span class="p">()</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code>
will have verified that the entire execution will eventually
terminate.)</li>
</ul>

<p>If no legal candidate entry point is identified, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> will still produce executable output files, but
they will need to be linked with some other code in the target language that
provides a <code class="language-dafny highlighter-rouge"><span class="n">main</span></code> entry point.</p>

<p>If the <code class="language-dafny highlighter-rouge"><span class="n">Main</span></code> method takes an argument (of type <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span></code>), the value of that input argument is the sequence
of command-line arguments, with the first entry of the sequence (at index 0) being a system-determined name for the 
executable being run.</p>

<p>The exit code of the program, when executed, is not yet specified.</p>

<!--PDF NEWPAGE-->
<h2 id="sec-modules">4. Modules (<a href="#g-module">grammar</a>)</h2>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">N</span>  <span class="p">{</span> <span class="p">}</span>
<span class="kr">import</span> <span class="n">A</span>
<span class="kr">export</span> <span class="n">A</span> <span class="kr">reveals</span> <span class="n">f</span>
</code></pre></div></div>

<p>Structuring a program by breaking it into parts is an important part of
creating large programs. In Dafny, this is accomplished via <em>modules</em>.
Modules provide a way to group together related types, classes, methods,
functions, and other modules, as well as to control the scope of
declarations. Modules may import each other for code reuse, and it is
possible to abstract over modules to separate an implementation from an
interface.</p>

<p>Module declarations are of three types:</p>
<ul>
  <li>a module definition</li>
  <li>a module import</li>
  <li>a module export definition</li>
</ul>

<p>Module definitions and imports each declare a submodule
of its enclosing module, which may be the
implicit, undeclared, top-level module.</p>

<h3 id="sec-module-definition">4.1. Declaring New Modules (<a href="#g-module-definition">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">P</span> <span class="p">{</span> <span class="kr">const</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="p">}</span>
<span class="kr">abstract</span> <span class="kr">module</span> <span class="n">A</span><span class="o">.</span><span class="n">Q</span> <span class="p">{</span> <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span>
<span class="kr">module</span> <span class="n">M</span> <span class="p">{</span> <span class="kr">module</span> <span class="n">N</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div></div>

<p>A <em>module definition</em></p>
<ul>
  <li>has an optional modifier (only <code class="language-dafny highlighter-rouge"><span class="kr">abstract</span></code> is allowed)</li>
  <li>followed by the keyword module</li>
  <li>followed by a name (a sequence of dot-separated identifiers)</li>
  <li>followed by a body enclosed in curly braces</li>
</ul>

<p>A module body consists of any declarations that are allowed at the top
level: classes, datatypes, types, methods, functions, etc.</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span>
    <span class="kr">method</span> <span class="n">m</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="kr">datatype</span> <span class="n">Option</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">|</span> <span class="n">B</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
  <span class="kr">type</span> <span class="n">T</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span>
  <span class="kr">function</span> <span class="n">f</span><span class="p">()</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can also put a module inside another, in a nested fashion:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">module</span> <span class="n">Helpers</span> <span class="p">{</span>
    <span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
      <span class="kr">method</span> <span class="n">doIt</span><span class="p">()</span>
      <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then you can refer to the members of the <code class="language-dafny highlighter-rouge"><span class="n">Helpers</span></code> module within the
<code class="language-dafny highlighter-rouge"><span class="n">Mod</span></code> module by prefixing them with Helpers.. For example:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">module</span> <span class="n">Helpers</span> <span class="p">{</span>
    <span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
      <span class="kr">constructor</span> <span class="p">()</span> <span class="p">{</span> <span class="n">f</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
      <span class="kr">method</span> <span class="n">doIt</span><span class="p">()</span>
      <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Helpers</span><span class="o">.</span><span class="n">C</span><span class="p">();</span>
    <span class="n">x</span><span class="o">.</span><span class="n">doIt</span><span class="p">();</span>
    <span class="n">x</span><span class="o">.</span><span class="n">f</span> <span class="o">:=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Methods and functions defined at the module level are available like
classes, with just the module name prefixing them. They are also
available in the methods and functions of the classes in the same
module.</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">module</span> <span class="n">Helpers</span> <span class="p">{</span>
    <span class="kr">function</span> <span class="n">addOne</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span> <span class="p">{</span>
      <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="n">Helpers</span><span class="o">.</span><span class="n">addOne</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// x is now 6</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that everything declared at the top-level
(in all the files constituting the program) is implicitly part
of a single implicit unnamed global module.</p>

<h3 id="42-declaring-nested-modules-standalone">4.2. Declaring nested modules standalone</h3>

<p>As described in the previous section, module declarations can be nested.
It is also permitted to declare a nested module <em>outside</em> of its
containing module. So instead of
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">module</span> <span class="n">B</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>one can write
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">A</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">A</span><span class="o">.</span><span class="n">B</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The second module is completely separate; for example, it can be in
a different file.
This feature provides flexibility in writing and maintenance;
for example, it can reduce the size of module <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> by extracting module <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">B</span></code>
into a separate body of text.</p>

<p>However, it can also lead to confusion, and program authors need to take care.
It may not be apparent to a reader of module <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> that module <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">B</span></code> exists;
the existence of <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">B</span></code> might cause names to be resolved differently and
the semantics of the program might be (silently) different if <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">B</span></code> is
present or absent.</p>

<h3 id="sec-importing-modules">4.3. Importing Modules (<a href="#g-module-import">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">import</span> <span class="n">A</span>
<span class="kr">import</span> <span class="kr">opened</span> <span class="n">B</span>
<span class="kr">import</span> <span class="n">A</span> <span class="o">=</span> <span class="n">B</span>
<span class="kr">import</span> <span class="n">A</span> <span class="o">:</span> <span class="n">B</span>
<span class="kr">import</span> <span class="n">A</span><span class="o">.</span><span class="n">B</span>
<span class="kr">import</span> <span class="n">A</span><span class="p">`</span><span class="n">E</span>
<span class="kr">import</span> <span class="n">X</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">B</span><span class="p">`{</span><span class="n">E</span><span class="p">,</span><span class="n">F</span><span class="p">}</span>
</code></pre></div></div>

<p>Sometimes you want to refer to
things from an existing module, such as a library. In this case, you
can <em>import</em> one module into another. This is done via the <code class="language-dafny highlighter-rouge"><span class="kr">import</span></code>
keyword, which has two forms with different meanings.
The simplest form is the concrete import, which has
the form <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">A</span> <span class="o">=</span> <span class="n">B</span></code>. This declaration creates a reference to the
module <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> (which must already exist), and binds it to the new local name
<code class="language-dafny highlighter-rouge"><span class="n">A</span></code>. This form can also be used to create a reference to a nested
module, as in <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">A</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">C</span></code>. The other form, using a <code class="language-dafny highlighter-rouge"><span class="o">:</span></code>, is
described in <a href="#sec-module-abstraction">Section 4.6</a>.</p>

<p>As modules in the same scope must have different names, this ability
to bind a module to a new name allows disambiguating separately developed
external modules that have the same name.
Note that the new name is only bound in the scope containing
the import declaration; it does not create a global alias. For
example, if <code class="language-dafny highlighter-rouge"><span class="n">Helpers</span></code> was defined outside of <code class="language-dafny highlighter-rouge"><span class="n">Mod</span></code>, then we could import
it:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Helpers</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">addOne</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Helpers</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">addOne</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that inside <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="p">()</span></code>, we have to use <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> instead of <code class="language-dafny highlighter-rouge"><span class="n">Helpers</span></code>, as we bound
it to a different name. The name <code class="language-dafny highlighter-rouge"><span class="n">Helpers</span></code> is not available inside <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="p">()</span></code> (or anywhere else inside <code class="language-dafny highlighter-rouge"><span class="n">Mod</span></code>),
as only names that have been bound inside <code class="language-dafny highlighter-rouge"><span class="n">Mod</span></code> are available. In order
to use the members from another module, that other module either has to be declared
there with <code class="language-dafny highlighter-rouge"><span class="kr">module</span></code> or imported with <code class="language-dafny highlighter-rouge"><span class="kr">import</span></code>. (As described below, the
resolution of the <code class="language-dafny highlighter-rouge"><span class="n">ModuleQualifiedName</span></code> that follows the <code class="language-dafny highlighter-rouge"><span class="o">=</span></code> in the <code class="language-dafny highlighter-rouge"><span class="kr">import</span></code>
statement or the <code class="language-dafny highlighter-rouge"><span class="kr">refines</span></code> in a module declaration uses slightly
different rules.)</p>

<p>We dont have to give <code class="language-dafny highlighter-rouge"><span class="n">Helpers</span></code> a new name, though, if we dont want
to. We can write <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Helpers</span> <span class="o">=</span> <span class="n">Helpers</span></code> to import the module under
its own name; Dafny
even provides the shorthand <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Helpers</span></code> for this behavior. You
cant bind two modules with the same name at the same time, so
sometimes you have to use the = version to ensure the names do not
clash. When importing nested modules, <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">B</span><span class="o">.</span><span class="n">C</span></code> means <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">C</span></code>;
the implicit name is always the last name segment of the module designation.</p>

<p>The first identifier in the dot-separated sequence of identifers that constitute
the qualified name of the module being imported is resolved as (in order)</p>
<ul>
  <li>a submodule of the importing module,</li>
  <li>or a sibling module of the importing module,</li>
  <li>or a sibling module of some containing module, traversing outward. 
There is no way to refer to a containing module, only
sibling modules (and their submodules).</li>
</ul>

<p>Import statements may occur at the top-level of a program
(that is, in the implicit top-level module of the program) as well.
There they serve as a way to give a new name, perhaps a
shorthand name, to a module. For example,</p>

<!-- %check-resolve Modules.1.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">MyModule</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// declare MyModule</span>
<span class="kr">import</span> <span class="n">MyModule</span>  <span class="c1">// error: cannot add a module named MyModule</span>
                 <span class="c1">// because there already is one</span>
<span class="kr">import</span> <span class="n">M</span> <span class="o">=</span> <span class="n">MyModule</span> <span class="c1">// OK. M and MyModule are equivalent</span>
</code></pre></div></div>

<h3 id="sec-opening-modules">4.4. Opening Modules</h3>

<p>Sometimes, prefixing the members of the module you imported with its
name is tedious and ugly, even if you select a short name when
importing it. In this case, you can import the module as <code class="language-dafny highlighter-rouge"><span class="kr">opened</span></code>,
which causes all of its members to be available without adding the
module name. The <code class="language-dafny highlighter-rouge"><span class="kr">opened</span></code> keyword, if present, must immediately follow <code class="language-dafny highlighter-rouge"><span class="kr">import</span></code>.
For example, we could write the previous example as:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Helpers</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">addOne</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="kr">opened</span> <span class="n">Helpers</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">addOne</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When opening modules, the newly bound members have lower priority
than local definitions. This means if you define
a local function called <code class="language-dafny highlighter-rouge"><span class="n">addOne</span></code>, the function from <code class="language-dafny highlighter-rouge"><span class="n">Helpers</span></code> will no
longer be available under that name. When modules are opened, the
original name binding is still present however, so you can always use
the name that was bound to get to anything that is hidden.</p>

<!-- %check-verify Modules.2.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Helpers</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">addOne</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="kr">opened</span> <span class="n">H</span> <span class="o">=</span> <span class="n">Helpers</span>
  <span class="kr">function</span> <span class="n">addOne</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">addOne</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// this is now false,</span>
                           <span class="c1">// as this is the function just defined</span>
    <span class="kr">assert</span> <span class="n">H</span><span class="o">.</span><span class="n">addOne</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// this is still true</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If you open two modules that both declare members with the same name,
then neither member can be referred to without a module prefix, as it
would be ambiguous which one was meant. Just opening the two modules
is not an error, however, as long as you dont attempt to use members
with common names. However, if the ambiguous references actually
refer to the same declaration, then they are permitted.
The <code class="language-dafny highlighter-rouge"><span class="kr">opened</span></code> keyword may be used with any kind of
<code class="language-dafny highlighter-rouge"><span class="kr">import</span></code> declaration, including the module abstraction form.</p>

<p>An <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="kr">opened</span></code> may occur at the top-level as well. For example,
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">MyModule</span> <span class="p">{</span>  <span class="p">}</span> <span class="c1">// declares MyModule</span>
<span class="kr">import</span> <span class="kr">opened</span> <span class="n">MyModule</span> <span class="c1">// does not declare a new module, but does</span>
                       <span class="c1">// make all names in MyModule available in</span>
                       <span class="c1">// the current scope, without needing</span>
                       <span class="c1">// qualification</span>
<span class="kr">import</span> <span class="kr">opened</span> <span class="n">M</span> <span class="o">=</span> <span class="n">MyModule</span> <span class="c1">// names in MyModule are available in</span>
                       <span class="c1">// the current scope without qualification</span>
                       <span class="c1">// or qualified with either M (because of this</span>
                       <span class="c1">// import) or MyModule (because of the original</span>
                       <span class="c1">// module definition)</span>
</code></pre></div></div>

<p>The Dafny style guidelines suggest using opened imports sparingly.
They are best used when the names being imported have obvious
and unambiguous meanings and when using qualified names would be
verbose enough to impede understanding.</p>

<p>There is a special case in which the behavior described above is altered.
If a module <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> declares a type <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> is <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="kr">opened</span></code> without renaming inside 
another module <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>, then the rules above would have, within <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>,
<code class="language-dafny highlighter-rouge"><span class="n">M</span></code> mean the module and <code class="language-dafny highlighter-rouge"><span class="n">M</span><span class="o">.</span><span class="n">M</span></code> mean the type. This is verbose. So in this 
somewhat common case, the type <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> is effectively made a local declaration within <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>
so that it has precedence over the module name. Now <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> refers to the type.
If one needs to refer to the module, it will have to be renamed as part of
the <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="kr">opened</span></code> statement.</p>

<p>This special-case behavior does give rise to a source of ambiguity. Consider
the example
<!-- %check-resolve Modules.3.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Option</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">1</span>
  <span class="kr">datatype</span> <span class="n">Option</span> <span class="o">=</span> <span class="n">A</span><span class="o">|</span><span class="n">B</span> <span class="p">{</span> <span class="kr">static</span> <span class="kr">const</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">X</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="kr">opened</span> <span class="n">Option</span>
  <span class="kr">method</span> <span class="n">M</span><span class="p">()</span> <span class="p">{</span> <span class="kr">print</span> <span class="n">Option</span><span class="o">.</span><span class="n">a</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-dafny highlighter-rouge"><span class="n">Option</span><span class="o">.</span><span class="n">a</span></code> now means the <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> in the datatype instead of the <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> in the module.
To avoid confusion in such cases, it is an ambiguity error if a name
that is declared in both the datatype and the module is used
when there is an <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">open</span></code> of
the module (without renaming).</p>

<h3 id="sec-export-sets">4.5. Export Sets and Access Control (<a href="#g-module-export">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">export</span> <span class="n">E</span> <span class="kr">extends</span> <span class="n">F</span> <span class="kr">reveals</span> <span class="n">f</span><span class="p">,</span><span class="n">g</span> <span class="kr">provides</span> <span class="n">g</span><span class="p">,</span><span class="n">h</span>
<span class="kr">export</span> <span class="n">E</span> <span class="kr">reveals</span> <span class="o">*</span>
<span class="kr">export</span> <span class="kr">reveals</span> <span class="n">f</span><span class="p">,</span><span class="n">g</span> <span class="kr">provides</span> <span class="n">g</span><span class="p">,</span><span class="n">h</span>
<span class="kr">export</span> <span class="n">E</span>
<span class="kr">export</span> <span class="n">E</span> <span class="o">...</span> <span class="kr">reveals</span> <span class="n">f</span>
</code></pre></div></div>

<p>In some programming languages, keywords such as <code class="language-dafny highlighter-rouge"><span class="n">public</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">private</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">protected</span></code>
are used to control access to (that is, visibility of) declared program entities.
In Dafny, modules and export sets provide that capability.
Modules combine declarations into logically related groups.
Export sets then permit selectively exposing subsets of a modules declarations;
another module can import the export set appropriate to its needs.
A user can define as many export sets as are needed to provide different
kinds of access to the modules declarations.
Each export set designates a list of names, which must be
names that are declared in the module (or in a refinement parent).</p>

<p>By default (in the absence of any export set declarations)
all the names declared in a module are available outside the
module using the <code class="language-dafny highlighter-rouge"><span class="kr">import</span></code> mechanism.
An <em>export set</em> enables a module to disallow the
use of some declarations outside the module.</p>

<p>An export set has an optional name used to disambiguate
in case of multiple export sets;
If specified, such names are used in <code class="language-dafny highlighter-rouge"><span class="kr">import</span></code> statements
to designate which export set of a module is being imported.
If a module <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> has export sets <code class="language-dafny highlighter-rouge"><span class="n">E1</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">E2</span></code>,
we can write <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">A</span> <span class="o">=</span> <span class="n">M</span><span class="p">`</span><span class="n">E1</span></code> to create a module alias
<code class="language-dafny highlighter-rouge"><span class="n">A</span></code> that contains only the names in <code class="language-dafny highlighter-rouge"><span class="n">E1</span></code>.
Or we can write <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">A</span> <span class="o">=</span> <span class="n">M</span><span class="p">`{</span><span class="n">E1</span><span class="p">,</span><span class="n">E2</span><span class="p">}</span></code> to import the union
of names in <code class="language-dafny highlighter-rouge"><span class="n">E1</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">E2</span></code> as module alias <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>.
As before, <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">M</span><span class="p">`</span><span class="n">E1</span></code> is an abbreviation of <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">`</span><span class="n">E1</span></code>.</p>

<p>If no export set is given in an import
statement, the default export set of the module is used.</p>

<p>There are various
defaults that apply differently in different cases.
The following description is with respect to an example module <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>:</p>

<p><em><code class="language-dafny highlighter-rouge"><span class="n">M</span></code> has no export sets declared</em>. Then another module may simply <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">M</span></code>
to obtain access to all of Ms declarations.</p>

<p><em><code class="language-dafny highlighter-rouge"><span class="n">M</span></code> has one or more named export sets (e.g., <code class="language-dafny highlighter-rouge"><span class="n">E</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">F</span></code>)</em>. Then another module can
write <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">M</span><span class="p">`</span><span class="n">E</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">M</span><span class="p">`{</span><span class="n">E</span><span class="p">,</span><span class="n">F</span><span class="p">}</span></code> to obtain access to the
names that are listed in export set <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> or to the union of those in export sets
<code class="language-dafny highlighter-rouge"><span class="n">E</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">F</span></code>, respectively. If no export set has the same name as the module,
then an export set designator must be used: in that case you cannot write
simply <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">M</span></code>.</p>

<p><em><code class="language-dafny highlighter-rouge"><span class="n">M</span></code> has an unnamed export set, along with other export sets (e.g., named <code class="language-dafny highlighter-rouge"><span class="n">E</span></code>)</em>. The unnamed
export set is the default export set and implicitly has the same name as
the module. Because there is a default export set, another module may write
either <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">M</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">M</span><span class="p">`</span><span class="n">M</span></code> to import the names in that
default export set. You can also still use the other export sets with the
explicit designator: <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">M</span><span class="p">`</span><span class="n">E</span></code></p>

<p><em><code class="language-dafny highlighter-rouge"><span class="n">M</span></code> declares an export set with the same name as the module</em>. This is equivalent
to declaring an export set without a name. <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">M</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">M</span><span class="p">`</span><span class="n">M</span></code>
perform the same function in either case; the export set with or without
the name of the module is the default export set for the module.</p>

<p>Note that names of module aliases (declared by import statements) are
just like other names in a module; they can be included or omitted from
export sets.
Names brought into a module by <a href="#sec-module-refinement"><em>refinement</em></a> are treated the same as
locally declared names and can be listed in export set declarations.
However, names brought into a module by <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="kr">opened</span></code> (either into a module
or a refinement parent of a module) may
not be further exported. For example,
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">10</span>
  <span class="kr">const</span> <span class="n">z</span> <span class="o">:=</span> <span class="mi">10</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">B</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="kr">opened</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">A</span> <span class="c1">// includes a, declares Z</span>
  <span class="kr">const</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">Z</span><span class="o">.</span><span class="n">a</span> <span class="c1">// OK</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="kr">opened</span> <span class="n">B</span> <span class="c1">// includes b, Z, but not a</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//assert b == a; // error: a is not known</span>
    <span class="c1">//assert b == B.a; // error: B.a is not valid</span>
    <span class="c1">//assert b == A.a; // error: A is not known</span>
    <span class="kr">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="n">Z</span><span class="o">.</span><span class="n">a</span><span class="p">;</span> <span class="c1">// OK: module Z is known and includes a</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However, in the above example,</p>

<ul>
  <li>if <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> has one export set <code class="language-dafny highlighter-rouge"><span class="kr">export</span> <span class="n">Y</span> <span class="kr">reveals</span> <span class="n">a</span></code>
then the import in module <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> is invalid because <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> has no default
export set;</li>
  <li>if <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> has one export set <code class="language-dafny highlighter-rouge"><span class="kr">export</span> <span class="n">Y</span> <span class="kr">reveals</span> <span class="n">a</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> has <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">A</span><span class="p">`</span><span class="n">Y</span></code>
then <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>s import is OK. So is the use of <code class="language-dafny highlighter-rouge"><span class="n">Z</span><span class="o">.</span><span class="n">a</span></code> in the assert because <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>
declares <code class="language-dafny highlighter-rouge"><span class="n">Z</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> brings in <code class="language-dafny highlighter-rouge"><span class="n">Z</span></code> through the <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="kr">opened</span></code> and
<code class="language-dafny highlighter-rouge"><span class="n">Z</span></code> contains <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> by virtue of its declaration. (The alias <code class="language-dafny highlighter-rouge"><span class="n">Z</span></code> is not able to
have export sets; all of its names are visible.)</li>
  <li>if <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> has one export set <code class="language-dafny highlighter-rouge"><span class="kr">export</span> <span class="kr">provides</span> <span class="n">z</span></code> then <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> does have a
default export set, so the import in <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> is OK, but neither the use of <code class="language-dafny highlighter-rouge"><span class="n">a</span></code>
in <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> nor as <code class="language-dafny highlighter-rouge"><span class="n">Z</span><span class="o">.</span><span class="n">a</span></code> in C would be valid, because <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is not in <code class="language-dafny highlighter-rouge"><span class="n">Z</span></code>.</li>
</ul>

<p>The default export set is important in the resolution of qualified
names, as described in <a href="#sec-name-resolution">Section 4.8</a>.</p>

<p>There are a few unusual cases to be noted:</p>
<ul>
  <li>an export set can be completely empty, as in <code class="language-dafny highlighter-rouge"><span class="kr">export</span> <span class="n">Nothing</span></code></li>
  <li>an eponymous export set can be completely empty, as in <code class="language-dafny highlighter-rouge"><span class="kr">export</span></code>, which by default has the same name as the enclosing module; this is a way to make the module completely private</li>
  <li>an export set declaration followed by an extreme predicate declaration looks like this:
<code class="language-dafny highlighter-rouge"><span class="kr">export</span> <span class="kr">least</span> <span class="kr">predicate</span> <span class="n">P</span><span class="p">()</span> <span class="p">{</span> <span class="kc">true</span> <span class="p">}</span></code>
In this case, the <code class="language-dafny highlighter-rouge"><span class="kr">least</span></code> (or <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span></code>) is the identifier naming the export set.
Consequently, <code class="language-dafny highlighter-rouge"><span class="kr">export</span> <span class="kr">least</span> <span class="kr">predicate</span> <span class="n">P</span><span class="p">[</span><span class="kt">nat</span><span class="p">]()</span> <span class="p">{</span> <span class="kc">true</span> <span class="p">}</span></code> is illegal because <code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="kt">nat</span><span class="p">]</span></code> cannot be part of a non-extreme predicate.
So, it is not possible to declare an eponymous, empty export set by omitting the export id immediately prior to a declaration of an extreme predicate,
because the <code class="language-dafny highlighter-rouge"><span class="kr">least</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span></code> token is parsed as the export set identifier. The workaround for this situation is to 
either put the name of the module in explicitly as the export ID (not leaving it to the default) or reorder the declarations.</li>
  <li>To avoid confusion, the code
<!-- %check-verify-warn Modules.10.expect -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
<span class="kr">export</span>
<span class="kr">least</span> <span class="kr">predicate</span> <span class="n">P</span><span class="p">()</span> <span class="p">{</span> <span class="kc">true</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>provokes a warning telling the user that the <code class="language-dafny highlighter-rouge"><span class="kr">least</span></code> goes with the <code class="language-dafny highlighter-rouge"><span class="kr">export</span></code>.</p>
  </li>
</ul>

<h4 id="sec-provided-and-revealed-names">4.5.1. Provided and revealed names</h4>

<p>Names can be exported from modules in two ways, designated by <code class="language-dafny highlighter-rouge"><span class="kr">provides</span></code>
and <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code> in the export set declaration.</p>

<p>When a name is exported as <em>provided</em>, then inside a module that has
imported the name only the name is known, not the details of the
names declaration.</p>

<p>For example, in the following code the constant <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is exported as provided.
<!-- %check-verify Modules.4.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">export</span> <span class="kr">provides</span> <span class="n">a</span>
  <span class="kr">const</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">10</span>
  <span class="kr">const</span> <span class="n">b</span> <span class="o">:=</span> <span class="mi">20</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">B</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="n">A</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// a is known, but not its value</span>
    <span class="c1">// assert A.b == 20; // b is not known through A`A</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Since <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is imported into module <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> through the default export set <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="p">`</span><span class="n">A</span></code>,
it can be referenced in the assert statement. The constant <code class="language-dafny highlighter-rouge"><span class="n">b</span></code> is not
exported, so it is not available. But the assert about <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is not provable
because the value of <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is not known in module <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>.</p>

<p>In contrast, if <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is exported as <em>revealed</em>, as shown in the next example,
its value is known and the assertion can be proved.
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">export</span> <span class="kr">reveals</span> <span class="n">a</span>
  <span class="kr">const</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">10</span>
  <span class="kr">const</span> <span class="n">b</span> <span class="o">:=</span> <span class="mi">20</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">B</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="n">A</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// a and its value are known</span>
    <span class="c1">// assert A.b == 20; // b is not known through A`A</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The following table shows which parts of a declaration are exported by an
export set that <code class="language-dafny highlighter-rouge"><span class="kr">provides</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code> the declaration.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code> declaration         | what is exported    | what is exported
                     | with provides       | with reveals
---------------------|---------------------|---------------------
 const x: X := E     | const x: X          | const x: X := E
---------------------|---------------------|---------------------
 var x: X            | var x: X            | not allowed
---------------------|---------------------|---------------------
 function F(x: X): Y | function F(x: X): Y | function F(x: X): Y
   specification...  |   specification...  |   specification...
 {                   |                     | {
   Body              |                     |   Body
 }                   |                     | }
---------------------|---------------------|---------------------
 method M(x: X)      | method M(x: X)      | not allowed
   returns (y: Y)    |   returns (y: Y)    |
   specification...  |   specification...  |
 {                   |                     |
   Body;             |                     |
 }                   |                     |
---------------------|---------------------|---------------------
 type Opaque         | type Opaque         | type Opaque
 {                   |                     |
   // members...     |                     |
 }                   |                     |
---------------------|---------------------|---------------------
 type Synonym = T    | type Synonym        | type Synonym = T
---------------------|---------------------|---------------------
 type S = x: X       | type S              | type S = x: X
   | P witness E     |                     |   | P witness E
---------------------|---------------------|---------------------
 newtype N = x: X    | type N              | newtype N = x: X
   | P witness E     |                     |   | P witness E
 {                   |                     |
   // members...     |                     |
 }                   |                     |
</code></pre></div></div>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code>---------------------|---------------------|---------------------
 datatype D =        | type D              | datatype D =
     Ctor0(x0: X0)   |                     |    Ctor0(x0: X0)
   | Ctor1(x1: X1)   |                     |  | Ctor1(x1: X1)
   | ...             |                     |  | ...
 {                   |                     |
   // members...     |                     |
 }                   |                     |
---------------------|---------------------|---------------------
 class Cl            | type Cl             | class Cl
   extends T0, ...   |                     |   extends T0, ...
 {                   |                     | {
   constructor ()    |                     |   constructor ()
     spec...         |                     |     spec...
   {                 |                     |
     Body;           |                     |
   }                 |                     |
   // members...     |                     |
 }                   |                     | }
---------------------|---------------------|---------------------
 trait Tr            | type Tr             | trait Tr
   extends T0, ...   |                     |   extends T0, ...
 {                   |                     |
   // members...     |                     |
 }                   |                     |
---------------------|---------------------|---------------------
 iterator Iter(x: X) | type Iter           | iterator Iter(x: X)
   yields (y: Y)     |                     |   yields (y: Y)
   specification...  |                     |   specification...
 {                   |                     |
   Body;             |                     |
 }                   |                     |
---------------------|---------------------|---------------------
 module SubModule    | module SubModule    | not allowed
   ...               |   ...               |
 {                   | {                   |
   export SubModule  |   export SubModule  |
     ...             |     ...             |
   export A ...      |                     |
   // decls...       |   // decls...       |
 }                   | }                   |
---------------------|---------------------|---------------------
 import L = MS       | import L = MS       | not allowed
---------------------|---------------------|---------------------
</code></pre></div></div>

<p>Variations of functions (e.g., <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">twostate</span> <span class="kr">function</span></code>) are
handled like <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> above, and variations of methods (e.g.,
<code class="language-dafny highlighter-rouge"><span class="kr">lemma</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">twostate</span> <span class="kr">lemma</span></code>) are treated like <code class="language-dafny highlighter-rouge"><span class="kr">method</span></code> above. Since
the whole signature is exported, a function or method is exported to
be of the same kind, even through <code class="language-dafny highlighter-rouge"><span class="kr">provides</span></code>. For example, an exported
<code class="language-dafny highlighter-rouge"><span class="kr">twostate</span> <span class="kr">lemma</span></code> is exported as a <code class="language-dafny highlighter-rouge"><span class="kr">twostate</span> <span class="kr">lemma</span></code> (and thus is known
by importers to have two implicit heap parameters), and an exported
<code class="language-dafny highlighter-rouge"><span class="kr">least</span> <span class="kr">predicate</span> <span class="n">P</span></code> is exported as a <code class="language-dafny highlighter-rouge"><span class="kr">least</span> <span class="kr">predicate</span> <span class="n">P</span></code> (and thus
importers can use both <code class="language-dafny highlighter-rouge"><span class="n">P</span></code> and its prefix predicate <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="err">#</span></code>).</p>

<p>If <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is a <code class="language-dafny highlighter-rouge"><span class="kr">class</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">trait</span></code>, or <code class="language-dafny highlighter-rouge"><span class="kr">iterator</span></code>, then <code class="language-dafny highlighter-rouge"><span class="kr">provides</span> <span class="n">C</span></code> exports
the non-null reference type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> as an abstract type. This does not reveal
that <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is a reference type, nor does it export the nullable type <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code>.</p>

<p>In most cases, exporting a <code class="language-dafny highlighter-rouge"><span class="kr">class</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">trait</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">datatype</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">codatatype</span></code>, or
abstract type does not automatically export its members. Instead, any member
to be exported must be listed explicitly. For example, consider the type
declaration</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">trait</span> <span class="n">Tr</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span> <span class="p">{</span> <span class="mi">10</span> <span class="p">}</span>
  <span class="kr">function</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span> <span class="p">{</span> <span class="mi">12</span> <span class="p">}</span>
  <span class="kr">function</span> <span class="n">H</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span> <span class="p">{</span> <span class="mi">14</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>An export set that contains only <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span> <span class="n">Tr</span></code> has the effect of exporting</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">trait</span> <span class="n">Tr</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and an export set that contains only <code class="language-dafny highlighter-rouge"><span class="kr">provides</span> <span class="n">Tr</span><span class="p">,</span> <span class="n">Tr</span><span class="o">.</span><span class="n">F</span> <span class="kr">reveals</span> <span class="n">Tr</span><span class="o">.</span><span class="n">H</span></code> has
the effect of exporting</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">Tr</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">function</span> <span class="n">H</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span> <span class="p">{</span> <span class="mi">14</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There is no syntax (for example, <code class="language-dafny highlighter-rouge"><span class="n">Tr</span><span class="o">.*</span></code>) to export all members of a type.</p>

<p>Some members are exported automatically when the type is revealed.
Specifically:</p>
<ul>
  <li>Revealing a <code class="language-dafny highlighter-rouge"><span class="kr">datatype</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">codatatype</span></code> automatically exports the types
discriminators and destructors.</li>
  <li>Revealing an <code class="language-dafny highlighter-rouge"><span class="kr">iterator</span></code> automatically exports the iterators members.</li>
  <li>Revealing a class automatically exports the classs anonymous constructor, if any.</li>
</ul>

<p>For a <code class="language-dafny highlighter-rouge"><span class="kr">class</span></code>, a <code class="language-dafny highlighter-rouge"><span class="kr">constructor</span></code> member can be exported only if the class is revealed.
For a <code class="language-dafny highlighter-rouge"><span class="kr">class</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">trait</span></code>, a <code class="language-dafny highlighter-rouge"><span class="kr">var</span></code> member can be exported only if the class or trait is revealed
(but a <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> member can be exported even if the enclosing class or trait is only provided).</p>

<p>When exporting a sub-module, only the sub-modules eponymous export set is exported.
There is no way for a parent module to export any other export set of a sub-module, unless
it is done via an <code class="language-dafny highlighter-rouge"><span class="kr">import</span></code> declaration of the parent module.</p>

<p>The effect of declaring an import as <code class="language-dafny highlighter-rouge"><span class="kr">opened</span></code> is confined to the importing module. That
is, the ability of use such imported names as unqualified is not passed on to further
imports, as the following example illustrates:</p>

<!-- %check-resolve Modules.5.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Library</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">xyz</span> <span class="o">:=</span> <span class="mi">16</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">export</span>
    <span class="kr">provides</span> <span class="n">Lib</span>
    <span class="kr">provides</span> <span class="n">xyz</span> <span class="c1">// error: 'xyz' is not declared locally</span>

  <span class="kr">import</span> <span class="kr">opened</span> <span class="n">Lib</span> <span class="o">=</span> <span class="n">Library</span>

  <span class="kr">const</span> <span class="n">k0</span> <span class="o">:=</span> <span class="n">Lib</span><span class="o">.</span><span class="n">xyz</span>
  <span class="kr">const</span> <span class="n">k1</span> <span class="o">:=</span> <span class="n">xyz</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">Client</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="kr">opened</span> <span class="n">M</span>

  <span class="kr">const</span> <span class="n">a0</span> <span class="o">:=</span> <span class="n">M</span><span class="o">.</span><span class="n">Lib</span><span class="o">.</span><span class="n">xyz</span>
  <span class="kr">const</span> <span class="n">a1</span> <span class="o">:=</span> <span class="n">Lib</span><span class="o">.</span><span class="n">xyz</span>
  <span class="kr">const</span> <span class="n">a2</span> <span class="o">:=</span> <span class="n">M</span><span class="o">.</span><span class="n">xyz</span> <span class="c1">// error: M does not have a declaration 'xyz'</span>
  <span class="kr">const</span> <span class="n">a3</span> <span class="o">:=</span> <span class="n">xyz</span> <span class="c1">// error: unresolved identifier 'xyz'</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As highlighted in this example, module <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> can use <code class="language-dafny highlighter-rouge"><span class="n">xyz</span></code> as if it were a local
name (see declaration <code class="language-dafny highlighter-rouge"><span class="n">k1</span></code>), but the unqualified name <code class="language-dafny highlighter-rouge"><span class="n">xyz</span></code> is not made available
to importers of <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> (see declarations <code class="language-dafny highlighter-rouge"><span class="n">a2</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">a3</span></code>), nor is it possible for
<code class="language-dafny highlighter-rouge"><span class="n">M</span></code> to export the name <code class="language-dafny highlighter-rouge"><span class="n">xyz</span></code>.</p>

<p>A few other notes:</p>

<ul>
  <li>A <code class="language-dafny highlighter-rouge"><span class="kr">provides</span></code> list can mention <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, which means that all local names
(except export set names) in the module are exported as <code class="language-dafny highlighter-rouge"><span class="kr">provides</span></code>.</li>
  <li>A <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code> list can mention <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, which means that all local names
(except export set names) in the module are exported as <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code>, if
the declaration is allowed to appear in a <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code> clause, or as
<code class="language-dafny highlighter-rouge"><span class="kr">provides</span></code>, if the declaration is not allowed to appear in a <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code>
clause.</li>
  <li>If no export sets are declared, then the implicit
export set is <code class="language-dafny highlighter-rouge"><span class="kr">export</span> <span class="kr">reveals</span> <span class="o">*</span></code>.</li>
  <li>A refinement module acquires all the export sets from its refinement parent.</li>
  <li>Names acquired by a module from its refinement parent are also subject to
export lists. (These are local names just like those declared directly.)</li>
</ul>

<h4 id="sec-extends-list">4.5.2. Extends list</h4>
<p>An export set declaration may include an <em>extends</em> list, which is a list of
one or more export set names from the same module containing the declaration
(including export set names obtained from a refinement parent).
The effect is to include in the declaration the union of all the names in
the export sets in the extends list, along with any other names explicitly
included in the declaration. So for example in
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">10</span>
  <span class="kr">const</span> <span class="n">b</span> <span class="o">:=</span> <span class="mi">10</span>
  <span class="kr">const</span> <span class="n">c</span> <span class="o">:=</span> <span class="mi">10</span>
  <span class="kr">export</span> <span class="n">A</span> <span class="kr">reveals</span> <span class="n">a</span>
  <span class="kr">export</span> <span class="n">B</span> <span class="kr">reveals</span> <span class="n">b</span>
  <span class="kr">export</span> <span class="n">C</span> <span class="kr">extends</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>
    <span class="kr">reveals</span> <span class="n">c</span>
<span class="p">}</span>
</code></pre></div></div>
<p>export set <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> will contain the names <code class="language-dafny highlighter-rouge"><span class="n">a</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">b</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">c</span></code>.</p>

<h3 id="sec-module-abstraction">4.6. Module Abstraction</h3>

<p>Sometimes, using a specific implementation is unnecessary; instead,
all that is needed is a module that implements some interface.  In
that case, you can use an <em>abstract</em> module import. In Dafny, this is
written <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">A</span> <span class="o">:</span> <span class="n">B</span></code>.  This means bind the name <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> as before, but
instead of getting the exact module <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>, you get any module which
<em>adheres</em> to <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>.  Typically, the module <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> may have abstract type
definitions, classes with bodiless methods, or otherwise be unsuitable
to use directly.  Because of the way refinement is defined, any
refinement of <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> can be used safely. For example, suppose we start with
these declarations:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">Interface</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">addSome</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
    <span class="kr">ensures</span> <span class="n">addSome</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span>
<span class="p">}</span>
<span class="kr">abstract</span> <span class="kr">module</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="n">A</span> <span class="o">:</span> <span class="n">Interface</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="mi">6</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="o">.</span><span class="n">addSome</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can be more precise if we know that <code class="language-dafny highlighter-rouge"><span class="n">addSome</span></code> actually adds
exactly one. The following module has this behavior. Further, the
postcondition is stronger, so this is actually a refinement of the
Interface module.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">Implementation</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">addSome</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
    <span class="kr">ensures</span> <span class="n">addSome</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can then substitute <code class="language-dafny highlighter-rouge"><span class="n">Implementation</span></code> for <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> in a new module, by
declaring a refinement of <code class="language-dafny highlighter-rouge"><span class="n">Mod</span></code> which defines  <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> to be <code class="language-dafny highlighter-rouge"><span class="n">Implementation</span></code>.</p>

<!-- %check-build -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">Interface</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">addSome</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
    <span class="kr">ensures</span> <span class="n">addSome</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n</span>
<span class="p">}</span>
<span class="kr">abstract</span> <span class="kr">module</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="n">A</span> <span class="o">:</span> <span class="n">Interface</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="mi">6</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="o">.</span><span class="n">addSome</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">Implementation</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">addSome</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
    <span class="kr">ensures</span> <span class="n">addSome</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">{</span>
    <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">Mod2</span> <span class="kr">refines</span> <span class="n">Mod</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Implementation</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you refine an abstract import into a concrete one
Dafny checks that the concrete module is a
refinement of the abstract one. This means that the methods must have
compatible signatures, all the classes and datatypes with their
constructors and fields in the abstract one must be present in the
concrete one, the specifications must be compatible, etc.</p>

<p>A module that includes an abstract import must be declared <code class="language-dafny highlighter-rouge"><span class="kr">abstract</span></code>.</p>

<h3 id="sec-module-ordering">4.7. Module Ordering and Dependencies</h3>

<p>Dafny isnt particular about the textual order in which modules are
declared, but
they must follow some rules to be well formed. In particular,
there must be a way to order the modules in a program such that each
only refers to things defined <strong>before</strong> it in the ordering. That
doesnt mean the modules have to be given textually in that order in
the source text. Dafny will
figure out that order for you, assuming you havent made any circular
references. For example, this is pretty clearly meaningless:</p>

<!-- %check-resolve Modules.6.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">import</span> <span class="n">A</span> <span class="o">=</span> <span class="n">B</span>
<span class="kr">import</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span> <span class="c1">// error: circular</span>
</code></pre></div></div>

<p>You can have import statements at the toplevel and you can import
modules defined at the same level:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">import</span> <span class="n">A</span> <span class="o">=</span> <span class="n">B</span>
<span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span><span class="o">.</span><span class="n">whatever</span><span class="p">();</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">B</span> <span class="p">{</span> <span class="kr">method</span> <span class="n">whatever</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span>
</code></pre></div></div>

<p>In this case, everything is well defined because we can put <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> first,
followed by the <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> import, and then finally <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="p">()</span></code>. If there is no
permitted ordering, then Dafny will give an error, complaining about a cyclic
dependency.</p>

<p>Note that when rearranging modules and imports, they have to be kept
in the same containing module, which disallows some pathological
module structures. Also, the imports and submodules are always
considered to be before their containing module, even at the toplevel. This means that the
following is not well formed:</p>

<!-- %check-resolve Modules.7.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">doIt</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">doIt</span><span class="p">();</span> <span class="c1">// error: M precedes doIt</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>because the module <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> must come before any other kind of members, such
as methods. To define global functions like this, you can put them in
a module (called <code class="language-dafny highlighter-rouge"><span class="n">Globals</span></code>, say) and open it into any module that needs
its functionality. Finally, if you import via a path, such as <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">A</span>
<span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">C</span></code>, then this creates a dependency of <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> on <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> itself
depends on its own nested module <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="o">.</span><span class="n">C</span></code>.</p>

<h3 id="sec-name-resolution">4.8. Name Resolution</h3>

<p>When Dafny sees something like <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;.</span><span class="n">B</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;.</span><span class="n">C</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span></code>, how does it know what each part
refers to? The process Dafny uses to determine what identifier
sequences like this refer to is name resolution. Though the rules may
seem complex, usually they do what you would expect. Dafny first looks
up the initial identifier. Depending on what the first identifier
refers to, the rest of the identifier is looked up in the appropriate
context.</p>

<p>In terms of the grammar, sequences like the above are represented as
a <code class="language-dafny highlighter-rouge"><span class="n">NameSegment</span></code> followed by 0 or more <code class="language-dafny highlighter-rouge"><span class="n">Suffix</span></code>es.
The form shown above contains three instances of
<code class="language-dafny highlighter-rouge"><span class="n">AugmentedDotSuffix_</span></code>.</p>

<p>The resolution is different depending on whether it is in
a module context, an expression context or a type context.</p>

<h4 id="481-modules-and-name-spaces">4.8.1. Modules and name spaces</h4>

<p>A module is a collection of declarations, each of which has a name.
These names are held in two namespaces.</p>

<ul>
  <li>The names of export sets</li>
  <li>The names of all other declarations, including submodules and aliased modules</li>
</ul>

<p>In addition names can be classified as <em>local</em> or <em>imported</em>.</p>

<ul>
  <li>Local declarations of a module are the declarations
 that are explicit in the module and the
local declarations of the refinement parent. This includes, for
example, the <code class="language-dafny highlighter-rouge"><span class="n">N</span></code> of <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="n">N</span> <span class="o">=</span> </code> in the refinement parent, recursively.</li>
  <li>Imported names of a module are those brought in by <code class="language-dafny highlighter-rouge"><span class="kr">import</span> <span class="kr">opened</span></code> plus
the imported names in the refinement parent.</li>
</ul>

<p>Within each namespace, the local names are unique. Thus a module may
not reuse a name that a refinement parent has declared (unless it is a
refining declaration, which replaces both declarations, as described
in <a href="#sec-module-refinement">Section 10</a>).</p>

<p>Local names take precedence over imported names. If a name is used more than
once among imported names (coming from different imports), then it is
ambiguous to <em>use</em> the name without qualification.</p>

<h4 id="482-module-id-context-name-resolution">4.8.2. Module Id Context Name Resolution</h4>

<p>A qualified name may be used to refer to a module in an import statement or a refines clause of a module declaration.
Such a qualified name is resolved as follows, with respect to its syntactic
location within a module <code class="language-dafny highlighter-rouge"><span class="n">Z</span></code>:</p>

<ol>
  <li>
    <p>The leading identifier of the qualified name is resolved as a local or imported module name of <code class="language-dafny highlighter-rouge"><span class="n">Z</span></code>, if there
is one with a matching name. The target of a <code class="language-dafny highlighter-rouge"><span class="kr">refines</span></code> clause does not
consider local names, that is, in <code class="language-dafny highlighter-rouge"><span class="kr">module</span> <span class="n">Z</span> <span class="kr">refines</span> <span class="n">A</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">C</span></code>, any contents of <code class="language-dafny highlighter-rouge"><span class="n">Z</span></code>
are not considered in finding <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>.</p>
  </li>
  <li>
    <p>Otherwise, it is resolved as a local or imported module name of the most enclosing module of <code class="language-dafny highlighter-rouge"><span class="n">Z</span></code>,
iterating outward to each successive enclosing module until a match is
found or the default toplevel module is reached without a match.
No consideration of export sets, default or otherwise, is used in this step.
However, if at any stage a matching name is found that is not a module
declaration, the resolution fails. See the examples below.</p>
  </li>
</ol>

<p>3a. Once the leading identifier is resolved as say module <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>, the next
   identifier in the quallified name
   is resolved as a local or imported module name within <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>.
   The resolution is restricted to the default export set of <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>.</p>

<p>3b. If the resolved module name is a module alias (from an <code class="language-dafny highlighter-rouge"><span class="kr">import</span></code> statement)
   then the target of the alias is resolved as a new qualified name
   with respect to its syntactic context (independent of any resolutions or
modules so far). Since <code class="language-dafny highlighter-rouge"><span class="n">Z</span></code> depends on <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>, any such alias target will
already have been resolved, because modules are resolved in order of
dependency.</p>

<ol>
  <li>Step 3 is iterated for each identifier in the qualified module id,
resulting in a module that is the final resolution of the complete
qualified id.</li>
</ol>

<p>Ordinarily a module must be <em>imported</em> in order for its constituent
declarations to be visible inside a given module <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>. However, for the
resolution of qualified names this is not the case.</p>

<p>This example shows that the resolution of the refinement parent does not
use any local names:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">10</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">B</span> <span class="kr">refines</span> <span class="n">A</span> <span class="p">{</span> <span class="c1">// the top-level A, not the submodule A</span>
  <span class="kr">module</span> <span class="n">A</span> <span class="p">{</span> <span class="kr">const</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">30</span> <span class="p">}</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span> <span class="kr">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// true</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In the example, the <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> in <code class="language-dafny highlighter-rouge"><span class="kr">refines</span> <span class="n">A</span></code> refers to the global <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>, not the submodule <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>.</p>

<h4 id="483-expression-context-name-resolution">4.8.3. Expression Context Name Resolution</h4>

<p>The leading identifier is resolved using the first following
rule that succeeds.</p>

<ol>
  <li>
    <p>Local variables, parameters and bound variables. These are things like
<code class="language-dafny highlighter-rouge"><span class="n">x</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">y</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> in <code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">x</span><span class="p">;,</span> <span class="o">...</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span></code>, and
<code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">i</span> <span class="o">::</span> <span class="o">....</span></code> The declaration chosen is the match from the
innermost matching scope.</p>
  </li>
  <li>
    <p>If in a class, try to match a member of the class. If the member that
is found is not static an implicit <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code> is inserted. This works for
fields, functions, and methods of the current class (if in a static
context, then only static methods and functions are allowed). You can
refer to fields of the current class either as <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">f</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">f</span></code>,
assuming of course that <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> is not hidden by one of the above. You
can always prefix <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code> if needed, which cannot be hidden. (Note that a
field whose name is a string of digits must always have some prefix.)</p>
  </li>
  <li>
    <p>If there is no <code class="language-dafny highlighter-rouge"><span class="n">Suffix</span></code>, then look for a datatype constructor, if
unambiguous. Any datatypes that dont need qualification (so the
datatype name itself doesnt need a prefix) and also have a uniquely
named constructor can be referred to just by name.  So if
<code class="language-dafny highlighter-rouge"><span class="kr">datatype</span> <span class="n">List</span> <span class="o">=</span> <span class="n">Cons</span><span class="p">(</span><span class="n">List</span><span class="p">)</span> <span class="o">|</span> <span class="n">Nil</span></code> is the only datatype that declares
<code class="language-dafny highlighter-rouge"><span class="n">Cons</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Nil</span></code> constructors, then you can write <code class="language-dafny highlighter-rouge"><span class="n">Cons</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="n">Nil</span><span class="p">))</span></code>.
If the constructor name is not unique, then you need to prefix it with
the name of the datatype (for example <code class="language-dafny highlighter-rouge"><span class="n">List</span><span class="o">.</span><span class="n">Cons</span><span class="p">(</span><span class="n">List</span><span class="o">.</span><span class="n">Nil</span><span class="p">)))</span></code>. This is
done per constructor, not per datatype.</p>
  </li>
  <li>
    <p>Look for a member of the enclosing module.</p>
  </li>
  <li>
    <p>Module-level (static) functions and methods</p>
  </li>
</ol>

<p>In each module, names from opened modules are also potential matches, but
only after names declared in the module.
If an ambiguous name is found or a name of the wrong kind (e.g. a module
instead of an expression identifier), an error is generated, rather than continuing
down the list.</p>

<p>After the first identifier, the rules are basically the
same, except in the new context. For example, if the first identifier is
a module, then the next identifier looks into that module. Opened modules
only apply within the module it is opened into. When looking up into
another module, only things explicitly declared in that module are
considered.</p>

<p>To resolve expression <code class="language-dafny highlighter-rouge"><span class="n">E</span><span class="o">.</span><span class="n">id</span></code>:</p>

<p>First resolve expression E and any type arguments.</p>

<ul>
  <li>If <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> resolved to a module <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>:
    <ol>
      <li>If <code class="language-dafny highlighter-rouge"><span class="n">E</span><span class="o">.</span><span class="n">id</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> is not followed by any further suffixes, look for
unambiguous datatype constructor.</li>
      <li>Member of module M: a sub-module (including submodules of imports),
class, datatype, etc.</li>
      <li>Static function or method.</li>
    </ol>
  </li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> denotes a type:
    <ol>
      <li>Look up id as a member of that type</li>
    </ol>
  </li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> denotes an expression:
    <ol>
      <li>Let T be the type of E. Look up id in T.</li>
    </ol>
  </li>
</ul>

<h4 id="484-type-context-name-resolution">4.8.4. Type Context Name Resolution</h4>

<p>In a type context the priority of identifier resolution is:</p>

<ol>
  <li>
    <p>Type parameters.</p>
  </li>
  <li>
    <p>Member of enclosing module (type name or the name of a module).</p>
  </li>
</ol>

<p>To resolve expression <code class="language-dafny highlighter-rouge"><span class="n">E</span><span class="o">.</span><span class="n">id</span></code>:</p>

<ul>
  <li>If <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> resolved to a module <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>:
    <ol>
      <li>Member of module M: a sub-module (including submodules of imports),
class, datatype, etc.</li>
    </ol>
  </li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> denotes a type:
    <ol>
      <li>Then the validity and meaning of <code class="language-dafny highlighter-rouge"><span class="n">id</span></code> depends on the type and
must be a user-declared or pre-defined member of the type.</li>
    </ol>
  </li>
</ul>

<!--PDF NEWPAGE-->
<h2 id="sec-types">5. Types</h2>

<p>A Dafny type is a (possibly-empty) set of values or heap data-structures,
together with allowed operations on those values.
Types are classified as mutable reference types or immutable value types,
depending on whether their values are stored in the heap or are
(mathematical) values independent of the heap.</p>

<p>Dafny supports the following kinds of types,
all described in later sections of this manual:</p>
<ul>
  <li><a href="#sec-basic-type">builtin scalar types</a>,</li>
  <li><a href="#sec-collection-types">builtin collection types</a>,</li>
  <li>reference types (<a href="#sec-class-types">classes</a>, <a href="#sec-array-type">arrays</a>, <a href="#sec-iterator-types">iterators</a>),</li>
  <li><a href="#sec-trait-types">abstract supertypes</a> (traits)</li>
  <li><a href="#sec-tuple-types">tuple types</a> (including as a special case a parenthesized type),</li>
  <li><a href="#sec-datatype">inductive</a> and <a href="#sec-coinductive-datatypes">coinductive</a> datatypes,</li>
  <li><a href="#sec-arrow-subset-types">function (arrow) types</a>, and</li>
  <li><a href="#sec-subset-types">types, such as subset types, derived from other types</a>.</li>
</ul>

<h3 id="51-kinds-of-types">5.1. Kinds of types</h3>
<h4 id="511-value-types">5.1.1. Value Types</h4>
<p>The value types are those whose values do not lie in the program heap.
These are:</p>

<ul>
  <li>The basic scalar types: <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code>, bitvector types</li>
  <li>The built-in collection types: <code class="language-dafny highlighter-rouge"><span class="kt">set</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">iset</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">multiset</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">seq</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">string</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">map</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">imap</span></code></li>
  <li>Tuple Types</li>
  <li>Inductive and coinductive types</li>
  <li>Function (arrow) types</li>
  <li>Subset and newtypes that are based on value types</li>
</ul>

<p>Data items having value types are passed by value. Since they are not
considered to occupy <em>memory</em>, framing expressions do not reference them.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> type is a pre-defined <a href="#sec-subset-types">subset type</a> of <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>.</p>

<p>Dafny does not include types themselves as values, nor is there a type of types.</p>

<h4 id="sec-reference-types">5.1.2. Reference Types</h4>
<p>Dafny offers a host of <em>reference types</em>.  These represent
<em>references</em> to objects allocated dynamically in the program heap.  To
access the members of an object, a reference to (that is, a <em>pointer</em>
to or <em>object identity</em> of) the object is <em>dereferenced</em>.</p>

<p>The reference types are class types, traits and array types.
Dafny supports both reference types that contain the special <code class="language-dafny highlighter-rouge"><span class="kc">null</span></code> value
(<em>nullable types</em>) and reference types that do not (<em>non-null types</em>).</p>

<h4 id="513-named-types-grammar">5.1.3. Named Types (<a href="#g-type">grammar</a>)</h4>

<p>A <em>Named Type</em> is used to specify a user-defined type by a (possibly module- or class-qualified) name.
Named types are introduced by
class, trait, inductive, coinductive, synonym and abstract
type declarations. They are also used to refer to type variables.
A Named Type is denoted by a dot-separated sequence of name segments (<a href="#sec-name-segment">Section 9.32</a>).</p>

<p>A name segment (for a type) is a type name optionally followed by a
<em>generic instantiation</em>, which supplies type parameters to a generic
type, if needed.</p>

<p>The following sections describe each of these kinds of types in more detail.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-basic-type">5.2. Basic types</h3>

<p>Dafny offers these basic types: <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code> for booleans, <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> for
characters, <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> and <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> for integers, <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code> for reals,
<code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code>, and bit-vector types.</p>

<h4 id="sec-booleans">5.2.1. Booleans (<a href="#g-basic-type">grammar</a>)</h4>

<p>There are two boolean values and each has a corresponding literal in
the language:  <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> and <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>.</p>

<p>Type <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code> supports the following operations:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th style="text-align: center">precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;==&gt;</span></code></td>
      <td style="text-align: center">1</td>
      <td>equivalence (if and only if)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">==&gt;</span></code></td>
      <td style="text-align: center">2</td>
      <td>implication (implies)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;==</span></code></td>
      <td style="text-align: center">2</td>
      <td>reverse implication (follows from)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&amp;&amp;</span></code></td>
      <td style="text-align: center">3</td>
      <td>conjunction (and)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">||</span></code></td>
      <td style="text-align: center">3</td>
      <td>disjunction (or)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">==</span></code></td>
      <td style="text-align: center">4</td>
      <td>equality</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!=</span></code></td>
      <td style="text-align: center">4</td>
      <td>disequality</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!</span></code></td>
      <td style="text-align: center">10</td>
      <td>negation (not)</td>
    </tr>
  </tbody>
</table>

<p>Negation is unary; the others are binary.  The table shows the operators
in groups of increasing binding power, with equality binding stronger
than conjunction and disjunction, and weaker than negation.  Within
each group, different operators do not associate, so parentheses need
to be used.  For example,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span> <span class="o">||</span> <span class="n">C</span>    <span class="c1">// error</span>
</code></pre></div></div>
<p>would be ambiguous and instead has to be written as either
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">||</span> <span class="n">C</span>
</code></pre></div></div>
<p>or
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">||</span> <span class="n">C</span><span class="p">)</span>
</code></pre></div></div>
<p>depending on the intended meaning.</p>

<h5 id="sec-equivalence-operator">5.2.1.1. Equivalence Operator</h5>

<p>The expressions <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="n">B</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">==</span> <span class="n">B</span></code> give the same value, but note
that <code class="language-dafny highlighter-rouge"><span class="o">&lt;==&gt;</span></code> is <em>associative</em> whereas <code class="language-dafny highlighter-rouge"><span class="o">==</span></code> is <em>chaining</em> and they have
different precedence.  So,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="n">B</span> <span class="o">&lt;==&gt;</span> <span class="n">C</span>
</code></pre></div></div>
<p>is the same as
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="n">B</span> <span class="o">&lt;==&gt;</span> <span class="n">C</span><span class="p">)</span>
</code></pre></div></div>
<p>and
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">(</span><span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="n">C</span>
</code></pre></div></div>
<p>whereas
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">==</span> <span class="n">B</span> <span class="o">==</span> <span class="n">C</span>
</code></pre></div></div>
<p>is simply a shorthand for
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">==</span> <span class="n">B</span> <span class="o">&amp;&amp;</span> <span class="n">B</span> <span class="o">==</span> <span class="n">C</span>
</code></pre></div></div>

<p>Also,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="n">B</span> <span class="o">==</span> <span class="n">C</span> <span class="o">&lt;==&gt;</span> <span class="n">D</span>
</code></pre></div></div>
<p>is
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="n">B</span> <span class="o">==</span> <span class="n">C</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="n">D</span>
</code></pre></div></div>

<h5 id="sec-conjunction-and-disjunction">5.2.1.2. Conjunction and Disjunction</h5>

<p>Conjunction and disjunction are associative.  These operators are
<em>short circuiting (from left to right)</em>, meaning that their second
argument is evaluated only if the evaluation of the first operand does
not determine the value of the expression.  Logically speaking, the
expression <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span></code> is defined when <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> is defined and either <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>
evaluates to <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> is defined.  When <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span></code> is defined, its
meaning is the same as the ordinary, symmetric mathematical
conjunction <code class="language-dafny highlighter-rouge"><span class="o">&amp;</span></code>.  The same holds for <code class="language-dafny highlighter-rouge"><span class="o">||</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">|</span></code>.</p>

<h5 id="sec-implication-and-reverse-implication">5.2.1.3. Implication and  Reverse Implication</h5>

<p>Implication is <em>right associative</em> and is short-circuiting from left
to right.  Reverse implication <code class="language-dafny highlighter-rouge"><span class="n">B</span> <span class="o">&lt;==</span> <span class="n">A</span></code> is exactly the same as
<code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">==&gt;</span> <span class="n">B</span></code>, but gives the ability to write the operands in the opposite
order.  Consequently, reverse implication is <em>left associative</em> and is
short-circuiting from <em>right to left</em>.  To illustrate the
associativity rules, each of the following four lines expresses the
same property, for any <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code>:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">==&gt;</span> <span class="n">B</span> <span class="o">==&gt;</span> <span class="n">C</span>
<span class="n">A</span> <span class="o">==&gt;</span> <span class="p">(</span><span class="n">B</span> <span class="o">==&gt;</span> <span class="n">C</span><span class="p">)</span> <span class="c1">// parentheses redundant, ==&gt; is right associative</span>
<span class="n">C</span> <span class="o">&lt;==</span> <span class="n">B</span> <span class="o">&lt;==</span> <span class="n">A</span>
<span class="p">(</span><span class="n">C</span> <span class="o">&lt;==</span> <span class="n">B</span><span class="p">)</span> <span class="o">&lt;==</span> <span class="n">A</span> <span class="c1">// parentheses redundant, &lt;== is left associative</span>
</code></pre></div></div>
<p>To illustrate the short-circuiting rules, note that the expression
<code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="o">.</span><span class="n">Length</span></code> is defined for an array <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> only if <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is not <code class="language-dafny highlighter-rouge"><span class="kc">null</span></code> (see
<a href="#sec-reference-types">Section 5.1.2</a>), which means the following two
expressions are <a href="#sec-assertion-batches">well-formed</a>:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">==&gt;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span>
<span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">&lt;==</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span>
</code></pre></div></div>
<p>The contrapositives of these two expressions would be:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">==&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="kc">null</span>  <span class="c1">// not well-formed</span>
<span class="n">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&lt;==</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="c1">// not well-formed</span>
</code></pre></div></div>
<p>but these expressions might not necessarily be <a href="#sec-assertion-batches">well-formed</a>, since well-formedness
requires the left (and right, respectively) operand, <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">&lt;</span> <span class="mi">0</span></code>,
to be <a href="#sec-assertion-batches">well-formed</a> in their context.</p>

<p>Implication <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">==&gt;</span> <span class="n">B</span></code> is equivalent to the disjunction <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="n">A</span> <span class="o">||</span> <span class="n">B</span></code>, but
is sometimes (especially in specifications) clearer to read.  Since,
<code class="language-dafny highlighter-rouge"><span class="o">||</span></code> is short-circuiting from left to right, note that
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span>
</code></pre></div></div>
<p>is <a href="#sec-assertion-batches">well-formed</a> by itself, whereas
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">||</span> <span class="n">a</span> <span class="o">==</span> <span class="kc">null</span>  <span class="c1">// not well-formed</span>
</code></pre></div></div>
<p>is not if the context cannot prove that <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span></code>.</p>

<p>In addition, booleans support <em>logical quantifiers</em> (forall and
exists), described in <a href="#sec-quantifier-expression">Section 9.31.4</a>.</p>

<h4 id="sec-numeric-types">5.2.2. Numeric Types (<a href="#g-basic-type">grammar</a>)</h4>

<p>Dafny supports <em>numeric types</em> of two kinds, <em>integer-based</em>, which
includes the basic type <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> of all integers, and <em>real-based</em>, which
includes the basic type <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code> of all real numbers and the floating-point
type <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code>.  User-defined numeric types based on <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> and <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code>, either
<em>subset types</em> or <em>newtypes</em>, are described in <a href="#sec-subset-types">Section 5.6.3</a>
and <a href="#sec-newtypes">Section 5.7</a>.</p>

<p>There is one built-in <a href="#sec-subset-types"><em>subset type</em></a>,
<code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code>, representing the non-negative subrange of <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>.</p>

<p>The language includes a literal for each integer, like
<code class="language-dafny highlighter-rouge"><span class="mi">0</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">13</span></code>, and <code class="language-dafny highlighter-rouge"><span class="mi">1985</span></code>.  Integers can also be written in hexadecimal
using the prefix <code class="language-dafny highlighter-rouge"><span class="err">0x</span></code>, as in <code class="language-dafny highlighter-rouge"><span class="mh">0x0</span></code>, <code class="language-dafny highlighter-rouge"><span class="mh">0xD</span></code>, and <code class="language-dafny highlighter-rouge"><span class="mh">0x7c1</span></code> (always with
a lower case <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>, but the hexadecimal digits themselves are case
insensitive).  Leading zeros are allowed.  To form negative literals,
use the unary minus operator, as in <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="mi">12</span></code>, but not <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span></code>.</p>

<p>There are also <strong>real literals</strong> for some of the reals. Real literals
are written as decimal numbers, optionally prefixed by a <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> character.
Examples: <code class="language-dafny highlighter-rouge"><span class="mf">1.0</span></code>, <code class="language-dafny highlighter-rouge"><span class="mf">1609.344</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="mf">12.5</span></code>, and <code class="language-dafny highlighter-rouge"><span class="mf">0.5772156649</span></code>.</p>

<p>Real literals can also be written in <strong>scientific notation</strong> using lowercase <code class="language-dafny highlighter-rouge"><span class="n">e</span></code>
to denote the exponent. For example, <code class="language-dafny highlighter-rouge"><span class="mi">1</span><span class="o">.</span><span class="err">23e5</span></code> (which equals <code class="language-dafny highlighter-rouge"><span class="mf">123000.0</span></code>),
<code class="language-dafny highlighter-rouge"><span class="mi">1</span><span class="o">.</span><span class="err">23e</span><span class="o">-</span><span class="mi">2</span></code> (which equals <code class="language-dafny highlighter-rouge"><span class="mf">0.0123</span></code>), and <code class="language-dafny highlighter-rouge"><span class="err">5e2</span></code> (which equals <code class="language-dafny highlighter-rouge"><span class="mf">500.0</span></code>).
Both decimal numbers with optional exponents (like <code class="language-dafny highlighter-rouge"><span class="mi">1</span><span class="o">.</span><span class="err">23e5</span></code>) and integers
with mandatory exponents (like <code class="language-dafny highlighter-rouge"><span class="err">123e5</span></code>) are supported.</p>

<p>As a convenience, <strong>trailing-dot shorthand</strong> can be used with real literals,
where a trailing-dot represents <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="mi">0</span></code>. For example, <code class="language-dafny highlighter-rouge"><span class="mi">1</span><span class="o">.</span></code> means <code class="language-dafny highlighter-rouge"><span class="mf">1.0</span></code> and
<code class="language-dafny highlighter-rouge"><span class="mi">123</span><span class="o">.</span></code> means <code class="language-dafny highlighter-rouge"><span class="mf">123.0</span></code>.</p>

<p>Real literals also support <strong>leading-dot shorthand</strong> for decimal values less than 1.
For example, <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="mi">5</span></code> means <code class="language-dafny highlighter-rouge"><span class="mf">0.5</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="mi">25</span></code> means <code class="language-dafny highlighter-rouge"><span class="mf">0.25</span></code>, and leading-dot shorthand can be
combined with scientific notation like <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="err">5e2</span></code> (which equals <code class="language-dafny highlighter-rouge"><span class="mf">50.0</span></code>) or <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="err">123e</span><span class="o">-</span><span class="mi">4</span></code>
(which equals <code class="language-dafny highlighter-rouge"><span class="mf">0.0000123</span></code>).</p>

<p>For integers (in both decimal and hexadecimal form) and reals,
any two digits in a literal may be separated by an underscore in order
to improve human readability of the literals.  For example:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">c1</span> <span class="o">:=</span> <span class="mi">1_000_000</span>        <span class="c1">// easier to read than 1000000</span>
<span class="kr">const</span> <span class="n">c2</span> <span class="o">:=</span> <span class="mi">0_12_345_6789</span>    <span class="c1">// strange but legal formatting of 123456789</span>
<span class="kr">const</span> <span class="n">c3</span> <span class="o">:=</span> <span class="mh">0x8000_0000</span>      <span class="c1">// same as 0x80000000 -- hex digits are</span>
                             <span class="c1">// often placed in groups of 4</span>
<span class="kr">const</span> <span class="n">c4</span> <span class="o">:=</span> <span class="mf">0.000_000_000_1</span>  <span class="c1">// same as 0.0000000001 -- 1 Angstrom</span>
</code></pre></div></div>

<p>In addition to equality and disequality, numeric types
support the following relational operations, which have the
same precedence as equality:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code></td>
      <td>less than</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code></td>
      <td>at most</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code></td>
      <td>at least</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code></td>
      <td>greater than</td>
    </tr>
  </tbody>
</table>

<p>Like equality and disequality, these operators are chaining, as long
as they are chained in the same direction.  That is,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&lt;=</span> <span class="n">B</span> <span class="o">&lt;</span> <span class="n">C</span> <span class="o">==</span> <span class="n">D</span> <span class="o">&lt;=</span> <span class="n">E</span>
</code></pre></div></div>
<p>is simply a shorthand for
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&lt;=</span> <span class="n">B</span> <span class="o">&amp;&amp;</span> <span class="n">B</span> <span class="o">&lt;</span> <span class="n">C</span> <span class="o">&amp;&amp;</span> <span class="n">C</span> <span class="o">==</span> <span class="n">D</span> <span class="o">&amp;&amp;</span> <span class="n">D</span> <span class="o">&lt;=</span> <span class="n">E</span>
</code></pre></div></div>
<p>whereas
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&lt;</span> <span class="n">B</span> <span class="o">&gt;</span> <span class="n">C</span>
</code></pre></div></div>
<p>is not allowed.</p>

<p>There are also operators on each numeric type:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th style="text-align: center">precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">+</span></code></td>
      <td style="text-align: center">6</td>
      <td>addition (plus)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">-</span></code></td>
      <td style="text-align: center">6</td>
      <td>subtraction (minus)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">*</span></code></td>
      <td style="text-align: center">7</td>
      <td>multiplication (times)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">/</span></code></td>
      <td style="text-align: center">7</td>
      <td>division (divided by)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">%</span></code></td>
      <td style="text-align: center">7</td>
      <td>modulus (mod)   int only</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">-</span></code></td>
      <td style="text-align: center">10</td>
      <td>negation (unary minus)</td>
    </tr>
  </tbody>
</table>

<p>The binary operators are left associative, and they associate with
each other in the two groups.
The groups are listed in order of
increasing binding power, with equality binding less strongly than any of these operators.
There is no implicit conversion between <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> and <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code>: use <code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="kt">int</span></code> or
<code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="kt">real</span></code> conversions to write an explicit conversion (cf. <a href="#sec-as-is-expression">Section 9.10</a>).</p>

<p>Modulus is supported only for integer-based numeric types.  Integer
division and modulus are the <em>Euclidean division and modulus</em>.  This
means that modulus always returns a non-negative value, regardless of the
signs of the two operands.  More precisely, for any integer <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> and
non-zero integer <code class="language-dafny highlighter-rouge"><span class="n">b</span></code>,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span> <span class="o">==</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
<span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">B</span>
</code></pre></div></div>
<p>where <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> denotes the absolute value of <code class="language-dafny highlighter-rouge"><span class="n">b</span></code>.</p>

<p>Real-based numeric types have a member <code class="language-dafny highlighter-rouge"><span class="n">Floor</span></code> that returns the
<em>floor</em> of the real value (as an int value), that is, the largest integer not exceeding
the real value.  For example, the following properties hold, for any
<code class="language-dafny highlighter-rouge"><span class="n">r</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">r'</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code>:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">real</span><span class="p">,</span> <span class="n">r'</span><span class="o">:</span> <span class="kt">real</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="mf">3.14</span><span class="o">.</span><span class="n">Floor</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">)</span><span class="o">.</span><span class="n">Floor</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="o">-</span><span class="mf">2.5</span><span class="o">.</span><span class="n">Floor</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// This is -(2.5.Floor)</span>
  <span class="kr">assert</span> <span class="n">r</span><span class="o">.</span><span class="n">Floor</span> <span class="ow">as</span> <span class="kt">real</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">r'</span> <span class="o">==&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">Floor</span> <span class="o">&lt;=</span> <span class="n">r'</span><span class="o">.</span><span class="n">Floor</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note in the third line that member access (like <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">Floor</span></code>) binds
stronger than unary minus.  The fourth line uses the conversion
function <code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="kt">real</span></code> from <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> to <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code>, as described in
<a href="#sec-as-is-expression">Section 9.10</a>.</p>

<h4 id="sec-floating-point-type">5.2.3. Floating-point Types (fp32 and fp64)</h4>

<p>Dafny supports two floating-point types: <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> (IEEE 754 binary32, single-precision)
and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> (IEEE 754 binary64, double-precision). These types provide hardware-compatible
floating-point arithmetic with the expected precision and rounding behavior. Both types
are considered real-based numeric types in Dafnys type system.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> type has 24 bits of significand precision (approximately 7 decimal digits),
while <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> has 53 bits (approximately 16 decimal digits).</p>

<h5 id="5231-literals">5.2.3.1. Literals</h5>

<p>Floating-point literals use the same notation as real literals, but the type system distinguishes between
exact and approximate representations:</p>

<ul>
  <li>
    <p><strong>Exact literals</strong>: Values that can be represented exactly in binary floating-point,
such as powers of 2 (<code class="language-dafny highlighter-rouge"><span class="mf">0.5</span></code>, <code class="language-dafny highlighter-rouge"><span class="mf">0.25</span></code>, <code class="language-dafny highlighter-rouge"><span class="mf">1.0</span></code>) and small integers.</p>
  </li>
  <li>
    <p><strong>Approximate literals</strong>: Values that cannot be represented exactly and require the
<code class="language-dafny highlighter-rouge"><span class="err">~</span></code> prefix to acknowledge rounding. For example, <code class="language-dafny highlighter-rouge"><span class="err">~</span><span class="mf">0.1</span></code>, <code class="language-dafny highlighter-rouge"><span class="err">~</span><span class="mf">3.14</span></code>, <code class="language-dafny highlighter-rouge"><span class="err">~</span><span class="mf">0.3</span></code>.</p>
  </li>
</ul>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">FloatingPointLiterals</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">exact</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mf">0.5</span><span class="p">;</span>      <span class="c1">// Exact: 0.5 = 2^(-1)</span>
  <span class="kr">var</span> <span class="n">approx</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="err">~</span><span class="mf">0.1</span><span class="p">;</span>    <span class="c1">// Approximate: 0.1 cannot be exactly represented</span>

  <span class="c1">// Scientific notation is supported</span>
  <span class="kr">var</span> <span class="n">large</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">.</span><span class="err">23e10</span><span class="p">;</span>  <span class="c1">// 12300000000.0</span>
  <span class="kr">var</span> <span class="n">small</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="err">~</span><span class="mi">1</span><span class="o">.</span><span class="err">5e</span><span class="o">-</span><span class="mi">10</span><span class="p">;</span> <span class="c1">// Very small number</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="err">~</span></code> prefix must encompass the entire literal including the sign:</p>
<ul>
  <li>Correct: <code class="language-dafny highlighter-rouge"><span class="err">~</span><span class="o">-</span><span class="mf">0.1</span></code> (approximate negative one-tenth)</li>
  <li>Incorrect: <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="err">~</span><span class="mf">0.1</span></code> (not allowed)</li>
</ul>

<h5 id="5232-special-values">5.2.3.2. Special Values</h5>

<p>Both <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> types include IEEE 754 special values as static members:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">NaN</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">NaN</span></code> - Not a Number</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">PositiveInfinity</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">PositiveInfinity</span></code> - Positive infinity (+)</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">NegativeInfinity</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">NegativeInfinity</span></code> - Negative infinity (-)</li>
</ul>

<p>Additional constants include:</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">MaxValue</span></code> - Largest finite positive value</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">MinValue</span></code> - Most negative finite value</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">Epsilon</span></code> - Smallest positive value such that <code class="language-dafny highlighter-rouge"><span class="mf">1.0</span> <span class="o">+</span> <span class="n">Epsilon</span> <span class="o">!=</span> <span class="mf">1.0</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">MinNormal</span></code> - Smallest positive normal number</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">MinSubnormal</span></code> - Smallest positive subnormal number</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">Pi</span></code> - The mathematical constant  (pi)</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">E</span></code> - The mathematical constant e (Eulers number)</li>
</ul>

<h5 id="5233-classification-predicates">5.2.3.3. Classification Predicates</h5>

<p>Values of type <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> support classification predicates to test for special values:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsNaN</span></code> - true if the value is NaN</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsInfinite</span></code> - true if the value is positive or negative infinity</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsFinite</span></code> - true if the value is neither NaN nor infinite</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsNormal</span></code> - true if the value is a normal (not subnormal) number</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsSubnormal</span></code> - true if the value is a subnormal number</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsZero</span></code> - true if the value is positive or negative zero</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsPositive</span></code> - true if the value has a positive sign</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsNegative</span></code> - true if the value has a negative sign</li>
</ul>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">ClassificationExample</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">nan</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">NaN</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">inf</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">PositiveInfinity</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">zero</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">normal</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mf">1.0</span><span class="p">;</span>

  <span class="kr">assert</span> <span class="n">nan</span><span class="o">.</span><span class="n">IsNaN</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">inf</span><span class="o">.</span><span class="n">IsInfinite</span> <span class="o">&amp;&amp;</span> <span class="n">inf</span><span class="o">.</span><span class="n">IsPositive</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">zero</span><span class="o">.</span><span class="n">IsZero</span> <span class="o">&amp;&amp;</span> <span class="n">zero</span><span class="o">.</span><span class="n">IsFinite</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">normal</span><span class="o">.</span><span class="n">IsNormal</span> <span class="o">&amp;&amp;</span> <span class="n">normal</span><span class="o">.</span><span class="n">IsFinite</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="5234-arithmetic-operations">5.2.3.4. Arithmetic Operations</h5>

<p>Both <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> types support standard arithmetic operations following IEEE 754 semantics:</p>

<ul>
  <li>Addition (<code class="language-dafny highlighter-rouge"><span class="o">+</span></code>), subtraction (<code class="language-dafny highlighter-rouge"><span class="o">-</span></code>), multiplication (<code class="language-dafny highlighter-rouge"><span class="o">*</span></code>), division (<code class="language-dafny highlighter-rouge"><span class="o">/</span></code>)</li>
  <li>Unary negation (<code class="language-dafny highlighter-rouge"><span class="o">-</span></code>)</li>
  <li>Comparisons (<code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code>)</li>
</ul>

<p><strong>Well-formedness checks</strong>: All these arithmetic operations and comparisons require that operands are not NaN. Additionally, certain combinations of infinity values produce invalid operations:</p>

<ul>
  <li>Addition: <code class="language-dafny highlighter-rouge"><span class="err"></span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="err"></span><span class="p">)</span></code> is invalid</li>
  <li>Subtraction: <code class="language-dafny highlighter-rouge"><span class="err"></span> <span class="o">-</span> <span class="err"></span></code> is invalid</li>
  <li>Multiplication: <code class="language-dafny highlighter-rouge"><span class="err"></span> <span class="o">*</span> <span class="mi">0</span></code> is invalid</li>
  <li>Division: <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span></code> and <code class="language-dafny highlighter-rouge"><span class="err"></span> <span class="o">/</span> <span class="err"></span></code> are invalid</li>
</ul>

<p>These well-formedness checks are performed by Dafny. To help it, use the classification predicates (<code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsNaN</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsInfinite</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsZero</span></code>).</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">FloatingPointArithmetic</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">a</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="err">~</span><span class="mf">0.1</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">b</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="err">~</span><span class="mf">0.2</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">c</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="err">~</span><span class="mf">0.3</span><span class="p">;</span>

  <span class="kr">assert</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">// 0.1 + 0.2 != 0.3 due to rounding</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">SafeArithmetic</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fp64</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="n">fp64</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">result</span><span class="o">:</span> <span class="n">fp64</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">y</span><span class="o">.</span><span class="n">IsNaN</span>
  <span class="kr">requires</span> <span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">IsInfinite</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">.</span><span class="n">IsInfinite</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="n">IsPositive</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">IsPositive</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">result</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// OK: preconditions established</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="5235-equality">5.2.3.5. Equality</h5>

<p>Both <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> types have equality semantics that differ from IEEE 754. Equality is defined based on the bit representation:</p>

<ul>
  <li>
    <p>In <strong>compiled contexts</strong> the <code class="language-dafny highlighter-rouge"><span class="o">==</span></code> operator has <strong>well-formedness conditions</strong> that
require operands to not be NaN and, if they are zeros, to have the same sign.
Under these conditions, <code class="language-dafny highlighter-rouge"><span class="o">==</span></code> behaves like IEEE 754 equality.</p>
  </li>
  <li>
    <p>In <strong>ghost contexts</strong> (specifications, assertions): The well-formedness conditions are
relaxed, and <code class="language-dafny highlighter-rouge"><span class="o">==</span></code> performs bitwise comparison where NaN equals itself and positive/negative
zero are distinct.</p>
  </li>
  <li>
    <p>The static methods <code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></code> provide IEEE 754 equality
semantics without well-formedness restrictions (NaN is not equal to anything including itself,
and 0 are equal).</p>
  </li>
</ul>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">EqualityExample</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">fp64</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="n">fp64</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">nan</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">NaN</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">posZero</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">negZero</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="o">-</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="c1">// In ghost context - no well-formedness restrictions</span>
  <span class="kr">assert</span> <span class="n">nan</span> <span class="o">==</span> <span class="n">nan</span><span class="p">;</span>           <span class="c1">// true (bitwise comparison)</span>
  <span class="kr">assert</span> <span class="n">posZero</span> <span class="o">!=</span> <span class="n">negZero</span><span class="p">;</span>   <span class="c1">// true (different bit patterns)</span>

  <span class="c1">// In compiled context - well-formedness restrictions verified statically</span>
  <span class="c1">// var b1 := x == y;              // ERROR: verifier cannot prove x and y are not NaN</span>
  <span class="c1">// var b2 := posZero == negZero;  // ERROR: verifier knows they have different signs</span>

  <span class="c1">// Valid use of == when preconditions can be verified</span>
  <span class="kr">if</span> <span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span> <span class="p">{</span>
    <span class="c1">// Can compare posZero with x since we know posZero is not NaN,</span>
    <span class="c1">// and if x is also zero, we'd need to check signs match</span>
    <span class="kr">if</span> <span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsZero</span> <span class="o">||</span> <span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNegative</span> <span class="p">{</span>
      <span class="kr">var</span> <span class="n">equal</span> <span class="o">:=</span> <span class="n">posZero</span> <span class="o">==</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// OK: not NaN, and no sign mismatch</span>
      <span class="kr">print</span> <span class="s2">"0.0 == "</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">": "</span><span class="p">,</span> <span class="n">equal</span><span class="p">,</span> <span class="s2">"\n"</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Simpler: just use fp64.Equal when unsure about values</span>
  <span class="kr">var</span> <span class="n">maybeNaN</span> <span class="o">:=</span> <span class="kr">if</span> <span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="n">IsNegative</span> <span class="kr">then</span> <span class="n">fp64</span><span class="o">.</span><span class="n">NaN</span> <span class="kr">else</span> <span class="n">x</span><span class="p">;</span>
  <span class="c1">// var bad := maybeNaN == x;  // ERROR: cannot prove maybeNaN is not NaN</span>
  <span class="kr">var</span> <span class="n">safe</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">maybeNaN</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">// Always works, no preconditions</span>

  <span class="c1">// fp64.Equal always uses IEEE 754 semantics</span>
  <span class="kr">assert</span> <span class="o">!</span><span class="n">fp64</span><span class="o">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="n">nan</span><span class="p">);</span>        <span class="c1">// NaN != NaN</span>
  <span class="kr">assert</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">posZero</span><span class="p">,</span> <span class="n">negZero</span><span class="p">);</span> <span class="c1">// 0 are equal</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="5236-unchecked-arithmetic-and-comparison-methods">5.2.3.6. Unchecked Arithmetic and Comparison Methods</h5>

<p>For operations that may involve NaN or invalid infinity combinations, both <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> provide unchecked static methods:</p>

<p><strong>Arithmetic methods:</strong></p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Addition without well-formedness checks</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Subtraction without well-formedness checks</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Multiplication without well-formedness checks</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Division without well-formedness checks</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Neg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Neg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> - Negation without well-formedness checks</li>
</ul>

<p><strong>Comparison methods:</strong></p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Less than without well-formedness checks</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">LessOrEqual</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">LessOrEqual</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Less than or equal without well-formedness checks</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Greater than without well-formedness checks</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">GreaterOrEqual</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">GreaterOrEqual</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Greater than or equal without well-formedness checks</li>
</ul>

<p>These methods follow IEEE 754 semantics exactly, including producing NaN for invalid operations and returning false for all comparisons involving NaN.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">EdgeCaseTesting</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">nan</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">NaN</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">inf</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">PositiveInfinity</span><span class="p">;</span>

  <span class="c1">// These would fail with operators due to wellformedness checks:</span>
  <span class="c1">// var bad1 := nan + 1.0;      // ERROR: fp64 arithmetic requires that operands are not NaN</span>
  <span class="c1">// var bad2 := inf - inf;      // ERROR: fp64 subtraction has invalid operand combination</span>
  <span class="c1">// var bad3 := nan &lt; 1.0;      // ERROR: fp64 comparison requires that operands are not NaN</span>

  <span class="c1">// But work with unchecked static methods:</span>
  <span class="kr">var</span> <span class="n">result1</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">result2</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Sub</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">result3</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Less</span><span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

  <span class="kr">assert</span> <span class="n">result1</span><span class="o">.</span><span class="n">IsNaN</span><span class="p">;</span>  <span class="c1">// NaN propagates</span>
  <span class="kr">assert</span> <span class="n">result2</span><span class="o">.</span><span class="n">IsNaN</span><span class="p">;</span>  <span class="c1">//  -  = NaN</span>
  <span class="kr">assert</span> <span class="o">!</span><span class="n">result3</span><span class="p">;</span>       <span class="c1">// NaN &lt; anything = false</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Recommendation</strong>: Use operators (<code class="language-dafny highlighter-rouge"><span class="o">+</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">-</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">/</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code>, etc.) by default for their safety guarantees. Only use these unchecked static methods when you specifically need to handle edge cases or rely on IEEE 754 behavior.</p>

<h5 id="5237-mathematical-functions">5.2.3.7. Mathematical Functions</h5>

<p>Both <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> types provide static methods for common mathematical operations. All functions
require that operands are not NaN, and some have additional preconditions:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> - Absolute value. <strong>Requires</strong>: <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> - Square root. <strong>Requires</strong>: <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="err"></span> <span class="mf">0.0</span></code> (non-negative). Returns x for finite x  0, returns + for x = +.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Minimum of two values. <strong>Requires</strong>: <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">y</span><span class="o">.</span><span class="n">IsNaN</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></code> - Maximum of two values. <strong>Requires</strong>: <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">y</span><span class="o">.</span><span class="n">IsNaN</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> - Round down to nearest integer. <strong>Requires</strong>: <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Ceiling</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Ceiling</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> - Round up to nearest integer. <strong>Requires</strong>: <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">Round</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">Round</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> - Round to nearest integer, ties to even. <strong>Requires</strong>: <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">IsNaN</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">ToInt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">ToInt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> - Convert to integer. <strong>Requires</strong>: <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">.</span><span class="n">IsFinite</span></code>.</li>
</ul>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">MathFunctions</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="o">-</span><span class="mf">3.5</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">y</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mf">2.0</span><span class="p">;</span>

  <span class="kr">var</span> <span class="n">absX</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">sqrtY</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">minimum</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">floored</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Floor</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">ceiled</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Ceiling</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">rounded</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Round</span><span class="p">(</span><span class="mf">2.5</span><span class="p">);</span>  <span class="c1">// Rounds to 2.0 (nearest even)</span>

  <span class="kr">assert</span> <span class="n">absX</span> <span class="o">==</span> <span class="mf">3.5</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">sqrtY</span> <span class="o">==</span> <span class="err">~</span><span class="mf">1.4142135623730951</span><span class="p">;</span>  <span class="c1">// Approximate 2</span>
  <span class="kr">assert</span> <span class="n">minimum</span> <span class="o">==</span> <span class="n">x</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">floored</span> <span class="o">==</span> <span class="o">-</span><span class="mf">4.0</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">ceiled</span> <span class="o">==</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">rounded</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Special value behavior:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">SpecialValueBehavior</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">inf</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">PositiveInfinity</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">negInf</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">;</span>

  <span class="c1">// Math functions work with infinity when preconditions are met</span>
  <span class="kr">var</span> <span class="n">sqrtInf</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">inf</span><span class="p">);</span>        <span class="c1">// Returns positive infinity</span>
  <span class="kr">var</span> <span class="n">absNegInf</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">negInf</span><span class="p">);</span>    <span class="c1">// Returns positive infinity</span>
  <span class="kr">var</span> <span class="n">minInf</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">Min</span><span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="n">negInf</span><span class="p">);</span>  <span class="c1">// Returns negative infinity</span>

  <span class="kr">assert</span> <span class="n">sqrtInf</span> <span class="o">==</span> <span class="n">fp64</span><span class="o">.</span><span class="n">PositiveInfinity</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">absNegInf</span> <span class="o">==</span> <span class="n">fp64</span><span class="o">.</span><span class="n">PositiveInfinity</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">minInf</span> <span class="o">==</span> <span class="n">fp64</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">;</span>

  <span class="c1">// Well-formedness checks prevent invalid operations</span>
  <span class="c1">// var sqrtNeg := fp64.Sqrt(-1.0);   // ERROR: negative input not allowed</span>
  <span class="c1">// var floorNaN := fp64.Floor(fp64.NaN); // ERROR: NaN not allowed</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="5238-type-conversions">5.2.3.8. Type Conversions</h5>

<p>Both <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> types support conversions to and from other numeric types using the <code class="language-dafny highlighter-rouge"><span class="ow">as</span></code> operator:</p>

<ul>
  <li>
    <p><strong>From <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code>/<code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code></strong>: Requires the real value to be exactly representable in the target type.</p>
  </li>
  <li>
    <p><strong>From <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code>/<code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> to <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code></strong>: Requires the floating-point value to be finite (not NaN or infinity).</p>
  </li>
  <li>
    <p><strong>From <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code>/<code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code></strong>: Requires the integer to be exactly representable in the target type.</p>
  </li>
  <li>
    <p><strong>From <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code>/<code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> to <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code></strong>: Requires the floating-point value to be finite and represent an exact integer.</p>
  </li>
  <li>
    <p><strong>Between <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code></strong>: Conversions are allowed in both directions. <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> is always exact. <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> requires the value to be exactly representable in fp32.</p>
  </li>
</ul>

<p><strong>Note</strong>: Direct conversions between <code class="language-dafny highlighter-rouge"><span class="n">bv</span></code> and floating-point types are not supported. To convert between
these types, use <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> as an intermediate type (e.g., <code class="language-dafny highlighter-rouge"><span class="n">bv_value</span> <span class="ow">as</span> <span class="kt">int</span> <span class="ow">as</span> <span class="n">fp64</span></code> or
<code class="language-dafny highlighter-rouge"><span class="n">fp64_value</span> <span class="ow">as</span> <span class="kt">int</span> <span class="ow">as</span> <span class="kt">bv32</span></code>).</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">ConversionExamples</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Real to fp64</span>
  <span class="kr">var</span> <span class="n">r1</span><span class="o">:</span> <span class="kt">real</span> <span class="o">:=</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="c1">// var f1: fp64 := r1 as fp64;  // OK: 0.5 is exactly representable, but times out</span>

  <span class="kr">var</span> <span class="n">r2</span><span class="o">:</span> <span class="kt">real</span> <span class="o">:=</span> <span class="mf">0.1</span><span class="p">;</span>
  <span class="c1">// var f2: fp64 := r2 as fp64;  // ERROR: 0.1 is not exactly representable</span>

  <span class="c1">// fp64 to real</span>
  <span class="kr">var</span> <span class="n">f3</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mf">42.5</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">r3</span><span class="o">:</span> <span class="kt">real</span> <span class="o">:=</span> <span class="n">f3</span> <span class="ow">as</span> <span class="kt">real</span><span class="p">;</span>  <span class="c1">// OK: finite value</span>

  <span class="c1">// int to fp64</span>
  <span class="kr">var</span> <span class="n">i1</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="c1">// var f4: fp64 := i1 as fp64;  // OK: 42 is exactly representable, but times out</span>
  <span class="kr">var</span> <span class="n">i2</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">9007199254740992</span><span class="p">;</span>  <span class="c1">// 2^53</span>
  <span class="c1">// var f5: fp64 := i2 as fp64;  // OK: 2^53 is exactly representable, but times out</span>
  <span class="kr">var</span> <span class="n">i3</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">9007199254740993</span><span class="p">;</span>  <span class="c1">// 2^53 + 1</span>
  <span class="c1">// var f6: fp64 := i3 as fp64;  // ERROR: 2^53 + 1 is not exactly representable</span>

  <span class="c1">// fp64 to int</span>
  <span class="kr">var</span> <span class="n">f7</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mf">3.0</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">i4</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="n">f7</span> <span class="ow">as</span> <span class="kt">int</span><span class="p">;</span>  <span class="c1">// OK: 3 is an integer</span>

  <span class="kr">var</span> <span class="n">f8</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="err">~</span><span class="mf">3.14</span><span class="p">;</span>
  <span class="c1">// var i5: int := f8 as int;  // ERROR: 3.14 is not an integer</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Note</strong>: There is a known limitation with conversions to floating-point types using the <code class="language-dafny highlighter-rouge"><span class="ow">as</span></code> operator:</p>

<ul>
  <li><strong>Direct literal conversions work</strong>: <code class="language-dafny highlighter-rouge"><span class="mi">42</span> <span class="ow">as</span> <span class="n">fp64</span></code>, <code class="language-dafny highlighter-rouge"><span class="mf">0.5</span> <span class="ow">as</span> <span class="n">fp32</span></code> verify successfully.</li>
  <li><strong>Variable conversions may timeout</strong>: Converting a variable to fp32/fp64 (e.g., <code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span> <span class="n">i</span> <span class="ow">as</span> <span class="n">fp64</span></code>)
may cause verification timeouts due to Z3s difficulty combining quantifiers and floats.</li>
</ul>

<p>To avoid this limitation, use direct literal conversions where possible.</p>

<h5 id="5239-inexact-conversion-methods">5.2.3.9. Inexact Conversion Methods</h5>

<p>In addition to the exact conversions using the <code class="language-dafny highlighter-rouge"><span class="ow">as</span></code> operator, both <code class="language-dafny highlighter-rouge"><span class="n">fp32</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">fp64</span></code> provide static methods
for conversions that may involve rounding or truncation:</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">FromReal</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">FromReal</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></code> - Converts a real value to the target type with rounding. Values outside the
representable range become infinity. No preconditions.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="n">fp32</span><span class="o">.</span><span class="n">ToInt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> / <code class="language-dafny highlighter-rouge"><span class="n">fp64</span><span class="o">.</span><span class="n">ToInt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> - Converts a floating-point value to unbounded int by truncating towards zero (like C cast).
Requires x to be finite (not NaN or infinity). This precondition is inspired by IEEE 754 which specifies
that implementations shall signal invalid operation for NaN/infinity to integer conversions.</p>
  </li>
</ul>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">InexactConversions</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// FromReal allows any real value and rounds as needed</span>
  <span class="kr">var</span> <span class="n">r1</span><span class="o">:</span> <span class="kt">real</span> <span class="o">:=</span> <span class="mf">0.1</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">f1</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">FromReal</span><span class="p">(</span><span class="n">r1</span><span class="p">);</span>  <span class="c1">// OK: rounds to nearest representable value</span>

  <span class="c1">// Verification times out here</span>
  <span class="c1">// var huge: real := 1e400;</span>
  <span class="c1">// var f2 := fp64.FromReal(huge);  // Becomes positive infinity</span>
  <span class="c1">// assert f2 == fp64.PositiveInfinity;</span>

  <span class="c1">// ToInt truncates towards zero (Round Toward Zero - RTZ)</span>
  <span class="kr">var</span> <span class="n">f3</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mf">3.75</span><span class="p">;</span>  <span class="c1">// Exactly representable</span>
  <span class="kr">var</span> <span class="n">i1</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">ToInt</span><span class="p">(</span><span class="n">f3</span><span class="p">);</span>  <span class="c1">// Returns 3</span>
  <span class="kr">assert</span> <span class="n">i1</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>

  <span class="kr">var</span> <span class="n">f4</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="o">-</span><span class="mf">3.75</span><span class="p">;</span>  <span class="c1">// Exactly representable</span>
  <span class="kr">var</span> <span class="n">i2</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">ToInt</span><span class="p">(</span><span class="n">f4</span><span class="p">);</span>  <span class="c1">// Returns -3 (truncates toward zero, not -4)</span>
  <span class="kr">assert</span> <span class="n">i2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This method demonstrates the precondition check</span>
<span class="kr">method</span> <span class="n">ToIntWellformednessExamples</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">finite</span><span class="o">:</span> <span class="n">fp64</span> <span class="o">:=</span> <span class="mf">42.5</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">fp64</span><span class="o">.</span><span class="n">ToInt</span><span class="p">(</span><span class="n">finite</span><span class="p">);</span>  <span class="c1">// OK: finite value</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">42</span><span class="p">;</span>

  <span class="c1">// The following would fail verification:</span>
  <span class="c1">// var inf := fp64.PositiveInfinity;</span>
  <span class="c1">// var i_inf := fp64.ToInt(inf);  // Error: requires finite argument</span>

  <span class="c1">// var nan := fp64.NaN;</span>
  <span class="c1">// var i_nan := fp64.ToInt(nan);  // Error: requires finite argument</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="52310-comparison-of-numeric-types">5.2.3.10. Comparison of Numeric Types</h5>

<table>
  <thead>
    <tr>
      <th>Aspect</th>
      <th>int</th>
      <th>real</th>
      <th>fp64</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Numeric kind</td>
      <td>integer-based</td>
      <td>real-based</td>
      <td>real-based</td>
    </tr>
    <tr>
      <td>Precision</td>
      <td>Unlimited</td>
      <td>Exact</td>
      <td>~15-17 decimal digits</td>
    </tr>
    <tr>
      <td>Special values</td>
      <td>None</td>
      <td>None</td>
      <td>NaN, </td>
    </tr>
    <tr>
      <td>Modulus operator</td>
      <td>Yes</td>
      <td>No</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Hardware mapping</td>
      <td>BigInteger</td>
      <td>BigRational</td>
      <td>IEEE 754 binary64</td>
    </tr>
  </tbody>
</table>

<h4 id="sec-bit-vector-types">5.2.4. Bit-vector Types (<a href="#g-basic-type">grammar</a>)</h4>

<p>Dafny includes a family of bit-vector types, each type having a specific,
constant length, the number of bits in its values.
Each such type is
distinct and is designated by the prefix <code class="language-dafny highlighter-rouge"><span class="n">bv</span></code> followed (without white space) by
a positive integer without leading zeros or zero, stating the number of bits. For example,
<code class="language-dafny highlighter-rouge"><span class="kt">bv1</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">bv8</span></code>, and <code class="language-dafny highlighter-rouge"><span class="kt">bv32</span></code> are legal bit-vector type names.
The type <code class="language-dafny highlighter-rouge"><span class="kt">bv0</span></code> is also legal; it is a bit-vector type with no bits and just one value, <code class="language-dafny highlighter-rouge"><span class="mh">0x0</span></code>.</p>

<p>Constant literals of bit-vector types are given by integer literals converted automatically
to the designated type, either by an implicit or explicit conversion operation or by initialization in a declaration.
Dafny checks that the constant literal is in the correct range. For example,
<!-- %check-resolve Types.1.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">i</span><span class="o">:</span> <span class="kt">bv1</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="kr">const</span> <span class="n">j</span><span class="o">:</span> <span class="kt">bv8</span> <span class="o">:=</span> <span class="mi">195</span>
<span class="kr">const</span> <span class="n">k</span><span class="o">:</span> <span class="kt">bv2</span> <span class="o">:=</span> <span class="mi">5</span> <span class="c1">// error - out of range</span>
<span class="kr">const</span> <span class="n">m</span> <span class="o">:=</span> <span class="p">(</span><span class="mi">194</span> <span class="ow">as</span> <span class="kt">bv8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">7</span> <span class="ow">as</span> <span class="kt">bv8</span><span class="p">)</span>
</code></pre></div></div>

<p>Bit-vector values can be converted to and from <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> and other bit-vector types, as long as
the values are in range for the target type. Bit-vector values are always considered unsigned.</p>

<p>Bit-vector operations include bit-wise operators and arithmetic operators
(as well as equality, disequality, and comparisons).
The arithmetic operations
truncate the high-order bits from the results; that is, they perform
unsigned arithmetic modulo 2^{number of bits}, like 2s-complement machine arithmetic.</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th style="text-align: center">precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;&lt;</span></code></td>
      <td style="text-align: center">5</td>
      <td>bit-limited bit-shift left</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;&gt;</span></code></td>
      <td style="text-align: center">5</td>
      <td>unsigned bit-shift right</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">+</span></code></td>
      <td style="text-align: center">6</td>
      <td>bit-limited addition</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">-</span></code></td>
      <td style="text-align: center">6</td>
      <td>bit-limited subtraction</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">*</span></code></td>
      <td style="text-align: center">7</td>
      <td>bit-limited multiplication</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&amp;</span></code></td>
      <td style="text-align: center">8</td>
      <td>bit-wise and</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">|</span></code></td>
      <td style="text-align: center">8</td>
      <td>bit-wise or</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">^</span></code></td>
      <td style="text-align: center">8</td>
      <td>bit-wise exclusive-or</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">-</span></code></td>
      <td style="text-align: center">10</td>
      <td>bit-limited negation (unary minus)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!</span></code></td>
      <td style="text-align: center">10</td>
      <td>bit-wise complement</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>.RotateLeft(n)</td>
      <td style="text-align: center">11</td>
      <td>rotates bits left by n bit positions</td>
    </tr>
    <tr>
      <td>.RotateRight(n)</td>
      <td style="text-align: center">11</td>
      <td>rotates bits right by n bit positions</td>
    </tr>
  </tbody>
</table>

<p>The groups of operators lower in the table above bind more tightly.<sup id="fnref:binding" role="doc-noteref"><a href="#fn:binding" class="footnote" rel="footnote">1</a></sup>
All operators bind more tightly than equality, disequality, and comparisons.
All binary operators are left-associative, but the
bit-wise <code class="language-dafny highlighter-rouge"><span class="o">&amp;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">|</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">^</span></code> do not associate together (parentheses are required to disambiguate).
The <code class="language-dafny highlighter-rouge"><span class="o">+</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">|</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">^</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">&amp;</span></code> operators are commutative.</p>

<p>The right-hand operand of bit-shift operations is an <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> value,
must be non-negative, and
no more than the number of bits in the type.
There is no signed right shift as all bit-vector values correspond to
non-negative integers.</p>

<p>Bit-vector negation returns an unsigned value in the correct range for the type.
It has the properties <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span></code> and <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="o">-</span><span class="n">x</span></code>, for a bitvector value <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>
of at least one bit.</p>

<p>The argument of the <code class="language-dafny highlighter-rouge"><span class="n">RotateLeft</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">RotateRight</span></code> operations is a
non-negative <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> that is no larger than the bit-width of the value being rotated.
<code class="language-dafny highlighter-rouge"><span class="n">RotateLeft</span></code> moves bits to higher bit positions (e.g., <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="mi">2</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">)</span><span class="o">.</span><span class="n">RotateLeft</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">)</span></code>
and <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="mi">8</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">)</span><span class="o">.</span><span class="n">RotateLeft</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">)</span></code>);
<code class="language-dafny highlighter-rouge"><span class="n">RotateRight</span></code> moves bits to lower bit positions, so <code class="language-dafny highlighter-rouge"><span class="n">b</span><span class="o">.</span><span class="n">RotateLeft</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">RotateRight</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span></code>.</p>

<p>Here are examples of the various operations (all the assertions are true except where indicated):
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">i</span><span class="o">:</span> <span class="kt">bv4</span> <span class="o">:=</span> <span class="mi">9</span>
<span class="kr">const</span> <span class="n">j</span><span class="o">:</span> <span class="kt">bv4</span> <span class="o">:=</span> <span class="mi">3</span>

<span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">i</span> <span class="o">|</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">11</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">i</span> <span class="o">^</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="o">!</span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="mi">6</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="o">-</span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="mi">7</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">11</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">i</span> <span class="ow">as</span> <span class="kt">int</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">j</span> <span class="ow">as</span> <span class="kt">int</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">6</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span> <span class="ow">as</span> <span class="kt">bv4</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">9</span><span class="p">;</span> <span class="c1">// auto conversion of literal to bv4</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">==</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span> <span class="c1">// arithmetic is modulo 16</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// + - bind tigher than &lt;&lt; &gt;&gt;</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// &amp; | ^ bind tighter than + - *</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The following are incorrectly formed:
<!-- %check-resolve Types.2.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">i</span><span class="o">:</span> <span class="kt">bv4</span> <span class="o">:=</span> <span class="mi">9</span>
<span class="kr">const</span> <span class="n">j</span><span class="o">:</span> <span class="kt">bv4</span> <span class="o">:=</span> <span class="mi">3</span>

<span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mi">4</span> <span class="o">|</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// parentheses required</span>
<span class="p">}</span>
</code></pre></div></div>
<!-- %check-resolve Types.3.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">k</span><span class="o">:</span> <span class="kt">bv4</span> <span class="o">:=</span> <span class="mi">9</span>

<span class="kr">method</span> <span class="n">p</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">k</span> <span class="ow">as</span> <span class="kt">bv5</span> <span class="o">==</span> <span class="mi">9</span> <span class="ow">as</span> <span class="kt">bv6</span><span class="p">;</span> <span class="c1">// error: mismatched types</span>
<span class="p">}</span>
</code></pre></div></div>
<p>These produce assertion errors:
<!-- %check-verify Types.4.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">i</span><span class="o">:</span> <span class="kt">bv4</span> <span class="o">:=</span> <span class="mi">9</span>

<span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="ow">as</span> <span class="kt">bv3</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// error: i is out of range for bv3</span>
<span class="p">}</span>
</code></pre></div></div>
<!-- %check-resolve Types.5.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">j</span><span class="o">:</span> <span class="kt">bv4</span> <span class="o">:=</span> <span class="mi">9</span>

<span class="kr">method</span> <span class="n">n</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">25</span><span class="p">;</span> <span class="c1">// error: 25 is out of range for bv4</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Bit-vector constants (like all constants) can be initialized using expressions, but pay attention
to how type inference applies to such expressions. For example,
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">a</span><span class="o">:</span> <span class="kt">bv3</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>
<p>is legal because Dafny interprets <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="mi">1</span></code> as a <code class="language-dafny highlighter-rouge"><span class="kt">bv3</span></code> expression, because <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> has type <code class="language-dafny highlighter-rouge"><span class="kt">bv3</span></code>.
Consequently the <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> is <code class="language-dafny highlighter-rouge"><span class="kt">bv3</span></code> negation and the <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> is a <code class="language-dafny highlighter-rouge"><span class="kt">bv3</span></code> literal; the value of the expression <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="mi">1</span></code> is
the <code class="language-dafny highlighter-rouge"><span class="kt">bv3</span></code> value <code class="language-dafny highlighter-rouge"><span class="mi">7</span></code>, which is then the value of <code class="language-dafny highlighter-rouge"><span class="n">a</span></code>.</p>

<p>On the other hand,
<!-- %check-resolve Types.6.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">b</span><span class="o">:</span> <span class="kt">bv3</span> <span class="o">:=</span> <span class="mi">6</span> <span class="o">&amp;</span> <span class="mi">11</span>
</code></pre></div></div>
<p>is illegal because, again, the <code class="language-dafny highlighter-rouge"><span class="o">&amp;</span></code> is <code class="language-dafny highlighter-rouge"><span class="kt">bv3</span></code> bit-wise-and and the numbers must be valid <code class="language-dafny highlighter-rouge"><span class="kt">bv3</span></code> literals.
But <code class="language-dafny highlighter-rouge"><span class="mi">11</span></code> is not a valid <code class="language-dafny highlighter-rouge"><span class="kt">bv3</span></code> literal.</p>

<h4 id="sec-ordinals">5.2.5. Ordinal type (<a href="#g-basic-type">grammar</a>)</h4>

<p>Values of type <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code> behave like <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code>s in many ways, with one important difference:
there are <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code> values that are larger than any <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code>. The smallest of these non-nat ordinals is
represented as $\omega$ in mathematics, though there is no literal expression in Dafny that represents this value.</p>

<p>The natural numbers are ordinals.
Any ordinal has a successor ordinal (equivalent to adding <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code>).
Some ordinals are <em>limit</em> ordinals, meaning they are not a successor of any other ordinal;
the natural number <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> and  $\omega$ are limit ordinals.</p>

<p>The <em>offset</em> of an ordinal is the number of successor operations it takes to reach it from a limit ordinal.</p>

<p>The Dafny type <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code> has these member functions:</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">o</span><span class="o">.</span><span class="n">IsLimit</span></code>  true if <code class="language-dafny highlighter-rouge"><span class="n">o</span></code> is a limit ordinal (including <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code>)</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">o</span><span class="o">.</span><span class="n">IsSucc</span></code>  true if <code class="language-dafny highlighter-rouge"><span class="n">o</span></code> is a successor to something, so <code class="language-dafny highlighter-rouge"><span class="n">o</span><span class="o">.</span><span class="n">IsSucc</span> <span class="o">&lt;==&gt;</span> <span class="o">!</span><span class="n">o</span><span class="o">.</span><span class="n">IsLimit</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">o</span><span class="o">.</span><span class="n">IsNat</span></code>  true if <code class="language-dafny highlighter-rouge"><span class="n">o</span></code> represents a <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> value, so for <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> a <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code>, <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">n</span> <span class="ow">as</span> <span class="kt">ORDINAL</span><span class="p">)</span><span class="o">.</span><span class="n">IsNat</span></code> is true
and if <code class="language-dafny highlighter-rouge"><span class="n">o</span><span class="o">.</span><span class="n">IsNat</span></code> is true then <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">o</span> <span class="ow">as</span> <span class="kt">nat</span><span class="p">)</span></code> is well-defined</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">o</span><span class="o">.</span><span class="n">Offset</span></code>  is the <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> value giving the offset of the ordinal</li>
</ul>

<p>In addition,</p>
<ul>
  <li>non-negative numeric literals may be considered <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code> literals, so <code class="language-dafny highlighter-rouge"><span class="n">o</span> <span class="o">+</span> <span class="mi">1</span></code> is allowed</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code>s may be compared, using <code class="language-dafny highlighter-rouge"><span class="o">==</span> <span class="o">!=</span> <span class="o">&lt;</span> <span class="o">&lt;=</span> <span class="o">&gt;</span> <span class="o">&gt;=</span></code></li>
  <li>two <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code>s may be added and the result is <code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code> either one of them; addition is associative but not commutative</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">/</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">%</span></code> are not defined for <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code>s</li>
  <li>two <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code>s may be subtracted if the RHS satisfies <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">IsNat</span></code> and the offset of the LHS is not smaller than the offset of the RHS</li>
</ul>

<p>In Dafny, <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code>s are used primarily in conjunction with <a href="#sec-extreme">extreme functions and lemmas</a>.</p>

<h4 id="sec-characters">5.2.6. Characters (<a href="#g-basic-type">grammar</a>)</h4>

<p>Dafny supports a type <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> of <em>characters</em>.
Its exact meaning is controlled by the command-line switch <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span><span class="o">:</span><span class="kc">true</span><span class="o">|</span><span class="kc">false</span></code>.</p>

<p>If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span></code> is disabled, then <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> represents any <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16 code unit</a>.
This includes surrogate code points.</p>

<p>If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span></code> is enabled, then <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> represents any <a href="https://unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a>.
This excludes surrogate code points.</p>

<p>Character literals are enclosed in single quotes, as in <code class="language-dafny highlighter-rouge"><span class="sc">'D'</span></code>.
To write a single quote as a
character literal, it is necessary to use an <em>escape sequence</em>.
Escape sequences can also be used to write other characters.  The
supported escape sequences are the following:</p>

<table>
  <thead>
    <tr>
      <th>escape sequence</th>
      <th>meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="err">\'</span></code></td>
      <td>the character <code class="language-dafny highlighter-rouge"><span class="err">'</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="err">\"</span></code></td>
      <td>the character <code class="language-dafny highlighter-rouge"><span class="err">"</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="err">\\</span></code></td>
      <td>the character <code class="language-dafny highlighter-rouge"><span class="err">\</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="mi">0</span></code></td>
      <td>the null character, same as <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">u0000</span></code> or <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">U</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">n</span></code></td>
      <td>line feed</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">r</span></code></td>
      <td>carriage return</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">t</span></code></td>
      <td>horizontal tab</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">u</span></code><em>xxxx</em></td>
      <td><a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16 code unit</a> whose hexadecimal code is <em>xxxx</em>,  where each <em>x</em> is a hexadecimal digit</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">U</span><span class="p">{</span></code><em>x..x</em><code class="language-dafny highlighter-rouge"><span class="p">}</span></code></td>
      <td><a href="https://unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> whose hexadecimal code is <em>x..x</em>,  where each <em>x</em> is a hexadecimal digit</td>
    </tr>
  </tbody>
</table>

<p>The escape sequence for a double quote is redundant, because
<code class="language-dafny highlighter-rouge"><span class="sc">'"'</span></code> and <code class="language-dafny highlighter-rouge"><span class="sc">'\"'</span></code> denote the same
characterboth forms are provided in order to support the same
escape sequences in string literals (<a href="#sec-strings">Section 5.5.3.5</a>).</p>

<p>In the form <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">u</span></code><em>xxxx</em>, which is only allowed if <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span></code> is disabled,
the <code class="language-dafny highlighter-rouge"><span class="n">u</span></code> is always lower case, but the four
hexadecimal digits are case insensitive.</p>

<p>In the form <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">U</span><span class="p">{</span></code><em>x..x</em><code class="language-dafny highlighter-rouge"><span class="p">}</span></code>,
which is only allowed if <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span></code> is enabled,
the <code class="language-dafny highlighter-rouge"><span class="n">U</span></code> is always upper case,
but the hexadecimal digits are case insensitive, and there must
be at least one and at most six digits.
Surrogate code points are not allowed.
The hex digits may be interspersed with underscores for readability
(but not beginning or ending with an underscore), as in <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">U</span><span class="p">{</span><span class="err">1_F680</span><span class="p">}</span></code>.</p>

<p>Character values are ordered and can be compared using the standard
relational operators:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code></td>
      <td>less than</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code></td>
      <td>at most</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code></td>
      <td>at least</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code></td>
      <td>greater than</td>
    </tr>
  </tbody>
</table>

<p>Sequences of characters represent <em>strings</em>, as described in
<a href="#sec-strings">Section 5.5.3.5</a>.</p>

<p>Character values can be converted to and from <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> values using the
<code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="kt">int</span></code> and <code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="kt">char</span></code> conversion operations. The result is what would
be expected in other programming languages, namely, the <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> value of a
<code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> is the ASCII or Unicode numeric value.</p>

<p>The only other operations on characters are obtaining a character
by indexing into a string, and the implicit conversion to string
when used as a parameter of a <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statement.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-type-parameters">5.3. Type parameters (<a href="#g-type-parameter">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">G1</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kr">type</span> <span class="n">G2</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span>
<span class="kr">type</span> <span class="n">G3</span><span class="o">&lt;+</span><span class="n">T</span><span class="p">(</span><span class="o">==</span><span class="p">),</span><span class="o">-</span><span class="n">U</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Many of the types, functions, and methods in Dafny can be
parameterized by types.  These <em>type parameters</em> are
declared inside angle brackets and can stand for any type.</p>

<p>Dafny has some inference support that makes certain signatures less
cluttered (described in <a href="#sec-type-inference">Section 12.2</a>).</p>

<h4 id="sec-type-characteristics">5.3.1. Declaring restrictions on type parameters</h4>

<p>It is sometimes necessary to restrict type parameters so that
they can only be instantiated by certain families of types, that is,
by types that have certain properties. These properties are known as
<em>type characteristics</em>. The following subsections
describe the type characteristics that Dafny supports.</p>

<p>In some cases, type inference will infer that a type-parameter
must be restricted in a particular way, in which case Dafny
will add the appropriate suffix, such as <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">==</span><span class="p">)</span></code>, automatically.</p>

<p>If more than one restriction is needed, they are either
listed comma-separated,
inside the parentheses or as multiple parenthesized elements:
 <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="o">==</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="o">==</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span></code>.</p>

<p>When an actual type is substituted for a type parameter in a generic type instantiation,
the actual type must have the declared or inferred type characteristics of the type parameter.
These characteristics might also be inferred for the actual type. For example, a numeric-based
subset or newtype automatically has the <code class="language-dafny highlighter-rouge"><span class="o">==</span></code> relationship of its base type. Similarly,
type synonyms have the characteristics of the type they represent.</p>

<p>An abstract type has no known characteristics. If it is intended to be defined only as types
that have certain characteristics, then those characteristics must be declared.
For example,
<!-- %check-resolve Types.26.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="mi">00</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="kr">type</span> <span class="n">Q</span>
<span class="kr">const</span> <span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>will give an error because it is not known whether the type <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code> is non-empty (<code class="language-dafny highlighter-rouge"><span class="mi">00</span></code>).
Instead, one needs to write
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="mi">00</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="kr">type</span> <span class="n">Q</span><span class="p">(</span><span class="mi">00</span><span class="p">)</span>
<span class="kr">const</span> <span class="n">a</span><span class="o">:</span> <span class="n">A?</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="kc">null</span>
</code></pre></div></div>

<h5 id="sec-equality-supporting">5.3.1.1. Equality-supporting type parameters: <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="o">==</span><span class="p">)</span></code></h5>

<p>Designating a type parameter with the <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">==</span><span class="p">)</span></code> suffix indicates that
the parameter may only be replaced in non-ghost contexts
with types that are known to
support run-time equality comparisons (<code class="language-dafny highlighter-rouge"><span class="o">==</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">!=</span></code>).
All types support equality in ghost contexts,
as if, for some types, the equality function is ghost.</p>

<p>For example,
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Compare</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">eq</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span> <span class="n">eq</span> <span class="o">:=</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>is a method whose type parameter is restricted to equality-supporting
types when used in a non-ghost context.
Again, note that <em>all</em> types support equality in <em>ghost</em>
contexts; the difference is only for non-ghost (that is, compiled)
code.  Coinductive datatypes, arrow types, and inductive
datatypes with ghost parameters are examples of types that are not
equality supporting.</p>

<h5 id="sec-auto-init">5.3.1.2. Auto-initializable types: <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></code></h5>

<p>At every access of a variable <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> of a type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, Dafny ensures that
<code class="language-dafny highlighter-rouge"><span class="n">x</span></code> holds a legal value of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>.
If no explicit initialization is given, then an arbitrary value is
assumed by the verifier and supplied by the compiler,
that is, the variable is <em>auto-initialized</em>, but to an arbitrary value.
For example,
<!-- %check-verify Types.21.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">Example</span><span class="o">&lt;</span><span class="n">A</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">X</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">n</span><span class="o">:</span> <span class="kt">nat</span>
  <span class="kr">var</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">a</span><span class="o">:</span> <span class="n">A</span>
  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="n">X</span>

  <span class="kr">constructor</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kr">new</span><span class="p">;</span> <span class="c1">// error: field 'x' has not been given a value`</span>
    <span class="kr">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// true, regardless of the value of 'n'</span>
    <span class="kr">assert</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// possibly false, since an arbitrary 'int' may be negative</span>
    <span class="c1">// 'a' does not require an explicit initialization, since 'A' is auto-init</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In the example above, the class fields do not need to be explicitly initialized
in the constructor because they are auto-initialized to an arbitrary value.</p>

<p>Local variables and out-parameters are however, subject to definite assignment
rules. The following example requires <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">relax</span><span class="o">-</span><span class="n">definite</span><span class="o">-</span><span class="n">assignment</span></code>,
which is not the default.
<!-- %check-verify Types.7a.expect %options --relax-definite-assignment --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">;</span> <span class="c1">// Auto-initialized to an arbitrary value of type `nat`</span>
  <span class="kr">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// true, regardless of the value of n</span>
  <span class="kr">var</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// possibly false, arbitrary ints may be negative</span>
<span class="p">}</span>
</code></pre></div></div>
<p>With the default behavior of definite assignment, <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> need to be initialized
to an explicit value of their type or to an arbitrary value using, for example,
<code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">n</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">:=</span> <span class="o">*</span><span class="p">;</span></code>.</p>

<p>For some types (known as <em>auto-init types</em>), the compiler can choose an
initial value, but for others it does not.
Variables and fields whose type the compiler does not auto-initialize
are subject to <em>definite-assignment</em> rules. These ensure that the program
explicitly assigns a value to a variable before it is used.
For more details see <a href="#sec-definite-assignment">Section 12.6</a> and the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">relax</span><span class="o">-</span><span class="n">definite</span><span class="o">-</span><span class="n">assignment</span></code> command-line option.
More detail on auto-initializing is in <a href="../Compilation/AutoInitialization">this document</a>.</p>

<p>Dafny supports auto-init as a type characteristic.
To restrict a type parameter to auto-init types, mark it with the
<code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="mi">0</span><span class="p">)</span></code> suffix. For example,
<!-- %check-verify Types.7b.expect %options --relax-definite-assignment --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">AutoInitExamples</span><span class="o">&lt;</span><span class="n">A</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">X</span><span class="o">&gt;</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="o">:</span> <span class="n">X</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 'a' does not require an explicit initialization, since A is auto-init</span>
  <span class="c1">// error: out-parameter 'x' has not been given a value</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In this example, an error is reported because out-parameter <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> has not
been assignedsince nothing is known about type <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>, variables of
type <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> are subject to definite-assignment rules. In contrast, since
type parameter <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> is declared to be restricted to auto-init types,
the program does not need to explicitly assign any value to the
out-parameter <code class="language-dafny highlighter-rouge"><span class="n">a</span></code>.</p>

<h5 id="sec-nonempty-types">5.3.1.3. Nonempty types: <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="mi">00</span><span class="p">)</span></code></h5>

<p>Auto-init types are important in compiled contexts. In ghost contexts, it
may still be important to know that a type is nonempty. Dafny supports
a type characteristic for nonempty types, written with the suffix <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="mi">00</span><span class="p">)</span></code>.
For example, with <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">relax</span><span class="o">-</span><span class="n">definite</span><span class="o">-</span><span class="n">assignment</span></code>, the following example happens:</p>

<!-- %check-verify Types.8.expect %options --relax-definite-assignment -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">NonemptyExamples</span><span class="o">&lt;</span><span class="n">B</span><span class="p">(</span><span class="mi">00</span><span class="p">),</span> <span class="n">X</span><span class="o">&gt;</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="n">B</span><span class="p">,</span> <span class="kr">ghost</span> <span class="n">g</span><span class="o">:</span> <span class="n">B</span><span class="p">,</span> <span class="kr">ghost</span> <span class="n">h</span><span class="o">:</span> <span class="n">X</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// error: non-ghost out-parameter 'b' has not been given a value</span>
  <span class="c1">// ghost out-parameter 'g' is fine, since its type is nonempty</span>
  <span class="c1">// error: 'h' has not been given a value</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Because of <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>s nonempty type characteristic, ghost parameter <code class="language-dafny highlighter-rouge"><span class="n">g</span></code> does not
need to be explicitly assigned. However, Dafny reports an error for the
non-ghost <code class="language-dafny highlighter-rouge"><span class="n">b</span></code>, since <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> is not an auto-init type, and reports an error
for <code class="language-dafny highlighter-rouge"><span class="n">h</span></code>, since the type <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> could be empty.</p>

<p>Note that every auto-init type is nonempty.</p>

<p>In the default definite-assignment mode (that is, without <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">relax</span><span class="o">-</span><span class="n">definite</span><span class="o">-</span><span class="n">assignment</span></code>)
there will be errors for all three formal parameters in the example just given.</p>

<p>For more details see <a href="#sec-definite-assignment">Section 12.6</a>.</p>

<h5 id="sec-non-heap-based">5.3.1.4. Non-heap based: <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span></code></h5>

<p>Dafny makes a distinction between types whose values are on the heap,
i.e. references, like
classes and arrays, and those that are strictly value-based, like basic
types and datatypes.
The practical implication is that references depend on allocation state
(e.g., are affected by the <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> operation) whereas non-reference values
are not.
Thus it can be relevant to know whether the values of a type parameter
are heap-based or not. This is indicated by the mode suffix <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span></code>.</p>

<p>A type parameter characterized by <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span></code> is <em>recursively</em> independent
of the allocation state. For example, a datatype is not a reference, but for
a parameterized data type such as
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Failure</span><span class="p">(</span><span class="n">error</span><span class="o">:</span> <span class="kt">string</span><span class="p">)</span> <span class="o">|</span> <span class="n">Success</span><span class="p">(</span><span class="n">value</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span>
</code></pre></div></div>
<p>the instantiation <code class="language-dafny highlighter-rouge"><span class="n">Result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code> satisfies <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span></code>, whereas
<code class="language-dafny highlighter-rouge"><span class="n">Result</span><span class="o">&lt;</span><span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span></code> does not.</p>

<p>Note that this characteristic of a type parameter is operative for both
verification and compilation.
Also, abstract types at the topmost scope are always implicitly <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span></code>.</p>

<p>Here are some examples:
<!-- %check-resolve Types.9.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Failure</span><span class="p">(</span><span class="n">error</span><span class="o">:</span> <span class="kt">string</span><span class="p">)</span> <span class="o">|</span> <span class="n">Success</span><span class="p">(</span><span class="n">v</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span>
<span class="kr">datatype</span> <span class="n">ResultN</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Failure</span><span class="p">(</span><span class="n">error</span><span class="o">:</span> <span class="kt">string</span><span class="p">)</span> <span class="o">|</span> <span class="n">Success</span><span class="p">(</span><span class="n">v</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span>

<span class="kr">class</span> <span class="n">C</span> <span class="p">{}</span>

<span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">x1</span><span class="o">:</span> <span class="n">Result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">x2</span><span class="o">:</span> <span class="n">ResultN</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">x3</span><span class="o">:</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">x4</span><span class="o">:</span> <span class="n">ResultN</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// error</span>
  <span class="kr">var</span> <span class="n">x5</span><span class="o">:</span> <span class="n">Result</span><span class="o">&lt;</span><span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">x6</span><span class="o">:</span> <span class="n">ResultN</span><span class="o">&lt;</span><span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">;</span> <span class="c1">// error</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="sec-type-parameter-variance">5.3.2. Type parameter variance</h4>

<p>Type parameters have several different variance and cardinality properties.
These properties of type parameters are designated in a generic type definition.
For instance, in <code class="language-dafny highlighter-rouge"><span class="kr">type</span> <span class="n">A</span><span class="o">&lt;+</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">...</span> </code>, the <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> indicates that the <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> position
is co-variant. These properties are indicated by the following notation:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">notation</th>
      <th>variance</th>
      <th>cardinality-preserving</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">(nothing)</td>
      <td>non-variant</td>
      <td>yes</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="o">+</span></code></td>
      <td>co-variant</td>
      <td>yes</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="o">-</span></code></td>
      <td>contra-variant</td>
      <td>not necessarily</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="o">*</span></code></td>
      <td>co-variant</td>
      <td>not necessarily</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="o">!</span></code></td>
      <td>non-variant</td>
      <td>not necessarily</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><em>co-variance</em> (<code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;+</span><span class="n">T</span><span class="o">&gt;</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;*</span><span class="n">T</span><span class="o">&gt;</span></code>) means that if <code class="language-dafny highlighter-rouge"><span class="n">U</span></code> is a subtype of <code class="language-dafny highlighter-rouge"><span class="n">V</span></code> then <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span></code> is a subtype of <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span></code></li>
  <li><em>contra-variance</em> (<code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;-</span><span class="n">T</span><span class="o">&gt;</span></code>) means that if <code class="language-dafny highlighter-rouge"><span class="n">U</span></code> is a subtype of <code class="language-dafny highlighter-rouge"><span class="n">V</span></code> then <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span></code> is a subtype of <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span></code></li>
  <li><em>non-variance</em> (<code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;!</span><span class="n">T</span><span class="o">&gt;</span></code>)  means that if <code class="language-dafny highlighter-rouge"><span class="n">U</span></code> is a different type than <code class="language-dafny highlighter-rouge"><span class="n">V</span></code> then there is no subtyping relationship between <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span></code></li>
</ul>

<p><em>Cardinality preserving</em>
means that the cardinality of the type being defined never exceeds the cardinality of any of its type parameters.
For example <code class="language-dafny highlighter-rouge"><span class="kr">type</span> <span class="n">T</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-&gt;</span> <span class="kt">bool</span></code>
is illegal and returns the error message <code class="language-dafny highlighter-rouge"><span class="n">formal</span> <span class="kr">type</span> <span class="n">parameter</span> <span class="sc">'X'</span> <span class="ow">is</span> <span class="n">not</span> <span class="n">used</span> <span class="n">according</span> <span class="kr">to</span> <span class="n">its</span> <span class="n">variance</span> <span class="n">specification</span> <span class="p">(</span><span class="n">it</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">left</span> <span class="n">of</span> <span class="n">an</span> <span class="n">arrow</span><span class="p">)</span> <span class="p">(</span><span class="n">perhaps</span> <span class="n">try</span> <span class="n">declaring</span> <span class="sc">'X'</span> <span class="ow">as</span> <span class="err">'-X'</span> <span class="n">or</span> <span class="err">'!X'</span><span class="p">)</span></code>
The type <code class="language-dafny highlighter-rouge"><span class="n">X</span> <span class="o">-&gt;</span> <span class="kt">bool</span></code> has strictly more values than the type <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>.
This affects certain uses of the type, so Dafny requires the declaration of <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> to explicitly say so.
Marking the type parameter <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> with <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">!</span></code> announces that the cardinality of <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span></code> may by larger than that of <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>.
If you use <code class="language-dafny highlighter-rouge"><span class="o">-</span></code>, youre also declaring <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> to be contravariant in its type argument, and if you use <code class="language-dafny highlighter-rouge"><span class="o">!</span></code>, youre declaring that <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is non-variant in its type argument.</p>

<p>To fix it, we use the variance <code class="language-dafny highlighter-rouge"><span class="o">!</span></code>:</p>

<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">T</span><span class="o">&lt;!</span><span class="n">X</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
</code></pre></div></div>

<p>This states that <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> does not preserve the cardinality of <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>, meaning there could be strictly more values of type <code class="language-dafny highlighter-rouge"><span class="n">T</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span></code> than values of type <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> for any <code class="language-dafny highlighter-rouge"><span class="n">E</span></code>.</p>

<p>A more detailed explanation of these topics is <a href="http://leino.science/papers/krml280.html">here</a>.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-generic-instantiation">5.4. Generic Instantiation (<a href="#g-generic-instantiation">grammar</a>)</h3>

<p>A generic instantiation consists of a comma-separated list of 1 or more Types,
enclosed in angle brackets (<code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code> <code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code>),
providing actual types to be used in place of the type parameters of the
declaration of the generic type.
If there is no instantion for a generic type, type inference will try
to fill these in (cf. <a href="#sec-type-inference">Section 12.2</a>).</p>

<!--PDF NEWPAGE-->
<h3 id="sec-collection-types">5.5. Collection types</h3>

<p>Dafny offers several built-in collection types.</p>

<h4 id="sec-sets">5.5.1. Sets (<a href="#g-collection-type">grammar</a>)</h4>

<p>For any type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, each value of type <code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> is a finite set of
<code class="language-dafny highlighter-rouge"><span class="n">T</span></code> values.</p>

<p>Set membership is determined by equality in the type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>,
so <code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> can be used in a non-ghost context only if <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is
<a href="#sec-equality-supporting">equality supporting</a>.</p>

<p>For any type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, each value of type <code class="language-dafny highlighter-rouge"><span class="kt">iset</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> is a potentially infinite
set of <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> values.</p>

<p>A set can be formed using a <a href="#sec-set-display-expression"><em>set display</em> expression</a>, which is a
possibly empty, unordered, duplicate-insensitive list of expressions
enclosed in curly braces.  To illustrate,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{}</span>        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>        <span class="p">{</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">}</span>
</code></pre></div></div>
<p>are three examples of set displays. There is also a <em>set comprehension</em>
expression (with a binder, like in logical quantifications), described in
<a href="#sec-set-comprehension-expression">Section 9.31.5</a>.</p>

<p>In addition to equality and disequality, set types
support the following relational operations:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th>precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code></td>
      <td>4</td>
      <td>proper subset</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code></td>
      <td>4</td>
      <td>subset</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code></td>
      <td>4</td>
      <td>superset</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code></td>
      <td>4</td>
      <td>proper superset</td>
    </tr>
  </tbody>
</table>

<p>Like the arithmetic relational operators, these operators are
chaining.</p>

<p>Sets support the following binary operators, listed in order of
increasing binding power:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th style="text-align: center">precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!!</span></code></td>
      <td style="text-align: center">4</td>
      <td>disjointness</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">+</span></code></td>
      <td style="text-align: center">6</td>
      <td>set union</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">-</span></code></td>
      <td style="text-align: center">6</td>
      <td>set difference</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">*</span></code></td>
      <td style="text-align: center">7</td>
      <td>set intersection</td>
    </tr>
  </tbody>
</table>

<p>The associativity rules of <code class="language-dafny highlighter-rouge"><span class="o">+</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">-</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> are like those of the
arithmetic operators with the same names.  The expression <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">!!</span> <span class="n">B</span></code>,
whose binding power is the same as equality (but which neither
associates nor chains with equality), says that sets <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> have
no elements in common, that is, it is equivalent to
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <span class="o">==</span> <span class="p">{}</span>
</code></pre></div></div>
<p>However, the disjointness operator is chaining though in a slightly different way than other chaining operators:
 <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">!!</span> <span class="n">B</span> <span class="o">!!</span> <span class="n">C</span> <span class="o">!!</span> <span class="n">D</span></code> means that <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">D</span></code> are all mutually disjoint, that is
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <span class="o">==</span> <span class="p">{}</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span> <span class="o">==</span> <span class="p">{}</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span> <span class="o">*</span> <span class="n">D</span> <span class="o">==</span> <span class="p">{}</span>
</code></pre></div></div>

<p>In addition, for any set <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> or <code class="language-dafny highlighter-rouge"><span class="kt">iset</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> and any
expression <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, sets support the following operations:</p>

<table>
  <thead>
    <tr>
      <th>expression</th>
      <th style="text-align: center">precedence</th>
      <th style="text-align: center">result type</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="ow">in</span> <span class="n">s</span></code></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></td>
      <td>set membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="o">!</span><span class="ow">in</span> <span class="n">s</span></code></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></td>
      <td>set non-membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="n">s</span><span class="o">|</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code></td>
      <td>set cardinality (not for <code class="language-dafny highlighter-rouge"><span class="kt">iset</span></code>)</td>
    </tr>
  </tbody>
</table>

<p>The expression <code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="o">!</span><span class="ow">in</span> <span class="n">s</span></code> is a syntactic shorthand for <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="p">(</span><span class="n">e</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span></code>.</p>

<p>(No white space is permitted between <code class="language-dafny highlighter-rouge"><span class="o">!</span></code> and <code class="language-dafny highlighter-rouge"><span class="ow">in</span></code>, making <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="ow">in</span></code> effectively
the one example of a mixed-character-class token in Dafny.)</p>

<h4 id="sec-multisets">5.5.2. Multisets (<a href="#g-collection-type">grammar</a>)</h4>

<p>A <em>multiset</em> is similar to a set, but keeps track of the multiplicity
of each element, not just its presence or absence.  For any type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>,
each value of type <code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> is a map from <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> values to natural
numbers denoting each elements multiplicity.  Multisets in Dafny
are finite, that is, they contain a finite number of each of a finite
set of elements.  Stated differently, a multiset maps only a finite
number of elements to non-zero (finite) multiplicities.</p>

<p>Like sets, multiset membership is determined by equality in the type
<code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, so <code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> can be used in a non-ghost context only if <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>
is <a href="#sec-equality-supporting">equality supporting</a>.</p>

<p>A multiset can be formed using a <em>multiset display</em> expression, which
is a possibly empty, unordered list of expressions enclosed in curly
braces after the keyword <code class="language-dafny highlighter-rouge"><span class="kt">multiset</span></code>.  To illustrate,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">multiset</span><span class="p">{}</span>   <span class="kt">multiset</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>   <span class="kt">multiset</span><span class="p">{</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">}</span>
</code></pre></div></div>
<p>are three examples of multiset displays.  There is no multiset
comprehension expression.</p>

<p>In addition to equality and disequality, multiset types
support the following relational operations:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th>precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code></td>
      <td>4</td>
      <td>proper multiset subset</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code></td>
      <td>4</td>
      <td>multiset subset</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code></td>
      <td>4</td>
      <td>multiset superset</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code></td>
      <td>4</td>
      <td>proper multiset superset</td>
    </tr>
  </tbody>
</table>

<p>Like the arithmetic relational operators, these operators are
chaining.</p>

<p>Multisets support the following binary operators, listed in order of
increasing binding power:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th style="text-align: center">precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!!</span></code></td>
      <td style="text-align: center">4</td>
      <td>multiset disjointness</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">+</span></code></td>
      <td style="text-align: center">6</td>
      <td>multiset sum</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">-</span></code></td>
      <td style="text-align: center">6</td>
      <td>multiset difference</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">*</span></code></td>
      <td style="text-align: center">7</td>
      <td>multiset intersection</td>
    </tr>
  </tbody>
</table>

<p>The associativity rules of <code class="language-dafny highlighter-rouge"><span class="o">+</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">-</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> are like those of the
arithmetic operators with the same names. The <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> operator
adds the multiplicity of corresponding elements, the <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> operator
subtracts them (but 0 is the minimum multiplicity),
and the <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> has multiplicity that is the minimum of the
multiplicity of the operands. There is no operator for multiset
union, which would compute the maximum of the multiplicities of the operands.</p>

<p>The expression <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">!!</span> <span class="n">B</span></code>
says that multisets <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> have no elements in common, that is,
it is equivalent to
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <span class="o">==</span> <span class="kt">multiset</span><span class="p">{}</span>
</code></pre></div></div>
<p>Like the analogous set operator, <code class="language-dafny highlighter-rouge"><span class="o">!!</span></code> is chaining and means mutual disjointness.</p>

<p>In addition, for any multiset <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>,
expression <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, and non-negative integer-based numeric
<code class="language-dafny highlighter-rouge"><span class="n">n</span></code>, multisets support the following operations:</p>

<table>
  <thead>
    <tr>
      <th>expression</th>
      <th style="text-align: center">precedence</th>
      <th style="text-align: center">result type</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="ow">in</span> <span class="n">s</span></code></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></td>
      <td>multiset membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="o">!</span><span class="ow">in</span> <span class="n">s</span></code></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></td>
      <td>multiset non-membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="n">s</span><span class="o">|</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code></td>
      <td>multiset cardinality</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">e</span><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code></td>
      <td>multiplicity of <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> in <code class="language-dafny highlighter-rouge"><span class="n">s</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">e</span> <span class="o">:=</span> <span class="n">n</span><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td>multiset update (change of multiplicity)</td>
    </tr>
  </tbody>
</table>

<p>The expression <code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="ow">in</span> <span class="n">s</span></code> returns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> if and only if <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span></code>.
The expression <code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="o">!</span><span class="ow">in</span> <span class="n">s</span></code> is a syntactic shorthand for <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="p">(</span><span class="n">e</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span></code>.
The expression <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">e</span> <span class="o">:=</span> <span class="n">n</span><span class="p">]</span></code> denotes a multiset like
<code class="language-dafny highlighter-rouge"><span class="n">s</span></code>, but where the multiplicity of element <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> is <code class="language-dafny highlighter-rouge"><span class="n">n</span></code>.  Note that
the multiset update <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">e</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">]</span></code> results in a multiset like <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> but
without any occurrences of <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> (whether or not <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> has occurrences of
<code class="language-dafny highlighter-rouge"><span class="n">e</span></code> in the first place).  As another example, note that
<code class="language-dafny highlighter-rouge"><span class="n">s</span> <span class="o">-</span> <span class="kt">multiset</span><span class="p">{</span><span class="n">e</span><span class="p">}</span></code> is equivalent to:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">s</span> <span class="kr">then</span> <span class="n">s</span><span class="p">[</span><span class="n">e</span> <span class="o">:=</span> <span class="n">s</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="kr">else</span> <span class="n">s</span>
</code></pre></div></div>

<h4 id="sec-sequences">5.5.3. Sequences (<a href="#g-collection-type">grammar</a>)</h4>

<p>For any type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, a value of type <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> denotes a <em>sequence</em> of <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>
elements, that is, a mapping from a finite downward-closed set of natural
numbers (called <em>indices</em>) to <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> values.</p>

<h5 id="sec-sequence-displays">5.5.3.1. Sequence Displays</h5>
<p>A sequence can be formed using a <em>sequence display</em> expression, which
is a possibly empty, ordered list of expressions enclosed in square
brackets.  To illustrate,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">[]</span>        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>        <span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">5</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">]</span>
</code></pre></div></div>
<p>are three examples of sequence displays.</p>

<p>There is also a sequence
comprehension expression (<a href="#sec-seq-comprehension">Section 9.28</a>):
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">seq</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">i</span> <span class="o">=&gt;</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>
<p>is equivalent to <code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span></code>.</p>

<h5 id="5532-sequence-relational-operators">5.5.3.2. Sequence Relational Operators</h5>
<p>In addition to equality and disequality, sequence types
support the following relational operations:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th>precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&lt;</td>
      <td>4</td>
      <td>proper prefix</td>
    </tr>
    <tr>
      <td>&lt;=</td>
      <td>4</td>
      <td>prefix</td>
    </tr>
  </tbody>
</table>

<p>Like the arithmetic relational operators, these operators are
chaining.  Note the absence of <code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code>.</p>

<h5 id="5533-sequence-concatenation">5.5.3.3. Sequence Concatenation</h5>
<p>Sequences support the following binary operator:</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th>precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">+</span></code></td>
      <td>6</td>
      <td>concatenation</td>
    </tr>
  </tbody>
</table>

<p>Operator <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> is associative, like the arithmetic operator with the
same name.</p>

<h5 id="sec-other-sequence-expressions">5.5.3.4. Other Sequence Expressions</h5>
<p>In addition, for any sequence <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>, expression <code class="language-dafny highlighter-rouge"><span class="n">e</span></code>
of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, integer-based numeric index <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> satisfying <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span></code>, and
integer-based numeric bounds <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> satisfying
<code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span> <span class="o">&lt;=</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span></code>, noting that bounds can equal the length of the sequence,
sequences support the following operations:</p>

<table>
  <thead>
    <tr>
      <th>expression</th>
      <th style="text-align: center">precedence</th>
      <th style="text-align: center">result type</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="ow">in</span> <span class="n">s</span></code></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></td>
      <td>sequence membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="o">!</span><span class="ow">in</span> <span class="n">s</span></code></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></td>
      <td>sequence non-membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="n">s</span><span class="o">|</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code></td>
      <td>sequence length</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="n">T</span></code></td>
      <td>sequence selection</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">:=</span> <span class="n">e</span><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td>sequence update</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td>subsequence</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td>drop</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td>take</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span></code><em>slices</em><code class="language-dafny highlighter-rouge"><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span></code></td>
      <td>slice</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td>sequence conversion to a <code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
    </tr>
  </tbody>
</table>

<p>Expression <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">:=</span> <span class="n">e</span><span class="p">]</span></code> returns a sequence like <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>, except that the
element at index <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> is <code class="language-dafny highlighter-rouge"><span class="n">e</span></code>.  The expression <code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="ow">in</span> <span class="n">s</span></code> says there
exists an index <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> such that <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span></code>.  It is allowed in non-ghost
contexts only if the element type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is
<a href="#sec-equality-supporting">equality supporting</a>.
The expression <code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="o">!</span><span class="ow">in</span> <span class="n">s</span></code> is a syntactic shorthand for <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="p">(</span><span class="n">e</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span></code>.</p>

<p>Expression <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span></code> yields a sequence formed by taking the first
<code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> elements and then dropping the first <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> elements.  The
resulting sequence thus has length <code class="language-dafny highlighter-rouge"><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span></code>.  Note that <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..|</span><span class="n">s</span><span class="o">|</span><span class="p">]</span></code>
equals <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>.  If the upper bound is omitted, it
defaults to <code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="n">s</span><span class="o">|</span></code>, so <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="p">]</span></code> yields the sequence formed by dropping
the first <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> elements of <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>.  If the lower bound is omitted, it
defaults to <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code>, so <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span></code> yields the sequence formed by taking the
first <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> elements of <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>.</p>

<p>In the sequence slice operation, <em>slices</em> is a nonempty list of
length designators separated and optionally terminated by a colon, and
there is at least one colon.  Each length designator is a non-negative
integer-based numeric; the sum of the length designators is no greater than <code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="n">s</span><span class="o">|</span></code>.  If there
are <em>k</em> colons, the operation produces <em>k + 1</em> consecutive subsequences
from <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>, with the length of each indicated by the corresponding length
designator, and returns these as a sequence of
sequences.
If <em>slices</em> is terminated by a
colon, then the length of the last slice extends until the end of <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>,
that is, its length is <code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="n">s</span><span class="o">|</span></code> minus the sum of the given length
designators.  For example, the following equalities hold, for any
sequence <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> of length at least <code class="language-dafny highlighter-rouge"><span class="mi">10</span></code>:
<!-- %check-verify %options --allow-axioms --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">t</span> <span class="o">:=</span> <span class="p">[</span><span class="mf">3.14</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="mf">1.41</span><span class="p">,</span> <span class="mf">1985.44</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">37.2</span><span class="p">][</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>
  <span class="kr">assert</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mf">3.14</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">[];</span>
  <span class="kr">assert</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mf">2.7</span><span class="p">,</span> <span class="mf">1.41</span><span class="p">,</span> <span class="mf">1985.44</span><span class="p">];</span>
  <span class="kr">var</span> <span class="n">u</span> <span class="o">:=</span> <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">][</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="p">];</span>
  <span class="kr">assert</span> <span class="o">|</span><span class="n">u</span><span class="o">|</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
  <span class="kr">assume</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="o">:</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="mi">10</span><span class="p">];</span>
  <span class="kr">assert</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="o">:</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="o">..</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The operation <code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></code> yields the multiset of elements of
sequence <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>.  It is allowed in non-ghost contexts only if the element
type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is <a href="#sec-equality-supporting">equality supporting</a>.</p>

<h5 id="sec-strings">5.5.3.5. Strings (<a href="#g-collection-type">grammar</a>)</h5>

<p>A special case of a sequence type is <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span></code>, for which Dafny
provides a synonym: <code class="language-dafny highlighter-rouge"><span class="kt">string</span></code>.  Strings are like other sequences, but
provide additional syntax for sequence display expressions, namely
<em>string literals</em>.  There are two forms of the syntax for string
literals:  the <em>standard form</em> and the <em>verbatim form</em>.</p>

<p>String literals of the standard form are enclosed in double quotes, as
in <code class="language-dafny highlighter-rouge"><span class="s2">"Dafny"</span></code>.  To include a double quote in such a string literal,
it is necessary to use an escape sequence.  Escape sequences can also
be used to include other characters.  The supported escape sequences
are the same as those for character literals (<a href="#sec-characters">Section 5.2.6</a>).
For example, the Dafny expression <code class="language-dafny highlighter-rouge"><span class="s2">"say \"yes\""</span></code> represents the
string <code class="language-dafny highlighter-rouge"><span class="err">'say "yes"'</span></code>.
The escape sequence for a single quote is redundant, because
<code class="language-dafny highlighter-rouge"><span class="s2">"\'"</span></code> and <code class="language-dafny highlighter-rouge"><span class="s2">"\'"</span></code> denote the same
stringboth forms are provided in order to support the same
escape sequences as do character literals.</p>

<p>String literals of the verbatim form are bracketed by
<code class="language-dafny highlighter-rouge"><span class="err">@"</span></code> and <code class="language-dafny highlighter-rouge"><span class="err">"</span></code>, as in <code class="language-dafny highlighter-rouge"><span class="sx">@"Dafny"</span></code>.  To include
a double quote in such a string literal, it is necessary to use the
escape sequence <code class="language-dafny highlighter-rouge"><span class="s2">""</span></code>, that is, to write the character
twice.  In the verbatim form, there are no other escape sequences.
Even characters like newline can be written inside the string literal
(hence spanning more than one line in the program text).</p>

<p>For example, the following three expressions denote the same string:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="s2">"C:\\tmp.txt"</span>
<span class="sx">@"C:\tmp.txt"</span>
<span class="p">[</span><span class="sc">'C'</span><span class="p">,</span> <span class="sc">':'</span><span class="p">,</span> <span class="sc">'\\'</span><span class="p">,</span> <span class="sc">'t'</span><span class="p">,</span> <span class="sc">'m'</span><span class="p">,</span> <span class="sc">'p'</span><span class="p">,</span> <span class="sc">'.'</span><span class="p">,</span> <span class="sc">'t'</span><span class="p">,</span> <span class="sc">'x'</span><span class="p">,</span> <span class="sc">'t'</span><span class="p">]</span>
</code></pre></div></div>

<p>Since strings are sequences, the relational operators <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code>
and <code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code> are defined on them.  Note, however, that these operators
still denote proper prefix and prefix, respectively, not some kind of
alphabetic comparison as might be desirable, for example, when
sorting strings.</p>

<h4 id="sec-maps">5.5.4. Finite and Infinite Maps (<a href="#g-collection-type">grammar</a>)</h4>

<p>For any types <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">U</span></code>, a value of type <code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code> denotes a
<em>(finite) map</em>
from <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">U</span></code>.  In other words, it is a look-up table indexed by
<code class="language-dafny highlighter-rouge"><span class="n">T</span></code>.  The <em>domain</em> of the map is a finite set of <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> values that have
associated <code class="language-dafny highlighter-rouge"><span class="n">U</span></code> values.  Since the keys in the domain are compared
using equality in the type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, type <code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code> can be used in a
non-ghost context only if <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is
<a href="#sec-equality-supporting">equality supporting</a>.</p>

<p>Similarly, for any types <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">U</span></code>, a value of type <code class="language-dafny highlighter-rouge"><span class="kt">imap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code>
denotes a <em>(possibly) infinite map</em>.  In most regards, <code class="language-dafny highlighter-rouge"><span class="kt">imap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code> is
like <code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code>, but a map of type <code class="language-dafny highlighter-rouge"><span class="kt">imap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code> is allowed to have an
infinite domain.</p>

<p>A map can be formed using a <em>map display</em> expression (see <a href="#sec-map-display-expression">Section 9.30</a>),
which is a possibly empty, ordered list of <em>maplets</em>, each maplet having the
form <code class="language-dafny highlighter-rouge"><span class="n">t</span> <span class="o">:=</span> <span class="n">u</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">t</span></code> is an expression of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">u</span></code> is an
expression of type <code class="language-dafny highlighter-rouge"><span class="n">U</span></code>, enclosed in square brackets after the keyword
<code class="language-dafny highlighter-rouge"><span class="kt">map</span></code>.  To illustrate,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">map</span><span class="p">[]</span>
<span class="kt">map</span><span class="p">[</span><span class="mi">20</span> <span class="o">:=</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">3</span> <span class="o">:=</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">20</span> <span class="o">:=</span> <span class="kc">false</span><span class="p">]</span>
<span class="kt">map</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">:=</span> <span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">]</span>
</code></pre></div></div>
<p>are three examples of map displays.  By using the keyword <code class="language-dafny highlighter-rouge"><span class="kt">imap</span></code>
instead of <code class="language-dafny highlighter-rouge"><span class="kt">map</span></code>, the map produced will be of type <code class="language-dafny highlighter-rouge"><span class="kt">imap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code>
instead of <code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code>.  Note that an infinite map (<code class="language-dafny highlighter-rouge"><span class="kt">imap</span></code>) is allowed
to have a finite domain, whereas a finite map (<code class="language-dafny highlighter-rouge"><span class="kt">map</span></code>) is not allowed
to have an infinite domain.
If the same key occurs more than
once in a map display expression, only the last occurrence appears in the resulting
map.<sup id="fnref:fn-map-display" role="doc-noteref"><a href="#fn:fn-map-display" class="footnote" rel="footnote">2</a></sup>  There is also a <em>map comprehension expression</em>,
explained in <a href="#sec-map-comprehension-expression">Section 9.31.8</a>.</p>

<p>For any map <code class="language-dafny highlighter-rouge"><span class="n">fm</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code>,
any map <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code> or <code class="language-dafny highlighter-rouge"><span class="kt">imap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code>,
any expression <code class="language-dafny highlighter-rouge"><span class="n">t</span></code> of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>,
any expression <code class="language-dafny highlighter-rouge"><span class="n">u</span></code> of type <code class="language-dafny highlighter-rouge"><span class="n">U</span></code>, and any <code class="language-dafny highlighter-rouge"><span class="n">d</span></code> in the domain of <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> (that
is, satisfying <code class="language-dafny highlighter-rouge"><span class="n">d</span> <span class="ow">in</span> <span class="n">m</span></code>), maps support the following operations:</p>

<table>
  <thead>
    <tr>
      <th>expression</th>
      <th style="text-align: center">precedence</th>
      <th style="text-align: center">result type</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">t</span> <span class="ow">in</span> <span class="n">m</span></code></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></td>
      <td>map domain membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">t</span> <span class="o">!</span><span class="ow">in</span> <span class="n">m</span></code></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></td>
      <td>map domain non-membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="n">fm</span><span class="o">|</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code></td>
      <td>map cardinality</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="p">[</span><span class="n">d</span><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="n">U</span></code></td>
      <td>map selection</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="p">[</span><span class="n">t</span> <span class="o">:=</span> <span class="n">u</span><span class="p">]</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center"><code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code></td>
      <td>map update</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Keys</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center">(i)<code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td>the domain of <code class="language-dafny highlighter-rouge"><span class="n">m</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Values</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center">(i)<code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span></code></td>
      <td>the range of <code class="language-dafny highlighter-rouge"><span class="n">m</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Items</span></code></td>
      <td style="text-align: center">11</td>
      <td style="text-align: center">(i)<code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="p">)</span><span class="o">&gt;</span></code></td>
      <td>set of pairs (t,u) in <code class="language-dafny highlighter-rouge"><span class="n">m</span></code></td>
    </tr>
  </tbody>
</table>

<p><code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="n">fm</span><span class="o">|</span></code> denotes the number of mappings in <code class="language-dafny highlighter-rouge"><span class="n">fm</span></code>, that is, the
cardinality of the domain of <code class="language-dafny highlighter-rouge"><span class="n">fm</span></code>.  Note that the cardinality operator
is not supported for infinite maps.
Expression <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="p">[</span><span class="n">d</span><span class="p">]</span></code> returns the <code class="language-dafny highlighter-rouge"><span class="n">U</span></code> value that <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> associates with <code class="language-dafny highlighter-rouge"><span class="n">d</span></code>.
Expression <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="p">[</span><span class="n">t</span> <span class="o">:=</span> <span class="n">u</span><span class="p">]</span></code> is a map like <code class="language-dafny highlighter-rouge"><span class="n">m</span></code>, except that the
element at key <code class="language-dafny highlighter-rouge"><span class="n">t</span></code> is <code class="language-dafny highlighter-rouge"><span class="n">u</span></code>.  The expression <code class="language-dafny highlighter-rouge"><span class="n">t</span> <span class="ow">in</span> <span class="n">m</span></code> says <code class="language-dafny highlighter-rouge"><span class="n">t</span></code> is in the
domain of <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">t</span> <span class="o">!</span><span class="ow">in</span> <span class="n">m</span></code> is a syntactic shorthand for
<code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="n">m</span><span class="p">)</span></code>.<sup id="fnref:fn-map-membership" role="doc-noteref"><a href="#fn:fn-map-membership" class="footnote" rel="footnote">3</a></sup></p>

<p>The expressions <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Keys</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Values</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Items</span></code> return, as sets,
the domain, the range, and the 2-tuples holding the key-value
associations in the map. Note that <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Values</span></code> will have a different
cardinality than <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Keys</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Items</span></code> if different keys are
associated with the same value. If <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> is an <code class="language-dafny highlighter-rouge"><span class="kt">imap</span></code>, then these
expressions return <code class="language-dafny highlighter-rouge"><span class="kt">iset</span></code> values. If <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> is a map, <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Values</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Items</span></code>
require the type of the range <code class="language-dafny highlighter-rouge"><span class="n">U</span></code> to support equality.</p>

<p>Here is a small example, where a map <code class="language-dafny highlighter-rouge"><span class="n">cache</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">real</span><span class="o">&gt;</span></code>
is used to cache computed values of Joule-Thomson coefficients for
some fixed gas at a given temperature:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">if</span> <span class="n">K</span> <span class="ow">in</span> <span class="n">cache</span> <span class="p">{</span>  <span class="c1">// check if temperature is in domain of cache</span>
  <span class="n">coeff</span> <span class="o">:=</span> <span class="n">cache</span><span class="p">[</span><span class="n">K</span><span class="p">];</span>  <span class="c1">// read result in cache</span>
<span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
  <span class="n">coeff</span> <span class="o">:=</span> <span class="n">ComputeJTCoefficient</span><span class="p">(</span><span class="n">K</span><span class="p">);</span> <span class="c1">// do expensive computation</span>
  <span class="n">cache</span> <span class="o">:=</span> <span class="n">cache</span><span class="p">[</span><span class="n">K</span> <span class="o">:=</span> <span class="n">coeff</span><span class="p">];</span>  <span class="c1">// update the cache</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dafny also overloads the <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> binary operators for maps.
The <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> operator merges two maps or imaps of the same type, as if each
(key,value) pair of the RHS is added in turn to the LHS (i)map.
In this use, <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> is not commutative; if a key exists in both
(i)maps, it is the value from the RHS (i)map that is present in the result.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> operator implements a map difference operator. Here the LHS
is a <code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span></code> or <code class="language-dafny highlighter-rouge"><span class="kt">imap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span></code> and the RHS is a <code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span></code> (but not an <code class="language-dafny highlighter-rouge"><span class="kt">iset</span></code>); the operation removes
from the LHS all the (key,value) pairs whose key is a member of the RHS set.</p>

<p>To avoid causing circular reasoning chains or providing too much information that might
complicate Dafnys prover finding proofs, not all properties of maps are known by the prover by default.
For example, the following does not prove:
<!-- %check-verify Types.25.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">mmm</span><span class="o">&lt;</span><span class="n">K</span><span class="p">(</span><span class="o">==</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="o">:</span> <span class="kt">map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="o">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="o">:</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">mm</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">:=</span> <span class="n">v</span><span class="p">];</span>
    <span class="kr">assert</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mm</span><span class="o">.</span><span class="n">Values</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p>Rather, one must provide an intermediate step, which is not entirely obvious:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">mmm</span><span class="o">&lt;</span><span class="n">K</span><span class="p">(</span><span class="o">==</span><span class="p">),</span><span class="n">V</span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="o">:</span> <span class="kt">map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="o">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="o">:</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">mm</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">:=</span> <span class="n">v</span><span class="p">];</span>
    <span class="kr">assert</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mm</span><span class="o">.</span><span class="n">Keys</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mm</span><span class="o">.</span><span class="n">Values</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<h4 id="555-iterating-over-collections">5.5.5. Iterating over collections</h4>

<p>Collections are very commonly used in programming and one frequently
needs to iterate over the elements of a collection. Dafny does not have
built-in iterator methods, but the idioms by which to do so are straightforward.
The subsections below give some introductory examples; more
detail can be found in this <a href="http://leino.science/papers/krml275.html">power user note</a>.</p>

<h5 id="5551-sequences-and-arrays">5.5.5.1. Sequences and arrays</h5>

<p>Sequences and arrays are indexable and have a length. So the idiom to
iterate over the contents is well-known. For an array:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">sum</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">:=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>For a sequence, the only difference is the length operator:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">sum</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">:=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement (<a href="#sec-forall-statement">Section 8.21</a>) can also be used
with arrays where parallel assignment is needed:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">rev</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">Length</span><span class="p">];</span>
  <span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="n">Length</span> <span class="p">{</span>
    <span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">s</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">Length</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>See <a href="#sec-array-to-seq">Section 5.10.2</a> on how to convert an array to a sequence.</p>

<h5 id="5552-sets">5.5.5.2. Sets</h5>
<p>There is no intrinsic order to the elements of a set. Nevertheless, we can
extract an arbitrary element of a nonempty set, performing an iteration
as follows:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">ss</span> <span class="o">:=</span> <span class="n">s</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">ss</span> <span class="o">!=</span> <span class="p">{}</span>
    <span class="kr">decreases</span> <span class="o">|</span><span class="n">ss</span><span class="o">|</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:|</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ss</span><span class="p">;</span>
    <span class="n">ss</span> <span class="o">:=</span> <span class="n">ss</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">};</span>
    <span class="kr">print</span> <span class="n">i</span><span class="p">,</span> <span class="s2">"\n"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Because <code class="language-dafny highlighter-rouge"><span class="kt">iset</span></code>s may be infinite, Dafny does not permit iteration over an <code class="language-dafny highlighter-rouge"><span class="kt">iset</span></code>.</p>

<h5 id="5553-maps">5.5.5.3. Maps</h5>

<p>Iterating over the contents of a <code class="language-dafny highlighter-rouge"><span class="kt">map</span></code> uses the component sets: <code class="language-dafny highlighter-rouge"><span class="n">Keys</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">Values</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">Items</span></code>. The iteration loop follows the same patterns as for sets:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="o">==</span><span class="p">),</span><span class="n">U</span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">m</span><span class="o">:</span> <span class="kt">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">items</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">Items</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">items</span> <span class="o">!=</span> <span class="p">{}</span>
    <span class="kr">decreases</span> <span class="o">|</span><span class="n">items</span><span class="o">|</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">item</span> <span class="o">:|</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">;</span>
    <span class="n">items</span> <span class="o">:=</span> <span class="n">items</span> <span class="o">-</span> <span class="p">{</span> <span class="n">item</span> <span class="p">};</span>
    <span class="kr">print</span> <span class="n">item</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="s2">" "</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"\n"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There are no mechanisms currently defined in Dafny for iterating over <code class="language-dafny highlighter-rouge"><span class="kt">imap</span></code>s.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-type-definition">5.6. Types that stand for other types (<a href="#g-type-definition">grammar</a>)</h3>

<p>It is sometimes useful to know a type by several names or to treat a
type abstractly. There are several mechanisms in Dafny to do this:</p>

<ul>
  <li>(<a href="#sec-synonym-type">Section 5.6.1</a>) A typical <em>synonym type</em>, in which a type name is a synonym for another type</li>
  <li>(<a href="#sec-abstract-types">Section 5.6.2</a>) An <em>abstract type</em>, in which a new type name is declared as an uninterpreted type</li>
  <li>(<a href="#sec-subset-types">Section 5.6.3</a>) A <em>subset type</em>, in which a new type name is given to a subset of the values of a given type</li>
  <li>(<a href="#sec-newtypes">Section 5.7</a>) A <em>newtype</em>, in which a subset type is declared, but with restrictions on converting to and from its base type</li>
</ul>

<h4 id="sec-synonym-type">5.6.1. Type synonyms (<a href="#g-type-definition">grammar</a>)</h4>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span>
<span class="kr">type</span> <span class="n">SS</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<p>A <em>type synonym</em> declaration:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">Y</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">G</span>
</code></pre></div></div>
<p>declares <code class="language-dafny highlighter-rouge"><span class="n">Y</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> to be a synonym for the type <code class="language-dafny highlighter-rouge"><span class="n">G</span></code>.
If the <code class="language-dafny highlighter-rouge"><span class="o">=</span> <span class="n">G</span></code> is omitted then the declaration just declares a name as an uninterpreted
<em>abstract</em> type, as described in <a href="#sec-abstract-types">Section 5.6.2</a>.  Such types may be
given a definition elsewhere in the Dafny program.</p>

<p>Here, <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is a
nonempty list of type parameters (each of which optionally
has a <a href="#sec-type-characteristics">type characteristics suffix</a>), which can be used as free type
variables in <code class="language-dafny highlighter-rouge"><span class="n">G</span></code>.  If the synonym has no type parameters, the <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>
is dropped.  In all cases, a type synonym is just a synonym.  That is,
there is never a difference, other than possibly in error messages
produced, between <code class="language-dafny highlighter-rouge"><span class="n">Y</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">G</span></code>.</p>

<p>For example, the names of the following type synonyms may improve the
readability of a program:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">Replacements</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kr">type</span> <span class="n">Vertex</span> <span class="o">=</span> <span class="kt">int</span>
</code></pre></div></div>

<p>The new type name itself may have <a href="#sec-type-characteristics">type characteristics</a> declared, and may need to if there is no definition.
If there is a definition, the type characteristics are typically inferred from the definition. The syntax is like this:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">Z</span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>As already described in <a href="#sec-strings">Section 5.5.3.5</a>, <code class="language-dafny highlighter-rouge"><span class="kt">string</span></code> is a built-in
type synonym for <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span></code>, as if it would have been declared as
follows:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">string_</span><span class="p">(</span><span class="o">==</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span> <span class="o">=</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>If the implicit declaration did not include the type characteristics, they would be inferred in any case.</p>

<p>Note that although a type synonym can be declared and used in place of a type name,
that does not affect the names of datatype or class constructors.
For example, consider
<!-- %check-resolve Types.22.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Pair</span><span class="p">(</span><span class="n">first</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">second</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span>
<span class="kr">type</span> <span class="n">IntPair</span> <span class="o">=</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>

<span class="kr">const</span> <span class="n">p</span><span class="o">:</span> <span class="n">IntPair</span> <span class="o">:=</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// OK</span>
<span class="kr">const</span> <span class="n">q</span><span class="o">:</span> <span class="n">IntPair</span> <span class="o">:=</span> <span class="n">IntPair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// Error</span>
</code></pre></div></div>

<p>In the declaration of <code class="language-dafny highlighter-rouge"><span class="n">q</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">IntPair</span></code> is the name of a type, not the name of a function or datatype constructor.</p>

<h4 id="sec-abstract-types">5.6.2. Abstract types (<a href="#g-type-definition">grammar</a>)</h4>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">T</span>
<span class="kr">type</span> <span class="n">Q</span> <span class="p">{</span> <span class="kr">function</span> <span class="n">toString</span><span class="p">(</span><span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">}</span>
</code></pre></div></div>

<p>An abstract type is a special case of a type synonym that is underspecified.  Such
a type is declared simply by:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">Y</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>Its definition can be stated in a
refining module.  The name <code class="language-dafny highlighter-rouge"><span class="n">Y</span></code> can be immediately followed by
a type characteristics suffix (<a href="#sec-type-characteristics">Section 5.3.1</a>).
Because there is no defining RHS, the type characteristics cannot be inferred and so
must be stated. If, in some refining module, a definition of the type is given, the
type characteristics must match those of the new definition.</p>

<p>For example, the declarations
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">T</span>
<span class="kr">function</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span><span class="o">:</span> <span class="n">T</span>
</code></pre></div></div>
<p>can be used to model an uninterpreted function <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> on some
arbitrary type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>.  As another example,
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">Monad</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>can be used abstractly to represent an arbitrary parameterized monad.</p>

<p>Even as an abstract type, the type
may be given members such as constants, methods or functions.
For example,
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">P</span> <span class="p">{</span>
  <span class="kr">type</span> <span class="n">T</span> <span class="p">{</span>
    <span class="kr">function</span> <span class="n">ToString</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">X</span> <span class="kr">refines</span> <span class="n">P</span> <span class="p">{</span>
  <span class="kr">newtype</span> <span class="n">T</span> <span class="o">=</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
    <span class="kr">function</span> <span class="n">ToString</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>  <span class="s2">""</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The abstract type <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="o">.</span><span class="n">T</span></code> has a declared member <code class="language-dafny highlighter-rouge"><span class="n">ToString</span></code>, which can be called wherever <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="o">.</span><span class="n">T</span></code> may be used.
In the refining module <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is declared to be a <code class="language-dafny highlighter-rouge"><span class="kr">newtype</span></code>, in which <code class="language-dafny highlighter-rouge"><span class="n">ToString</span></code> now has a body.</p>

<p>It would be an error to refine <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="o">.</span><span class="n">T</span></code> as a simple type synonym or subset type in <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>, say <code class="language-dafny highlighter-rouge"><span class="kr">type</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span></code>, because
type synonyms may not have members.</p>

<h4 id="sec-subset-types">5.6.3. Subset types (<a href="#g-type-definition">grammar</a>)</h4>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">Pos</span> <span class="o">=</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">witness</span> <span class="mi">1</span>
<span class="kr">type</span> <span class="n">PosReal</span> <span class="o">=</span> <span class="n">r</span> <span class="o">|</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="kr">witness</span> <span class="mf">1.0</span>
<span class="kr">type</span> <span class="n">Empty</span> <span class="o">=</span> <span class="n">n</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="kr">witness</span> <span class="o">*</span>
<span class="kr">type</span> <span class="n">Big</span> <span class="o">=</span> <span class="n">n</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="kr">ghost</span> <span class="kr">witness</span> <span class="mi">10000</span>
</code></pre></div></div>

<p>A <em>subset type</em> is a restricted use of an existing type, called
the <em>base type</em> of the subset type.  A subset type is like a
combined use of the base type and a predicate on the base
type.</p>

<p>An assignment from a subset type to its base type is always
allowed.  An assignment in the other direction, from the base type to
a subset type, is allowed provided the value assigned does indeed
satisfy the predicate of the subset type. This condition is checked
by the verifier, not by the type checker. Similarly, assignments from
one subset type to another (both with the same base type) are also
permitted, as long as it can be established that the value being assigned
satisfies the predicate defining the receiving subset type.
(Note, in contrast, assignments between a newtype and its base type
are never allowed, even if the value assigned is a value of the target
type.  For such assignments, an explicit conversion must be used, see
<a href="#sec-as-is-expression">Section 9.10</a>.)</p>

<p>The declaration of a subset type permits an optional <a href="#sec-witness"><code class="language-dafny highlighter-rouge"><span class="kr">witness</span></code> clause</a>, to declare that there is
a value that satisfies the subset types predicate; that is, the witness clause establishes that the defined
type is not empty. The compiler may, but is not obligated to, use this value when auto-initializing a
newly declared variable of the subset type.</p>

<p>Dafny builds in three families of subset types, as described next.</p>

<h5 id="5631-type-nat">5.6.3.1. Type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code></h5>

<p>The built-in type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code>, which represents the non-negative integers
(that is, the natural numbers), is a subset type:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="kt">nat</span> <span class="o">=</span> <span class="n">n</span><span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span>
</code></pre></div></div>

<p>A simple example that
puts subset type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> to good use is the standard Fibonacci
function:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>An equivalent, but clumsy, formulation of this function (modulo the
wording of any error messages produced at call sites) would be to use
type <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> and to write the restricting predicate in pre- and
postconditions:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">requires</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span>  <span class="c1">// the function argument must be non-negative</span>
  <span class="kr">ensures</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1">// the function result is non-negative</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="5632-non-null-types">5.6.3.2. Non-null types</h5>

<p>Every class, trait, and iterator declaration <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> gives rise to two types.</p>

<p>One type has the name <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code> (that is, the name of the class, trait,
or iterator declaration with a <code class="language-dafny highlighter-rouge"><span class="n">?</span></code> character appended to the end).
The values of <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code> are the references to <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> objects, and also
the value <code class="language-dafny highlighter-rouge"><span class="kc">null</span></code>.
In other words, <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code> is the type of <em>possibly null</em> references
(aka, <em>nullable</em> references) to <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> objects.</p>

<p>The other type has the name <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> (that is, the same name as the
class, trait, or iterator declaration).
Its values are the references to <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> objects, and does not contain
the value <code class="language-dafny highlighter-rouge"><span class="kc">null</span></code>.
In other words, <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is the type of <em>non-null</em> references to <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>
objects.</p>

<p>The type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is a subset type of <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code>:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">C</span> <span class="o">=</span> <span class="n">c</span><span class="o">:</span> <span class="n">C?</span> <span class="o">|</span> <span class="n">c</span> <span class="o">!=</span> <span class="kc">null</span>
</code></pre></div></div>
<p>(It may be natural to think of the type <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code> as the union of
type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> and the value <code class="language-dafny highlighter-rouge"><span class="kc">null</span></code>, but, technically, Dafny defines
<code class="language-dafny highlighter-rouge"><span class="n">C</span></code> as a subset type with base type <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code>.)</p>

<p>From being a subset type, we get that <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is a subtype of <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code>.
Moreover, if a class or trait <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> extends a trait <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>, then
type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is a subtype of <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> and type <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code> is a subtype of <code class="language-dafny highlighter-rouge"><span class="n">B?</span></code>.</p>

<p>Every possibly-null reference type is a subtype of the
built-in possibly-null trait type <code class="language-dafny highlighter-rouge"><span class="kt">object?</span></code>, and
every non-null reference type is a subtype of the
built-in non-null trait type <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code>. (And, from the fact
that <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> is a subset type of <code class="language-dafny highlighter-rouge"><span class="kt">object?</span></code>, we also have that
<code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> is a subtype of <code class="language-dafny highlighter-rouge"><span class="kt">object?</span></code>.)</p>

<p>Arrays are references and array types also come in these two flavors.
For example,
<code class="language-dafny highlighter-rouge"><span class="kt">array?</span></code> and <code class="language-dafny highlighter-rouge"><span class="kt">array2?</span></code> are possibly-null (1- and 2-dimensional) array types, and
<code class="language-dafny highlighter-rouge"><span class="kt">array</span></code> and <code class="language-dafny highlighter-rouge"><span class="kt">array2</span></code> are their respective non-null types.</p>

<p>Note that <code class="language-dafny highlighter-rouge"><span class="n">?</span></code> is not an operator. Instead, it is simply the last
character of the name of these various possibly-null types.</p>

<h5 id="sec-arrow-subset-types">5.6.3.3. Arrow types: <code class="language-dafny highlighter-rouge"><span class="o">-&gt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">--&gt;</span></code>, and <code class="language-dafny highlighter-rouge"><span class="err">~</span><span class="o">&gt;</span></code></h5>

<p>For more information about arrow types (function types), see <a href="#sec-arrow-types">Section 5.12</a>.
This section is a preview to point out the subset-type relationships among the kinds
of function types.</p>

<p>The built-in type</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="o">-&gt;</span></code> stands for total functions,</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--&gt;</span></code> stands for partial functions (that is, functions with possible <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses),
and</li>
  <li><code class="language-dafny highlighter-rouge"><span class="err">~</span><span class="o">&gt;</span></code> stands for all functions.</li>
</ul>

<p>More precisely, type constructors
exist for any arity (<code class="language-dafny highlighter-rouge"><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">X</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">X</span></code>, <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">X</span></code>, <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">X</span></code>,
etc.).</p>

<p>For a list of types <code class="language-dafny highlighter-rouge"><span class="n">TT</span></code> and a type <code class="language-dafny highlighter-rouge"><span class="n">U</span></code>, the values of the arrow type <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">U</span></code>
are functions from <code class="language-dafny highlighter-rouge"><span class="n">TT</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">U</span></code>. This includes functions that may read the
heap and functions that are not defined on all inputs. It is not common
to need this generality (and working with such general functions is
difficult). Therefore, Dafny defines two subset types that are more common
(and much easier to work with).</p>

<p>The type <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">U</span></code> denotes the subset of <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">U</span></code> where the functions
do not read the (mutable parts of the) heap.
Values of type <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">U</span></code> are called <em>partial functions</em>,
and the subset type <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">U</span></code> is called the <em>partial arrow type</em>.
(As a mnemonic to help you remember that this is the partial arrow, you may
think of the little gap between the two hyphens in <code class="language-dafny highlighter-rouge"><span class="o">--&gt;</span></code> as showing a broken
arrow.)</p>

<p>Intuitively, the built-in partial arrow type is defined as follows (here shown
for arrows with arity 1):
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">A</span> <span class="o">--&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">f</span><span class="o">:</span> <span class="n">A</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">B</span> <span class="o">|</span> <span class="kr">forall</span> <span class="n">a</span> <span class="o">::</span> <span class="n">f</span><span class="o">.</span><span class="kr">reads</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="p">{}</span>
</code></pre></div></div>
<p>(except that what is shown here left of the <code class="language-dafny highlighter-rouge"><span class="o">=</span></code> is not legal Dafny syntax
and that the restriction could not be verified as is).
That is, the partial arrow type is defined as those functions <code class="language-dafny highlighter-rouge"><span class="n">f</span></code>
whose reads frame is empty for all inputs.
More precisely, taking variance into account, the partial arrow type
is defined as
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="o">-</span><span class="n">A</span> <span class="o">--&gt;</span> <span class="o">+</span><span class="n">B</span> <span class="o">=</span> <span class="n">f</span><span class="o">:</span> <span class="n">A</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">B</span> <span class="o">|</span> <span class="kr">forall</span> <span class="n">a</span> <span class="o">::</span> <span class="n">f</span><span class="o">.</span><span class="kr">reads</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="p">{}</span>
</code></pre></div></div>

<p>The type <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span></code> is, in turn, a subset type of <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">U</span></code>, adding the
restriction that the functions must not impose any precondition. That is,
values of type <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span></code> are <em>total functions</em>, and the subset type
<code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span></code> is called the <em>total arrow type</em>.</p>

<p>The built-in total arrow type is defined as follows (here shown
for arrows with arity 1):
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="o">-</span><span class="n">A</span> <span class="o">-&gt;</span> <span class="o">+</span><span class="n">B</span> <span class="o">=</span> <span class="n">f</span><span class="o">:</span> <span class="n">A</span> <span class="o">--&gt;</span> <span class="n">B</span> <span class="o">|</span> <span class="kr">forall</span> <span class="n">a</span> <span class="o">::</span> <span class="n">f</span><span class="o">.</span><span class="kr">requires</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>
<p>That is, the total arrow type is defined as those partial functions <code class="language-dafny highlighter-rouge"><span class="n">f</span></code>
whose precondition evaluates to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> for all inputs.</p>

<p>Among these types, the most commonly used are the total arrow types.
They are also the easiest to work with. Because they are common, they
have the simplest syntax (<code class="language-dafny highlighter-rouge"><span class="o">-&gt;</span></code>).</p>

<p>Note, informally, we tend to speak of all three of these types as arrow types,
even though, technically, the <code class="language-dafny highlighter-rouge"><span class="err">~</span><span class="o">&gt;</span></code> types are the arrow types and the
<code class="language-dafny highlighter-rouge"><span class="o">--&gt;</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">-&gt;</span></code> types are subset types thereof. The one place where you may need to
remember that <code class="language-dafny highlighter-rouge"><span class="o">--&gt;</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">-&gt;</span></code> are subset types is in some error messages.
For example, if you try to assign a partial function to a variable whose
type is a total arrow type and the verifier is not able to prove that the
partial function really is total, then youll get an error saying that the subset-type
constraint may not be satisfied.</p>

<p>For more information about arrow types, see <a href="#sec-arrow-types">Section 5.12</a>.</p>

<h5 id="sec-witness">5.6.3.4. Witness clauses</h5>

<p>The declaration of a subset type permits an optional <code class="language-dafny highlighter-rouge"><span class="kr">witness</span></code> clause.
Types in Dafny are generally expected to be non-empty, in part because
variables of any type are expected to have some value when they are used.
In many cases, Dafny can determine that a newly declared type has
some value.
For example, in the absence of a witness clause,
a numeric type that includes 0 is known by Dafny
to be non-empty.
However, Dafny cannot always make this determination.
If it cannot, a <code class="language-dafny highlighter-rouge"><span class="kr">witness</span></code> clause is required. The value given in
the <code class="language-dafny highlighter-rouge"><span class="kr">witness</span></code> clause must be a valid value for the type and assures Dafny
that the type is non-empty. (The variation <code class="language-dafny highlighter-rouge"><span class="kr">witness</span> <span class="o">*</span></code> is described below.)</p>

<p>For example,
<!-- %check-verify Types.10.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">OddInt</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div></div>
<p>will give an error message, but
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">OddInt</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">witness</span> <span class="mi">73</span>
</code></pre></div></div>
<p>does not. Here is another example:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">NonEmptySeq</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">witness</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>If the witness is only available in ghost code, you can declare the witness
as a <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">witness</span></code>. In this case, the Dafny verifier knows that the type
is non-empty, but it will not be able to auto-initialize a variable of that
type in compiled code.</p>

<p>There is even room to do the following:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">BaseType</span>
<span class="kr">predicate</span> <span class="n">RHS</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">BaseType</span><span class="p">)</span>
<span class="kr">type</span> <span class="n">MySubset</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span> <span class="n">BaseType</span> <span class="o">|</span> <span class="n">RHS</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">ghost</span> <span class="kr">witness</span> <span class="n">MySubsetWitness</span><span class="p">()</span>

<span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span> <span class="n">MySubsetWitness</span><span class="p">()</span><span class="o">:</span> <span class="n">BaseType</span>
  <span class="kr">ensures</span> <span class="n">RHS</span><span class="p">(</span><span class="n">MySubsetWitness</span><span class="p">())</span>
</code></pre></div></div>
<p>Here the type is given a ghost witness: the result of the expression
<code class="language-dafny highlighter-rouge"><span class="n">MySubsetWitness</span><span class="p">()</span></code>, which is a call of a (ghost) function.
Now that function has a postcondition saying that the returned value
is indeed a candidate value for the declared type, so the verifier is
satisfied regarding the non-emptiness of the type. However, the function
has no body, so there is still no proof that there is indeed such a witness.
You can either supply a, perhaps complicated, body to generate a viable
candidate or you can be very sure, without proof, that there is indeed such a value.
If you are wrong, you have introduced an unsoundness into your program.</p>

<p>In addition though, types are allowed to be empty or possibly empty.
This is indicated by the clause <code class="language-dafny highlighter-rouge"><span class="kr">witness</span> <span class="o">*</span></code>, which tells the verifier not to check for a satisfying witness.
A declaration like this produces an empty type:
<!-- %check-verify %save ReallyEmpty.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">ReallyEmpty</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="kc">false</span> <span class="kr">witness</span> <span class="o">*</span>
</code></pre></div></div>
<p>The type can be used in code like
<!-- %check-verify %use ReallyEmpty.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">M</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">ReallyEmpty</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">seven</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">seven</span> <span class="o">==</span> <span class="mi">7</span>
<span class="p">{</span>
  <span class="n">seven</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>which does verify. But the method can never be called because there is no value that
can be supplied as the argument. Even this code
<!-- %check-verify Types.10a.expect %use ReallyEmpty.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">P</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">seven</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">seven</span> <span class="o">==</span> <span class="mi">7</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="n">ReallyEmpty</span><span class="p">;</span>
  <span class="n">seven</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>does not complain about <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> unless <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is actually used, in which case it must have a value.
The postcondition in <code class="language-dafny highlighter-rouge"><span class="n">P</span></code> does not verify, but not because of the empty type.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-newtypes">5.7. Newtypes (<a href="#g-type-definition">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">newtype</span> <span class="n">I</span> <span class="o">=</span> <span class="kt">int</span>
<span class="kr">newtype</span> <span class="n">D</span> <span class="o">=</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span>
<span class="kr">newtype</span> <span class="n">uint8</span> <span class="o">=</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span>
</code></pre></div></div>

<p>A newtype is like a type synonym or subset type except that it declares a wholly new type
name that is distinct from its base type. It also accepts an optional <a href="#sec-witness"><code class="language-dafny highlighter-rouge"><span class="kr">witness</span></code> clause</a>.</p>

<p>A new type can be declared with the <em>newtype</em>
declaration, for example:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">newtype</span> <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span> <span class="n">M</span> <span class="o">|</span> <span class="n">Q</span>
</code></pre></div></div>
<p>where <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> is a type and <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code> is a boolean expression that can
use <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> as a free variable.  If <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> is an integer-based numeric type,
then so is <code class="language-dafny highlighter-rouge"><span class="n">N</span></code>; if <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> is real-based, then so is <code class="language-dafny highlighter-rouge"><span class="n">N</span></code>.  If the type <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>
can be inferred from <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code>, the <code class="language-dafny highlighter-rouge"><span class="o">:</span> <span class="n">M</span></code> can be omitted.  If <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code> is just
<code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>, then the declaration can be given simply as:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">newtype</span> <span class="n">N</span> <span class="o">=</span> <span class="n">M</span>
</code></pre></div></div>
<p>Type <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> is known as the <em>base type</em> of <code class="language-dafny highlighter-rouge"><span class="n">N</span></code>. At present, Dafny only supports
<code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> and <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code> as base types of newtypes.</p>

<p>A newtype is a type that supports the same operations as its
base type.  The newtype is distinct from and incompatible with other
types; in particular, it is not assignable to its base type
without an explicit conversion.  An important difference between the
operations on a newtype and the operations on its base type is that
the newtype operations are defined only if the result satisfies the
predicate <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code>, and likewise for the literals of the
newtype.</p>

<p>For example, suppose <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> are integer-based numeric bounds that
satisfy <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span></code> and consider the following code fragment:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>
<p>If <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> have type <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>, then the code fragment is legal; in
particular, it never overflows, since <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> has no upper bound.  In
contrast, if <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> are variables of a newtype <code class="language-dafny highlighter-rouge"><span class="n">int32</span></code> declared
as follows:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">newtype</span> <span class="n">int32</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="o">-</span><span class="mh">0x8000_0000</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mh">0x8000_0000</span>
</code></pre></div></div>
<p>then the code fragment is erroneous, since the result of the addition
may fail to satisfy the predicate in the definition of <code class="language-dafny highlighter-rouge"><span class="n">int32</span></code>.  The
code fragment can be rewritten as
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">mid</span> <span class="o">:=</span> <span class="n">lo</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>
<p>in which case it is legal for both <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">int32</span></code>.</p>

<p>An additional point with respect to arithmetic overflow is that for (signed)
<code class="language-dafny highlighter-rouge"><span class="n">int32</span></code> values <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> constrained only by <code class="language-dafny highlighter-rouge"><span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span></code>, the difference <code class="language-dafny highlighter-rouge"><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span></code>
can also overflow the bounds of the <code class="language-dafny highlighter-rouge"><span class="n">int32</span></code> type. So you could also write:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">mid</span> <span class="o">:=</span> <span class="n">lo</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">lo</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>

<p>Since a newtype is incompatible with its base type and since all
results of the newtypes operations are members of the newtype, a
compiler for Dafny is free to specialize the run-time representation
of the newtype.  For example, by scrutinizing the definition of
<code class="language-dafny highlighter-rouge"><span class="n">int32</span></code> above, a compiler may decide to store <code class="language-dafny highlighter-rouge"><span class="n">int32</span></code> values using
signed 32-bit integers in the target hardware.</p>

<p>The incompatibility of a newtype and its basetype is intentional,
as newtypes are meant to be used as distinct types from the basetype.
If numeric types are desired that mix more readily with the basetype,
the subset types described in <a href="#sec-subset-types">Section 5.6.3</a>
 may be more appropriate.</p>

<p>Note that the bound variable <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> in <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code> has type <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>, not <code class="language-dafny highlighter-rouge"><span class="n">N</span></code>.
Consequently, it may not be possible to state <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code> about the <code class="language-dafny highlighter-rouge"><span class="n">N</span></code>
value.  For example, consider the following type of 8-bit 2s
complement integers:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">newtype</span> <span class="n">int8</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="o">-</span><span class="mi">128</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">128</span>
</code></pre></div></div>
<p>and consider a variable <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> of type <code class="language-dafny highlighter-rouge"><span class="n">int8</span></code>.  The expression
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="o">-</span><span class="mi">128</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">128</span>
</code></pre></div></div>
<p>is not well-defined, because the comparisons require each operand to
have type <code class="language-dafny highlighter-rouge"><span class="n">int8</span></code>, which means the literal <code class="language-dafny highlighter-rouge"><span class="mi">128</span></code> is checked to be of
type <code class="language-dafny highlighter-rouge"><span class="n">int8</span></code>, which it is not.  A proper way to write this expression
is to use a conversion operation, described in <a href="#sec-conversion">Section 5.7.1</a>, on <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> to
convert it to the base type:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="o">-</span><span class="mi">128</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="ow">as</span> <span class="kt">int</span> <span class="o">&lt;</span> <span class="mi">128</span>
</code></pre></div></div>

<p>If possible, Dafny compilers will represent values of the newtype using
a native type for the sake of efficiency. This action can
be inhibited or a specific native data type selected by
using the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">nativeType</span><span class="p">}</span></code> attribute, as explained in
<a href="#sec-nativetype">Section 11.1.2</a>.</p>

<p>Furthermore, for the compiler to be able to make an appropriate choice of
representation, the constants in the defining expression as shown above must be
known constants at compile-time. They need not be numeric literals; combinations
of basic operations and symbolic constants are also allowed as described
in <a href="#sec-compile-time-constants">Section 9.39</a>.</p>

<h4 id="sec-conversion">5.7.1. Conversion operations</h4>

<p>For every type <code class="language-dafny highlighter-rouge"><span class="n">N</span></code>, there is a conversion operation with the
name <code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="n">N</span></code>, described more fully in <a href="#sec-as-is-expression">Section 9.10</a>.
It is a partial function defined when the
given value, which can be of any type, is a member of the type
converted to.  When the conversion is from a real-based numeric type
to an integer-based numeric type, the operation requires that the
real-based argument have no fractional part.  (To round a real-based
numeric value down to the nearest integer, use the <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">Floor</span></code> member,
see <a href="#sec-numeric-types">Section 5.2.2</a>.)</p>

<p>To illustrate using the example from above, if <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> have type
<code class="language-dafny highlighter-rouge"><span class="n">int32</span></code>, then the code fragment can legally be written as follows:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="n">lo</span> <span class="ow">as</span> <span class="kt">int</span> <span class="o">+</span> <span class="n">hi</span> <span class="ow">as</span> <span class="kt">int</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>
<p>where the type of <code class="language-dafny highlighter-rouge"><span class="n">mid</span></code> is inferred to be <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>.  Since the result
value of the division is a member of type <code class="language-dafny highlighter-rouge"><span class="n">int32</span></code>, one can introduce
yet another conversion operation to make the type of <code class="language-dafny highlighter-rouge"><span class="n">mid</span></code> be <code class="language-dafny highlighter-rouge"><span class="n">int32</span></code>:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">mid</span> <span class="o">:=</span> <span class="p">((</span><span class="n">lo</span> <span class="ow">as</span> <span class="kt">int</span> <span class="o">+</span> <span class="n">hi</span> <span class="ow">as</span> <span class="kt">int</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">as</span> <span class="n">int32</span><span class="p">;</span>
</code></pre></div></div>
<p>If the compiler does specialize the run-time representation for
<code class="language-dafny highlighter-rouge"><span class="n">int32</span></code>, then these statements come at the expense of two,
respectively three, run-time conversions.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="n">N</span></code> conversion operation is grammatically a suffix operation like
<code class="language-dafny highlighter-rouge"><span class="o">.</span></code>field and array indexing, but binds less tightly than unary operations:
<code class="language-dafny highlighter-rouge"><span class="o">-</span> <span class="n">x</span> <span class="ow">as</span> <span class="kt">int</span></code> is <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="ow">as</span> <span class="kt">int</span></code>; <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="ow">as</span> <span class="kt">int</span></code> is <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="ow">as</span> <span class="kt">int</span><span class="p">)</span></code>.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="n">N</span></code> conversion can also be used with reference types. For example,
if <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is a class, <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> is an expression of type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">o</span></code> is an expression
of type <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code>, then <code class="language-dafny highlighter-rouge"><span class="n">c</span> <span class="ow">as</span> <span class="kt">object</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">c</span> <span class="ow">as</span> <span class="kt">object?</span></code> are upcasts
and <code class="language-dafny highlighter-rouge"><span class="n">o</span> <span class="ow">is</span> <span class="n">C</span></code> is a downcast. A downcast requires the LHS expression to
have the RHS type, as is enforced by the verifier.</p>

<p>For some types (in particular, reference types), there is also a
corresponding <code class="language-dafny highlighter-rouge"><span class="ow">is</span></code> operation (<a href="#sec-as-is-expression">Section 9.10</a>) that
tests whether a value is valid for a given type.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-class-types">5.8. Class types (<a href="#g-class-type">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">trait</span> <span class="n">T</span> <span class="p">{}</span>
<span class="kr">class</span> <span class="n">A</span> <span class="p">{}</span>
<span class="kr">class</span> <span class="n">B</span> <span class="kr">extends</span> <span class="n">T</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">b</span><span class="o">:</span> <span class="n">B?</span>
  <span class="kr">var</span> <span class="n">v</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">constructor</span> <span class="p">(</span><span class="n">vv</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">vv</span><span class="p">;</span> <span class="n">b</span> <span class="o">:=</span> <span class="kc">null</span><span class="p">;</span> <span class="p">}</span>
  <span class="kr">function</span> <span class="n">toString</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span> <span class="s2">"a B"</span> <span class="p">}</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">B</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
  <span class="kr">static</span> <span class="kr">method</span> <span class="n">q</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Declarations within a class all begin with keywords and do not end with semicolons.</p>

<p>A <em>class</em> <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is a reference type declared as follows:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="n">J1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Jn</span>
<span class="p">{</span>
  <span class="err">_</span><span class="n">members_</span>
<span class="p">}</span>
</code></pre></div></div>
<p>where the &lt;&gt;-enclosed list of one-or-more type parameters <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is optional. The text
<code class="language-dafny highlighter-rouge"><span class="kr">extends</span> <span class="n">J1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Jn</span></code> is also optional and says that the class extends traits <code class="language-dafny highlighter-rouge"><span class="n">J1</span></code>  <code class="language-dafny highlighter-rouge"><span class="n">Jn</span></code>.
The members of a class are <em>fields</em>, <em>constant fields</em>, <em>functions</em>, and
<em>methods</em>.  These are accessed or invoked by dereferencing a reference
to a <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> instance.</p>

<p>A function or method is invoked on an <em>instance</em>
of <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>, unless the function or method is declared <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code>.
A function or method that is not <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code> is called an
<em>instance</em> function or method.</p>

<p>An instance function or method takes an implicit <em>receiver</em>
parameter, namely, the instance used to access the member.  In the
specification and body of an instance function or method, the receiver
parameter can be referred to explicitly by the keyword <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>.
However, in such places, members of <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code> can also be mentioned
without any qualification.  To illustrate, the qualified <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">f</span></code> and
the unqualified <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> refer to the same field of the same object in the
following example:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">method</span> <span class="n">Example</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">==</span> <span class="kr">this</span><span class="o">.</span><span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>so the method body always assigns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> to the out-parameter <code class="language-dafny highlighter-rouge"><span class="n">b</span></code>.
However, in this example, <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">x</span></code> are different because
the field <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is shadowed by the declaration of the local variable <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>.
There is no semantic difference between qualified and
unqualified accesses to the same receiver and member.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> instance is created using <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code>. There are three forms of <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code>,
depending on whether or not the class declares any <em>constructors</em>
(see <a href="#sec-constructor-methods">Section 6.3.2</a>):</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">;</span>
<span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</code></pre></div></div>

<p>For a class with no constructors, the first two forms can be used.
The first form simply allocates a new instance of a <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> object, initializing
its fields to values of their respective types (and initializing each <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> field
with a RHS to its specified value). The second form additionally invokes
an <em>initialization method</em> (here, named <code class="language-dafny highlighter-rouge"><span class="n">Init</span></code>) on the newly allocated object
and the given arguments. It is therefore a shorthand for
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">;</span>
<span class="n">c</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</code></pre></div></div>
<p>An initialization method is an ordinary method that has no out-parameters and
that modifies no more than <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>.</p>

<p>For a class that declares one or more constructors, the second and third forms
of <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> can be used. For such a class, the second form invokes the indicated
constructor (here, named <code class="language-dafny highlighter-rouge"><span class="n">Init</span></code>), which allocates and initializes the object.
The third form is the same as the second, but invokes the <em>anonymous constructor</em>
of the class (that is, a constructor declared with the empty-string name).</p>

<p>The details of constructors and other class members are described in <a href="#sec-constructor-methods">Section 6.3.2</a>.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-trait-types">5.9. Trait types (<a href="#g-trait-type">grammar</a>)</h3>

<p>A <em>trait</em> is an abstract superclass, similar to an interface or
mixin. A trait can be <em>extended</em> only by another trait or
by a class (and in the latter case we say that the class <em>implements</em>
the trait). More specifically, algebraic datatypes cannot extend traits.<sup id="fnref:fn-traits" role="doc-noteref"><a href="#fn:fn-traits" class="footnote" rel="footnote">4</a></sup></p>

<p>The declaration of a trait is much like that of a class:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">trait</span> <span class="n">J</span>
<span class="p">{</span>
  <span class="err">_</span><span class="n">members_</span>
<span class="p">}</span>
</code></pre></div></div>
<p>where <em>members</em> can include fields, constant fields, functions, methods and declarations of nested traits, but
no constructor methods.  The functions and methods are allowed to be
declared <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code>.</p>

<p>A reference type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> that extends a trait <code class="language-dafny highlighter-rouge"><span class="n">J</span></code> is assignable to a variable of
type <code class="language-dafny highlighter-rouge"><span class="n">J</span></code>;
a value of type <code class="language-dafny highlighter-rouge"><span class="n">J</span></code> is assignable to a variable of a reference type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> that
extends <code class="language-dafny highlighter-rouge"><span class="n">J</span></code> only if the verifier can prove that the reference does
indeed refer to an object of allocated type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>.
The members of <code class="language-dafny highlighter-rouge"><span class="n">J</span></code> are available as members
of <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>.  A member in <code class="language-dafny highlighter-rouge"><span class="n">J</span></code> is not allowed to be redeclared in <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>,
except if the member is a non-<code class="language-dafny highlighter-rouge"><span class="kr">static</span></code> function or method without a
body in <code class="language-dafny highlighter-rouge"><span class="n">J</span></code>.  By doing so, type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> can supply a stronger
specification and a body for the member. There is further discussion on
this point in <a href="#sec-inheritance">Section 5.9.2</a>.</p>

<p><code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> is not allowed to be used with traits.  Therefore, there is no
object whose allocated type is a trait.  But there can of course be
objects of a class <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> that implement a trait <code class="language-dafny highlighter-rouge"><span class="n">J</span></code>, and a reference to
such a <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> object can be used as a value of type <code class="language-dafny highlighter-rouge"><span class="n">J</span></code>.</p>

<h4 id="sec-object-type">5.9.1. Type <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> (<a href="#g-object-type">grammar</a>)</h4>

<p>There is a built-in trait <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> that is implicitly extended by all classes and traits.
It produces two types: the type <code class="language-dafny highlighter-rouge"><span class="kt">object?</span></code> that is a supertype of all
reference types and a subset type <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> that is a supertype of all non-null reference types.
This includes reference types like arrays and iterators that do not permit
explicit extending of traits. The purpose of type <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code>
is to enable a uniform treatment of <em>dynamic frames</em>. In particular, it
is useful to keep a ghost field (typically named <code class="language-dafny highlighter-rouge"><span class="n">Repr</span></code> for
representation) of type <code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span></code>.</p>

<p>It serves no purpose (but does no harm) to explicitly list the trait <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> as
an extendee in a class or trait declaration.</p>

<p>Traits <code class="language-dafny highlighter-rouge"><span class="kt">object?</span></code> and  <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> contain no members.</p>

<p>The dynamic allocation of objects is done using <code class="language-dafny highlighter-rouge"><span class="kr">new</span> <span class="n">C</span></code>,
 where <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is the name of a class.
 The name <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is not allowed to be a trait,
 except that it is allowed to be <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code>.
 The construction <code class="language-dafny highlighter-rouge"><span class="kr">new</span> <span class="kt">object</span></code> allocates a new object (of an unspecified class type).
 The construction can be used to create unique references, where no other properties of those references are needed.
(<code class="language-dafny highlighter-rouge"><span class="kr">new</span> <span class="kt">object?</span></code> makes no sense; always use <code class="language-dafny highlighter-rouge"><span class="kr">new</span> <span class="kt">object</span></code> instead because the result of
<code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> is always non-null.)</p>

<h4 id="sec-inheritance">5.9.2. Inheritance</h4>

<p>The purpose of traits is to be able to express abstraction: a trait
encapsulates a set of behaviors; classes and traits that extend it
<em>inherit</em> those behaviors, perhaps specializing them.</p>

<p>A trait or class may extend multiple other traits.
The traits syntactically listed in a trait or classs <code class="language-dafny highlighter-rouge"><span class="kr">extends</span></code> clause
are called its <em>direct parents</em>; the <em>transitive parents</em> of a trait or class
are its direct parents, the transitive parents of its direct parents, and
the <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> trait (if it is not itself <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code>).
These are sets of traits, in that it does not matter if
there are repetitions of a given trait in a class or traits direct or
transitive parents. However, if a trait with type parameters is repeated,
it must have the same actual type parameters in each instance.
Furthermore, a trait may not be in its own set of transitive parents; that is,
the graph of traits connected by the directed <em>extends</em> relationship may not
have any cycles.</p>

<p>A class or trait inherits (as if they are copied) all the instance members
of its transitive parents. However, since names may not be overloaded in
Dafny, different members (that is, members with different type signatures)
within the set of transitive parents and the class or trait itself must have different names.<sup id="fnref:overload" role="doc-noteref"><a href="#fn:overload" class="footnote" rel="footnote">5</a></sup>
This restriction does mean that traits from different sources that
coincidentally use the same name for different purposes cannot be combined
by being part of the set of transitive parents for some new trait or class.</p>

<p>A declaration of  member <code class="language-dafny highlighter-rouge"><span class="n">C</span><span class="o">.</span><span class="n">M</span></code> in a class or trait <em>overrides</em> any other declarations
of the same name (and signature) in a transitive parent. <code class="language-dafny highlighter-rouge"><span class="n">C</span><span class="o">.</span><span class="n">M</span></code> is then called an
override; a declaration that
does not override anything is called an <em>original declaration</em>.</p>

<p>Static members of a trait may not be redeclared;
thus, if there is a body it must be declared in the trait;
the compiler will require a body, though the verifier will not.</p>

<p>Where traits within an extension hierarchy do declare instance members with the same
name (and thus the same signature), some rules apply. Recall that, for methods,
every declaration includes a specification; if no specification is given
explicitly, a default specification applies. Instance method declarations in traits,
however, need not have a body, as a body can be declared in an override.</p>

<p>For a given non-static method M,</p>

<ul>
  <li>A trait or class may not redeclare M if it has a transitive parent that declares M and provides a body.</li>
  <li>A trait may but need not provide a body if all its transitive parents that declare M do not declare a body.</li>
  <li>A trait or class may not have more than one transitive parent that declares M with a body.</li>
  <li>A class that has one or more transitive parents that declare M without a body
and no transitive parent that declares M with a body must itself redeclare M
with a body if it is compiled. (The verifier alone does not require a body.)</li>
  <li>Currently (and under debate), the following restriction applies:
if <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> overrides two (or more) declarations, <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="o">.</span><span class="n">M</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Q</span><span class="o">.</span><span class="n">M</span></code>, then either
<code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="o">.</span><span class="n">M</span></code> must override <code class="language-dafny highlighter-rouge"><span class="n">Q</span><span class="o">.</span><span class="n">M</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">Q</span><span class="o">.</span><span class="n">M</span></code> must override <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="o">.</span><span class="n">M</span></code>.</li>
</ul>

<p>The last restriction above is the current implementation. It effectively limits
inheritance of a method M to a single chain of declarations and does not
permit mixins.</p>

<p>Each of any method declarations explicitly or implicitly
includes a specification. In simple cases, those syntactically separate
specifications will be copies of each other (up to renaming to take account
of differing formal parameter names). However they need not be. The rule is
that the specifications of M in a given class or trait must be <em>as strong as</em>
Ms specifications in a transitive parent.
Here <em>as strong as</em>  means that it
must be permitted to call the subtypes M in the context of the supertypes M.
Stated differently, where P and C are a parent trait and a child class or trait,
respectively, then, under the precondition of <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="o">.</span><span class="n">M</span></code>,</p>

<ul>
  <li>C.Ms <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause must be implied by P.Ms <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause</li>
  <li>C.Ms <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause must imply P.Ms <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause</li>
  <li>C.Ms <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> set must be a subset of P.Ms <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> set</li>
  <li>C.Ms <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> set must be a subset of P.Ms <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> set</li>
  <li>C.Ms <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> expression must be smaller than or equal to P.Ms <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> expression</li>
</ul>

<p>Non-static const and field declarations are also inherited from parent traits.
These may not be redeclared in extending traits and classes.
However, a trait need not initialize a const field with a value.
The class that extends a trait that declares such a const field without an
initializer can initialize the field in a constructor.
If the declaring trait does give
an initial value in the declaration, the extending class or trait may not either
redeclare the field or give it a value in a constructor.</p>

<p>When names are inherited from multiple traits, they must be different.
If two traits declare a common name (even with the same signature),
they cannot both be extendees of the same class or trait.</p>

<h4 id="593-example-of-traits">5.9.3. Example of traits</h4>
<p>As an example, the following trait represents movable geometric shapes:
<!-- %check-verify %save Shape.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">trait</span> <span class="n">Shape</span> <span class="kr">extends</span> <span class="kt">object</span>
<span class="p">{</span>
  <span class="kr">function</span> <span class="n">Width</span><span class="p">()</span><span class="o">:</span> <span class="kt">real</span>
    <span class="kr">reads</span> <span class="kr">this</span>
    <span class="kr">decreases</span> <span class="mi">1</span>
  <span class="kr">method</span> <span class="n">Move</span><span class="p">(</span><span class="n">dx</span><span class="o">:</span> <span class="kt">real</span><span class="p">,</span> <span class="n">dy</span><span class="o">:</span> <span class="kt">real</span><span class="p">)</span>
    <span class="kr">modifies</span> <span class="kr">this</span>
  <span class="kr">method</span> <span class="n">MoveH</span><span class="p">(</span><span class="n">dx</span><span class="o">:</span> <span class="kt">real</span><span class="p">)</span>
    <span class="kr">modifies</span> <span class="kr">this</span>
  <span class="p">{</span>
    <span class="n">Move</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Members <code class="language-dafny highlighter-rouge"><span class="n">Width</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Move</span></code> are <em>abstract</em> (that is, body-less) and can
be implemented differently by different classes that extend the trait.
The implementation of method <code class="language-dafny highlighter-rouge"><span class="n">MoveH</span></code> is given in the trait and thus
is used by all classes that extend <code class="language-dafny highlighter-rouge"><span class="n">Shape</span></code>.  Here are two classes
that each extend <code class="language-dafny highlighter-rouge"><span class="n">Shape</span></code>:
<!-- %check-verify %use Shape.tmp %save UnitSquare.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">UnitSquare</span> <span class="kr">extends</span> <span class="n">Shape</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="kt">real</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">real</span>
  <span class="kr">function</span> <span class="n">Width</span><span class="p">()</span><span class="o">:</span> <span class="kt">real</span>
    <span class="kr">decreases</span> <span class="mi">0</span>
  <span class="p">{</span>  <span class="c1">// note the empty reads clause</span>
    <span class="mf">1.0</span>
  <span class="p">}</span>
  <span class="kr">method</span> <span class="n">Move</span><span class="p">(</span><span class="n">dx</span><span class="o">:</span> <span class="kt">real</span><span class="p">,</span> <span class="n">dy</span><span class="o">:</span> <span class="kt">real</span><span class="p">)</span>
    <span class="kr">modifies</span> <span class="kr">this</span>
  <span class="p">{</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="n">LowerRightTriangle</span> <span class="kr">extends</span> <span class="n">Shape</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">xNW</span><span class="o">:</span> <span class="kt">real</span><span class="p">,</span> <span class="n">yNW</span><span class="o">:</span> <span class="kt">real</span><span class="p">,</span> <span class="n">xSE</span><span class="o">:</span> <span class="kt">real</span><span class="p">,</span> <span class="n">ySE</span><span class="o">:</span> <span class="kt">real</span>
  <span class="kr">function</span> <span class="n">Width</span><span class="p">()</span><span class="o">:</span> <span class="kt">real</span>
    <span class="kr">reads</span> <span class="kr">this</span>
    <span class="kr">decreases</span> <span class="mi">0</span>
  <span class="p">{</span>
    <span class="n">xSE</span> <span class="o">-</span> <span class="n">xNW</span>
  <span class="p">}</span>
  <span class="kr">method</span> <span class="n">Move</span><span class="p">(</span><span class="n">dx</span><span class="o">:</span> <span class="kt">real</span><span class="p">,</span> <span class="n">dy</span><span class="o">:</span> <span class="kt">real</span><span class="p">)</span>
    <span class="kr">modifies</span> <span class="kr">this</span>
  <span class="p">{</span>
    <span class="n">xNW</span><span class="p">,</span> <span class="n">yNW</span><span class="p">,</span> <span class="n">xSE</span><span class="p">,</span> <span class="n">ySE</span> <span class="o">:=</span> <span class="n">xNW</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">yNW</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="n">xSE</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ySE</span> <span class="o">+</span> <span class="n">dy</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note that the classes can declare additional members, that they supply
implementations for the abstract members of the trait,
that they repeat the member signatures, and that they are responsible
for providing their own member specifications that both strengthen the
corresponding specification in the trait and are satisfied by the
provided body.
Finally, here is some code that creates two class instances and uses
them together as shapes:
<!-- %check-verify %use UnitSquare.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">myShapes</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">A</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">UnitSquare</span><span class="p">;</span>
  <span class="n">myShapes</span> <span class="o">:=</span> <span class="p">[</span><span class="n">A</span><span class="p">];</span>
  <span class="kr">var</span> <span class="n">tri</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">LowerRightTriangle</span><span class="p">;</span>
  <span class="c1">// myShapes contains two Shape values, of different classes</span>
  <span class="n">myShapes</span> <span class="o">:=</span> <span class="n">myShapes</span> <span class="o">+</span> <span class="p">[</span><span class="n">tri</span><span class="p">];</span>
  <span class="c1">// move shape 1 to the right by the width of shape 0</span>
  <span class="n">myShapes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">MoveH</span><span class="p">(</span><span class="n">myShapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Width</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<!--PDF NEWPAGE-->
<h3 id="sec-array-type">5.10. Array types (<a href="#g-array-type">grammar</a>)</h3>

<p>Dafny supports mutable fixed-length <em>array types</em> of any positive
dimension.  Array types are (heap-based) reference types.</p>

<p><code class="language-dafny highlighter-rouge"><span class="n">arrayToken</span></code> is a kind of <a href="#sec-reserved-words">reserved token</a>,
such as <code class="language-dafny highlighter-rouge"><span class="kt">array</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">array?</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">array2</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">array2?</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">array3</span></code>, and so on (but not <code class="language-dafny highlighter-rouge"><span class="n">array1</span></code>).
The type parameter suffix giving the element type can be omitted if the element type can be inferred, though in that case it is likely that the <code class="language-dafny highlighter-rouge"><span class="n">arrayToken</span></code> itself is also
inferrable and can be omitted.</p>

<h4 id="5101-one-dimensional-arrays">5.10.1. One-dimensional arrays</h4>

<p>A one-dimensional array of <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> elements may be initialized by
any expression that returns a value of the desired type.
Commonly, <a href="#sec-array-allocation">array allocation expressions</a> are used.
Some examples are shown here:
<!-- %check-verify %options --relax-definite-assignment --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
  <span class="kr">var</span> <span class="n">b</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
  <span class="kr">var</span> <span class="n">c</span><span class="o">:</span> <span class="kt">array</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">T</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The initial values of the array elements are arbitrary values of type
<code class="language-dafny highlighter-rouge"><span class="n">T</span></code>.
A one-dimensional array value can also be assigned using an ordered list of expressions enclosed in square brackets, as follows:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">T</span><span class="p">[]</span> <span class="p">[</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span><span class="p">,</span> <span class="n">t4</span><span class="p">];</span>
</code></pre></div></div>
<p>The initialization can also use an expression that returns a function of type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span> <span class="o">-&gt;</span> <span class="n">T</span></code>:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">](</span><span class="n">i</span> <span class="o">=&gt;</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
</code></pre></div></div>
<p>In fact, the initializer can simply be a function name for the right type of function:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">](</span><span class="n">Square</span><span class="p">);</span>
</code></pre></div></div>

<p>The length of an array is retrieved using the immutable <code class="language-dafny highlighter-rouge"><span class="n">Length</span></code>
member.  For example, the array allocated with <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">];</span></code> satisfies:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">==</span> <span class="n">n</span>
</code></pre></div></div>
<p>Once an array is allocated, its length cannot be changed.</p>

<p>For any integer-based numeric <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> in the range <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span></code>,
the <em>array selection</em> expression <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></code> retrieves element <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> (that
is, the element preceded by <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> elements in the array).  The
element stored at <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> can be changed to a value <code class="language-dafny highlighter-rouge"><span class="n">t</span></code> using the array
update statement:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">t</span><span class="p">;</span>
</code></pre></div></div>

<p>Caveat: The type of the array created by <code class="language-dafny highlighter-rouge"><span class="kr">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span></code> is
<code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>.  A mistake that is simple to make and that can lead to
befuddlement is to write <code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> instead of <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> after <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code>.
For example, consider the following:
<!-- %check-resolve Types.17.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">b</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
  <span class="kr">var</span> <span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  <span class="c1">// resolution error</span>
  <span class="kr">var</span> <span class="n">d</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">array</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  <span class="c1">// resolution error</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The first statement allocates an array of type <code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>, but of
unknown length.  The second allocates an array of type
<code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span></code> of length <code class="language-dafny highlighter-rouge"><span class="n">n</span></code>, that is, an array that holds <code class="language-dafny highlighter-rouge"><span class="n">n</span></code>
values of type <code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>.  The third statement allocates an
array of type <code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> and then attempts to invoke an anonymous
constructor on this array, passing argument <code class="language-dafny highlighter-rouge"><span class="n">n</span></code>.  Since <code class="language-dafny highlighter-rouge"><span class="kt">array</span></code> has no
constructors, let alone an anonymous constructor, this statement
gives rise to an error.  If the type-parameter list is omitted for a
type that expects type parameters, Dafny will attempt to fill these
in, so as long as the <code class="language-dafny highlighter-rouge"><span class="kt">array</span></code> type parameter can be inferred, it is
okay to leave off the <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> in the fourth statement above.  However,
as with the third statement, <code class="language-dafny highlighter-rouge"><span class="kt">array</span></code> has no anonymous constructor, so
an error message is generated.</p>

<h4 id="sec-array-to-seq">5.10.2. Converting arrays to sequences</h4>

<p>One-dimensional arrays support operations that convert a stretch of
consecutive elements into a sequence.  For any array <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> of type
<code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>, integer-based numeric bounds <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> satisfying
<code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span></code>, noting that bounds can equal the arrays length,
the following operations each yields a
<code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>:</p>

<table>
  <thead>
    <tr>
      <th>expression</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span></code></td>
      <td>subarray conversion to sequence</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="p">]</span></code></td>
      <td>drop</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span></code></td>
      <td>take</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="p">]</span></code></td>
      <td>array conversion to sequence</td>
    </tr>
  </tbody>
</table>

<p>The expression <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span></code> takes the first <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> elements of the array,
then drops the first <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> elements thereof and returns what remains as
a sequence, with length <code class="language-dafny highlighter-rouge"><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span></code>.
The other operations are special instances of the first.  If <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> is
omitted, it defaults to <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> and if <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> is omitted, it defaults to
<code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="o">.</span><span class="n">Length</span></code>.
In the last operation, both <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> have been omitted, thus
<code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="p">]</span></code> returns the sequence consisting of all the array elements of
<code class="language-dafny highlighter-rouge"><span class="n">a</span></code>.</p>

<p>The subarray operations are especially useful in specifications.  For
example, the loop invariant of a binary search algorithm that uses
variables <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> to delimit the subarray where the search <code class="language-dafny highlighter-rouge"><span class="n">key</span></code>
may still be found can be expressed as follows:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">key</span> <span class="o">!</span><span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="n">lo</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">!</span><span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="n">hi</span><span class="o">..</span><span class="p">]</span>
</code></pre></div></div>
<p>Another use is to say that a certain range of array elements have not
been changed since the beginning of a method:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span> <span class="o">==</span> <span class="kr">old</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">hi</span><span class="p">])</span>
</code></pre></div></div>
<p>or since the beginning of a loop:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ghost</span> <span class="kr">var</span> <span class="n">prevElements</span> <span class="o">:=</span> <span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="p">];</span>
<span class="kr">while</span> <span class="c1">// ...</span>
  <span class="kr">invariant</span> <span class="n">a</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span> <span class="o">==</span> <span class="n">prevElements</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note that the type of <code class="language-dafny highlighter-rouge"><span class="n">prevElements</span></code> in this example is <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>, if
<code class="language-dafny highlighter-rouge"><span class="n">a</span></code> has type <code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>.</p>

<p>A final example of the subarray operation lies in expressing that an
arrays elements are a permutation of the arrays elements at the
beginning of a method, as would be done in most sorting algorithms.
Here, the subarray operation is combined with the sequence-to-multiset
conversion:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">multiset</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="p">])</span> <span class="o">==</span> <span class="kt">multiset</span><span class="p">(</span><span class="kr">old</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="p">]))</span>
</code></pre></div></div>

<h4 id="sec-multi-dimensional-arrays">5.10.3. Multi-dimensional arrays</h4>

<p>An array of 2 or more dimensions is mostly like a one-dimensional
array, except that <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> takes more length arguments (one for each
dimension), and the array selection expression and the array update
statement take more indices.  For example:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">matrix</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">];</span>
<span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">:=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">];</span>
</code></pre></div></div>
<p>create a 2-dimensional array whose dimensions have lengths <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> and
<code class="language-dafny highlighter-rouge"><span class="n">n</span></code>, respectively, and then swaps the elements at <code class="language-dafny highlighter-rouge"><span class="n">i</span><span class="p">,</span><span class="n">j</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="p">,</span><span class="n">y</span></code>.
The type of <code class="language-dafny highlighter-rouge"><span class="n">matrix</span></code> is <code class="language-dafny highlighter-rouge"><span class="kt">array2</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>, and similarly for
higher-dimensional arrays (<code class="language-dafny highlighter-rouge"><span class="kt">array3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="kt">array4</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>, etc.).  Note,
however, that there is no type <code class="language-dafny highlighter-rouge"><span class="n">array0</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>, and what could have been
<code class="language-dafny highlighter-rouge"><span class="n">array1</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> is actually named just <code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>. (Accordingly, <code class="language-dafny highlighter-rouge"><span class="n">array0</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">array1</span></code> are just
normal identifiers, not type names.)</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> operation above requires <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> to be non-negative
integer-based numerics.  These lengths can be retrieved using the
immutable fields <code class="language-dafny highlighter-rouge"><span class="n">Length0</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Length1</span></code>.  For example, the following
holds for the array created above:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">matrix</span><span class="o">.</span><span class="n">Length0</span> <span class="o">==</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">Length1</span> <span class="o">==</span> <span class="n">n</span>
</code></pre></div></div>
<p>Higher-dimensional arrays are similar (<code class="language-dafny highlighter-rouge"><span class="n">Length0</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">Length1</span></code>,
<code class="language-dafny highlighter-rouge"><span class="n">Length2</span></code>, ).  The array selection expression and array update
statement require that the indices are in bounds.  For example, the
swap statement above is <a href="#sec-assertion-batches">well-formed</a> only if:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">Length0</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">Length1</span> <span class="o">&amp;&amp;</span>
<span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">Length0</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">Length1</span>
</code></pre></div></div>

<p>In contrast to one-dimensional arrays, there is no operation to
convert stretches of elements from a multi-dimensional array to a
sequence.</p>

<p>There is however syntax to create a multi-dimensional array value
using a function: see <a href="#sec-array-allocation">Section 9.16</a>.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-iterator-types">5.11. Iterator types (<a href="#g-iterator-type">grammar</a>)</h3>

<p>See <a href="#sec-iterator-specification">Section 7.5</a> for a description of iterator specifications.</p>

<p>An <em>iterator</em> provides a programming abstraction for writing code that
iteratively returns elements.  These CLU-style iterators are
<em>co-routines</em> in the sense that they keep track of their own program
counter and control can be transferred into and out of the iterator
body.</p>

<p>An iterator is declared as follows:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">iterator</span> <span class="n">Iter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="err">_</span><span class="ow">in</span><span class="o">-</span><span class="n">params_</span><span class="p">)</span> <span class="kr">yields</span> <span class="p">(</span><span class="err">_</span><span class="kr">yield</span><span class="o">-</span><span class="n">params_</span><span class="p">)</span>
  <span class="err">_</span><span class="n">specification_</span>
<span class="p">{</span>
  <span class="err">_</span><span class="n">body_</span>
<span class="p">}</span>
</code></pre></div></div>
<p>where <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is a list of type parameters (as usual, if there are no type
parameters, <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> is omitted). This declaration gives rise to a
reference type with the same name, <code class="language-dafny highlighter-rouge"><span class="n">Iter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>. In the signature,
in-parameters and yield-parameters are the iterators analog of a
methods in-parameters and out-parameters. The difference is that the
out-parameters of a method are returned to a caller just once, whereas
the yield-parameters of an iterator are returned each time the iterator
body performs a <code class="language-dafny highlighter-rouge"><span class="kr">yield</span></code>. The body consists of statements, like in a
method body, but with the availability also of <code class="language-dafny highlighter-rouge"><span class="kr">yield</span></code> statements.</p>

<p>From the perspective of an iterator client, the <code class="language-dafny highlighter-rouge"><span class="kr">iterator</span></code> declaration
can be understood as generating a class <code class="language-dafny highlighter-rouge"><span class="n">Iter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> with various
members, a simplified version of which is described next.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">Iter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> class contains an anonymous constructor whose parameters
are the iterators in-parameters:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">Valid</span><span class="p">()</span>
<span class="kr">constructor</span> <span class="p">(</span><span class="err">_</span><span class="ow">in</span><span class="o">-</span><span class="n">params_</span><span class="p">)</span>
  <span class="kr">modifies</span> <span class="kr">this</span>
  <span class="kr">ensures</span> <span class="n">Valid</span><span class="p">()</span>
</code></pre></div></div>
<p>An iterator is created using <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> and this anonymous constructor.
For example, an iterator willing to return ten consecutive integers
from <code class="language-dafny highlighter-rouge"><span class="n">start</span></code> can be declared as follows:
<!-- %check-verify %save Gen.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">iterator</span> <span class="n">Gen</span><span class="p">(</span><span class="n">start</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">yields</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">yield</span> <span class="kr">ensures</span> <span class="o">|</span><span class="n">xs</span><span class="o">|</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">start</span> <span class="o">+</span> <span class="o">|</span><span class="n">xs</span><span class="o">|</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="kr">invariant</span> <span class="o">|</span><span class="n">xs</span><span class="o">|</span> <span class="o">==</span> <span class="n">i</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
    <span class="kr">yield</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>An instance of this iterator is created using
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">iter</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Gen</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
</code></pre></div></div>
<p>It is used like this:
<!-- %check-verify %use Gen.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Gen</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
  <span class="kr">while</span> <span class="kc">true</span>
    <span class="kr">invariant</span> <span class="n">i</span><span class="o">.</span><span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="kr">fresh</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="err">_</span><span class="kr">new</span><span class="p">)</span>
    <span class="kr">decreases</span> <span class="mi">10</span> <span class="o">-</span> <span class="o">|</span><span class="n">i</span><span class="o">.</span><span class="n">xs</span><span class="o">|</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">i</span><span class="o">.</span><span class="n">MoveNext</span><span class="p">();</span>
    <span class="kr">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span><span class="kr">break</span><span class="p">;</span> <span class="p">}</span>
    <span class="kr">print</span> <span class="n">i</span><span class="o">.</span><span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The predicate <code class="language-dafny highlighter-rouge"><span class="n">Valid</span><span class="p">()</span></code> says when the iterator is in a state where one
can attempt to compute more elements.  It is a postcondition of the
constructor and occurs in the specification of the <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code> member:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">MoveNext</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">more</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">Valid</span><span class="p">()</span>
  <span class="kr">modifies</span> <span class="kr">this</span>
  <span class="kr">ensures</span> <span class="n">more</span> <span class="o">==&gt;</span> <span class="n">Valid</span><span class="p">()</span>
</code></pre></div></div>
<p>Note that the iterator remains valid as long as <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code> returns
<code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>.  Once <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code> returns <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>, the <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code> method can no
longer be called.  Note, the client is under no obligation to keep
calling <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code> until it returns <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>, and the body of the
iterator is allowed to keep returning elements forever.</p>

<p>The in-parameters of the iterator are stored in immutable fields of
the iterator class.  To illustrate in terms of the example above, the
iterator class <code class="language-dafny highlighter-rouge"><span class="n">Gen</span></code> contains the following field:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">start</span><span class="o">:</span> <span class="kt">int</span>
</code></pre></div></div>
<p>The yield-parameters also result in members of the iterator class:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span>
</code></pre></div></div>
<p>These fields are set by the <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code> method.  If <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code> returns
<code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>, the latest yield values are available in these fields and the
client can read them from there.</p>

<p>To aid in writing specifications, the iterator class also contains
ghost members that keep the history of values returned by
<code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code>.  The names of these ghost fields follow the names of the
yield-parameters with an <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> appended to the name (to suggest
plural).  Name checking rules make sure these names do not give rise
to ambiguities.  The iterator class for <code class="language-dafny highlighter-rouge"><span class="n">Gen</span></code> above thus contains:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ghost</span> <span class="kr">var</span> <span class="n">xs</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>These history fields are changed automatically by <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code>, but are
not assignable by user code.</p>

<p>Finally, the iterator class contains some special fields for use in
specifications.  In particular, the iterator specification is
recorded in the following immutable fields:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ghost</span> <span class="kr">var</span> <span class="err">_</span><span class="kr">reads</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span>
<span class="kr">ghost</span> <span class="kr">var</span> <span class="err">_</span><span class="kr">modifies</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span>
<span class="kr">ghost</span> <span class="kr">var</span> <span class="err">_</span><span class="n">decreases0</span><span class="o">:</span> <span class="n">T0</span>
<span class="kr">ghost</span> <span class="kr">var</span> <span class="err">_</span><span class="n">decreases1</span><span class="o">:</span> <span class="n">T1</span>
<span class="c1">// ...</span>
</code></pre></div></div>
<p>where there is a <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="kr">decreases</span><span class="p">(</span></code><em>i</em><code class="language-dafny highlighter-rouge"><span class="p">)</span><span class="o">:</span> <span class="n">T</span><span class="p">(</span></code><em>i</em><code class="language-dafny highlighter-rouge"><span class="p">)</span></code> field for each
component of the iterators <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code>
clause.<sup id="fnref:fn-iterator-field-names" role="doc-noteref"><a href="#fn:fn-iterator-field-names" class="footnote" rel="footnote">6</a></sup>
In addition, there is a field:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ghost</span> <span class="kr">var</span> <span class="err">_</span><span class="kr">new</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>
<p>to which any objects allocated on behalf of the iterator body are
added.  The iterator body is allowed to remove elements from the
<code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="kr">new</span></code> set, but cannot by assignment to <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="kr">new</span></code> add any elements.</p>

<p>Note, in the precondition of the iterator, which is to hold upon
construction of the iterator, the in-parameters are indeed
in-parameters, not fields of <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>.</p>

<p><code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses on iterators have a different meaning than they do on functions and methods.
Iterators may read any memory they like, but because arbitrary code may be executed
whenever they <code class="language-dafny highlighter-rouge"><span class="kr">yield</span></code> control, they need to declare what memory locations must not be modified
by other code in order to maintain correctness.
The contents of an iterators <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses become part of the <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause
of the implicitly created <code class="language-dafny highlighter-rouge"><span class="n">Valid</span><span class="p">()</span></code> predicate.
This means if client code modifies any of this state,
it will not be able to establish the precondition for the iterators <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span><span class="p">()</span></code> method,
and hence the iterator body will never resume if this state is modified.</p>

<p>It is regrettably tricky to use iterators. The language really
ought to have a <code class="language-dafny highlighter-rouge"><span class="n">foreach</span></code> statement to make this easier.
Here is an example showing a definition and use of an iterator.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">iterator</span> <span class="n">Iter</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="kr">yields</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span>
  <span class="kr">yield</span> <span class="kr">ensures</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!</span><span class="ow">in</span> <span class="n">xs</span><span class="p">[</span><span class="o">..|</span><span class="n">xs</span><span class="o">|-</span><span class="mi">1</span><span class="p">]</span>
  <span class="kr">ensures</span> <span class="n">s</span> <span class="o">==</span> <span class="kt">set</span> <span class="n">z</span> <span class="o">|</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">xs</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">s</span><span class="p">;</span>
  <span class="kr">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="p">{})</span>
    <span class="kr">invariant</span> <span class="n">r</span> <span class="o">!!</span> <span class="kt">set</span> <span class="n">z</span> <span class="o">|</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">xs</span>
    <span class="kr">invariant</span> <span class="n">s</span> <span class="o">==</span> <span class="n">r</span> <span class="o">+</span> <span class="kt">set</span> <span class="n">z</span> <span class="o">|</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">xs</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">y</span> <span class="o">:|</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">r</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">!</span><span class="ow">in</span> <span class="n">xs</span><span class="p">;</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">r</span> <span class="o">-</span> <span class="p">{</span><span class="n">y</span><span class="p">},</span> <span class="n">y</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">!</span><span class="ow">in</span> <span class="n">xs</span><span class="p">;</span>
    <span class="kr">yield</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="n">xs</span><span class="p">[</span><span class="o">|</span><span class="n">xs</span><span class="o">|-</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// a lemma to help prove loop invariant</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">UseIterToCopy</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">t</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">s</span> <span class="o">==</span> <span class="n">t</span>
<span class="p">{</span>
  <span class="n">t</span> <span class="o">:=</span> <span class="p">{};</span>
  <span class="kr">var</span> <span class="n">m</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Iter</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="kr">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="kr">invariant</span> <span class="n">m</span><span class="o">.</span><span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="kr">fresh</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="err">_</span><span class="kr">new</span><span class="p">)</span>
    <span class="kr">invariant</span> <span class="n">t</span> <span class="o">==</span> <span class="kt">set</span> <span class="n">z</span> <span class="o">|</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">xs</span>
    <span class="kr">decreases</span> <span class="n">s</span> <span class="o">-</span> <span class="n">t</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">more</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">MoveNext</span><span class="p">();</span>
    <span class="kr">if</span> <span class="p">(</span><span class="o">!</span><span class="n">more</span><span class="p">)</span> <span class="p">{</span> <span class="kr">break</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span> <span class="o">+</span> <span class="p">{</span><span class="n">m</span><span class="o">.</span><span class="n">x</span><span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The design of iterators is <a href="https://github.com/dafny-lang/dafny/issues/2440">under discussion and may change</a>.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-arrow-types">5.12. Arrow types (<a href="#g-arrow-type">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="err">~</span><span class="o">&gt;</span> <span class="kt">bool</span>
<span class="p">()</span> <span class="o">--&gt;</span> <span class="kt">object?</span>
</code></pre></div></div>

<p>Functions are first-class values in Dafny. The types of function values
are called <em>arrow types</em> (aka, <em>function types</em>).
Arrow types have the form <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">U</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">TT</span></code> is a (possibly empty)
comma-delimited list of types and <code class="language-dafny highlighter-rouge"><span class="n">U</span></code> is a type.
<code class="language-dafny highlighter-rouge"><span class="n">TT</span></code> is called the functions <em>domain type(s)</em> and <code class="language-dafny highlighter-rouge"><span class="n">U</span></code> is its
<em>range type</em>.  For example, the type of a function
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">arr</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="kt">real</span>
  <span class="kr">requires</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1000</span>
  <span class="kr">reads</span> <span class="n">arr</span>
</code></pre></div></div>
<p>is <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">)</span> <span class="err">~</span><span class="o">&gt;</span> <span class="kt">real</span></code>.</p>

<p>As seen in the example above, the functions that are values of a type
<code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">U</span></code> can have a precondition (as indicated by the <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause)
and can read values in the heap (as indicated by the <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause).
As described in <a href="#sec-arrow-subset-types">Section 5.6.3.3</a>,</p>

<ul>
  <li>the subset type <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">U</span></code> denotes partial (but heap-independent) functions</li>
  <li>and the subset type <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">TT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span></code> denotes total functions.</li>
</ul>

<p>A function declared without a <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause is known by the type
checker to be a partial function. For example, the type of
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span><span class="o">:</span> <span class="kt">real</span>
  <span class="kr">requires</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1000</span>
</code></pre></div></div>
<p>is <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="kt">real</span></code>.
Similarly, a function declared with neither a <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause nor a
<code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause is known by the type checker to be a total function.
For example, the type of
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span><span class="o">:</span> <span class="kt">real</span>
</code></pre></div></div>
<p>is <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">real</span></code>.
In addition to functions declared by name, Dafny also supports anonymous
functions by means of <em>lambda expressions</em> (see <a href="#sec-lambda-expression">Section 9.13</a>).</p>

<p>To simplify the appearance of the basic case where a functions
domain consists of a list of exactly one non-function, non-tuple type, the parentheses around
the domain type can be dropped in this case. For example, you may
write just <code class="language-dafny highlighter-rouge"><span class="n">T</span> <span class="o">-&gt;</span> <span class="n">U</span></code> for a total arrow type.
This innocent simplification requires additional explanation in the
case where that one type is a tuple type, since tuple types are also
written with enclosing parentheses.
If the function takes a single argument that is a tuple, an additional
set of parentheses is needed.  For example, the function
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">G</span><span class="p">(</span><span class="n">pair</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">))</span><span class="o">:</span> <span class="kt">real</span>
</code></pre></div></div>
<p>has type <code class="language-dafny highlighter-rouge"><span class="p">((</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kt">real</span></code>.  Note the necessary double
parentheses.  Similarly, a function that takes no arguments is
different from one that takes a 0-tuple as an argument.  For instance,
the functions
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">NoArgs</span><span class="p">()</span><span class="o">:</span> <span class="kt">real</span>
<span class="kr">function</span> <span class="n">Z</span><span class="p">(</span><span class="n">unit</span><span class="o">:</span> <span class="p">())</span><span class="o">:</span> <span class="kt">real</span>
</code></pre></div></div>
<p>have types <code class="language-dafny highlighter-rouge"><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">real</span></code> and <code class="language-dafny highlighter-rouge"><span class="p">(())</span> <span class="o">-&gt;</span> <span class="kt">real</span></code>, respectively.</p>

<p>The function arrows are right associative.
For example, <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">C</span></code> means <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">B</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="p">)</span></code>, whereas
the other association requires explicit parentheses: <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">C</span></code>.
As another example, <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span> <span class="o">--&gt;</span> <span class="n">C</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">D</span></code> means
<code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">B</span> <span class="o">--&gt;</span> <span class="p">(</span><span class="n">C</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">D</span><span class="p">))</span></code>.</p>

<p>Note that the receiver parameter of a named function is not part of
the type.  Rather, it is used when looking up the function and can
then be thought of as being captured into the function definition.
For example, suppose function <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> above is declared in a class <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> and
that <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> references an object of type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>; then, the following is type
correct:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">real</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="n">F</span><span class="p">;</span>
</code></pre></div></div>
<p>whereas it would have been incorrect to have written something like:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">f'</span><span class="o">:</span> <span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">real</span> <span class="o">:=</span> <span class="n">F</span><span class="p">;</span>  <span class="c1">// not correct</span>
</code></pre></div></div>

<p>The arrow types themselves do not divide a functions parameters into ghost
versus non-ghost. Instead, a function used as a first-class value is
considered to be ghost if either the function or any of its arguments
is ghost. The following example program illustrates:
<!-- %check-resolve Types.18.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="kr">ghost</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">{</span>
  <span class="n">x</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Example</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">g</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">h</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="n">f</span> <span class="o">:=</span> <span class="n">F</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="n">F</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
  <span class="n">g</span> <span class="o">:=</span> <span class="n">F</span><span class="p">;</span> <span class="c1">// error: tries to assign ghost to non-ghost</span>
  <span class="n">h</span> <span class="o">:=</span> <span class="n">F</span><span class="p">;</span> <span class="c1">// error: wrong arity (and also tries to assign ghost to non-ghost)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In addition to its type signature, each function value has three properties,
described next.</p>

<p>Every function implicitly takes the heap as an argument.  No function
ever depends on the <em>entire</em> heap, however.  A property of the
function is its declared upper bound on the set of heap locations it
depends on for a given input.  This lets the verifier figure out that
certain heap modifications have no effect on the value returned by a
certain function.  For a function <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">:</span> <span class="n">T</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">U</span></code> and a value <code class="language-dafny highlighter-rouge"><span class="n">t</span></code> of type
<code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, the dependency set is denoted <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">reads</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></code> and has type
<code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span></code>.</p>

<p>The second property of functions stems from the fact that every function
is potentially <em>partial</em>. In other words, a property of a function is its
<em>precondition</em>. For a function <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">:</span> <span class="n">T</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">U</span></code>, the precondition of <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> for a
parameter value <code class="language-dafny highlighter-rouge"><span class="n">t</span></code> of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is denoted <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">requires</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></code> and has type
<code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code>.</p>

<p>The third property of a function is more obviousthe functions
body.  For a function <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">:</span> <span class="n">T</span> <span class="err">~</span><span class="o">&gt;</span> <span class="n">U</span></code>, the value that the function yields
for an input <code class="language-dafny highlighter-rouge"><span class="n">t</span></code> of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is denoted <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></code> and has type <code class="language-dafny highlighter-rouge"><span class="n">U</span></code>.</p>

<p>Note that <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">reads</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">requires</span></code> are themselves functions.
Without loss of generality, suppose <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> is defined as:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span><span class="o">:</span> <span class="n">U</span>
  <span class="kr">reads</span> <span class="n">R</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">body</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>where <code class="language-dafny highlighter-rouge"><span class="n">P</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">R</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">body</span></code> are declared as:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">P</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span>
<span class="kr">function</span> <span class="n">R</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span>
<span class="kr">function</span> <span class="n">body</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span><span class="o">:</span> <span class="n">U</span>
</code></pre></div></div>
<p>Then, <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">reads</span></code> is a function of type <code class="language-dafny highlighter-rouge"><span class="n">T</span> <span class="err">~</span><span class="o">&gt;</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">object?</span><span class="o">&gt;</span></code>
whose <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> properties are given by the definition:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">f</span><span class="o">.</span><span class="kr">reads</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span>
  <span class="kr">reads</span> <span class="n">R</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">R</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">requires</span></code> is a function of type <code class="language-dafny highlighter-rouge"><span class="n">T</span> <span class="err">~</span><span class="o">&gt;</span> <span class="kt">bool</span></code> whose <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> and
<code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> properties are given by the definition:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">f_requires</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="kc">true</span>
  <span class="kr">reads</span> <span class="kr">if</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">then</span> <span class="n">R</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">else</span> <span class="o">*</span>
<span class="p">{</span>
  <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>where <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> is a notation to indicate that any memory location can
be read, but is not valid Dafny syntax.</p>

<p>In these examples, if <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> instead had type <code class="language-dafny highlighter-rouge"><span class="n">T</span> <span class="o">--&gt;</span> <span class="n">U</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">T</span> <span class="o">-&gt;</span> <span class="n">U</span></code>,
then the type of <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">reads</span></code> is <code class="language-dafny highlighter-rouge"><span class="n">T</span> <span class="o">-&gt;</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">object?</span><span class="o">&gt;</span></code> and the type
of <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">requires</span></code> is <code class="language-dafny highlighter-rouge"><span class="n">T</span> <span class="o">-&gt;</span> <span class="kt">bool</span></code>.</p>

<p>Dafny also supports anonymous functions by means of
<em>lambda expressions</em>. See <a href="#sec-lambda-expression">Section 9.13</a>.</p>

<!--PDF NEWPAGE-->
<h3 id="sec-tuple-types">5.13.  Tuple types</h3>
<pre><code class="language-grammar">TupleType = "(" [ [ "ghost" ] Type { "," [ "ghost" ] Type } ] ")"
</code></pre>

<p>Dafny builds in record types that correspond to tuples and gives these
a convenient special syntax, namely parentheses.  For example, for what
might have been declared as
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Pair</span><span class="p">(</span><span class="mi">0</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span> <span class="n">U</span><span class="p">)</span>
</code></pre></div></div>
<p>Dafny provides the type <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span></code> and the constructor <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span></code>, as
if the datatypes name were  (i.e., an empty string)
and its type arguments are given in
round parentheses, and as if the constructor name were the empty string.
Note that
the destructor names are <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> and <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code>, which are legal identifier names
for members.  For an example showing the use of a tuple destructor, here
is a property that holds of 2-tuples (that is, <em>pairs</em>):
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(){</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span><span class="o">.</span><span class="mi">1</span> <span class="o">==</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dafny declares <em>n</em>-tuples where <em>n</em> is 0 or 2 or more.  There are no
1-tuples, since parentheses around a single type or a single value have
no semantic meaning.  The 0-tuple type, <code class="language-dafny highlighter-rouge"><span class="p">()</span></code>, is often known as the
<em>unit type</em> and its single value, also written <code class="language-dafny highlighter-rouge"><span class="p">()</span></code>, is known as <em>unit</em>.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> modifier can be used to mark tuple components as being used for specification only:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">pair</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kr">ghost</span> <span class="kt">int</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kr">ghost</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<!--PDF NEWPAGE-->
<h3 id="sec-datatype">5.14. Algebraic Datatypes (<a href="#g-datatype">grammar</a>)</h3>

<p>Dafny offers two kinds of algebraic datatypes, those defined
inductively (with <code class="language-dafny highlighter-rouge"><span class="kr">datatype</span></code>)  and those defined coinductively (with <code class="language-dafny highlighter-rouge"><span class="kr">codatatype</span></code>).
The salient property of
every datatype is that each value of the type uniquely identifies one
of the datatypes constructors and each constructor is injective in
its parameters.</p>

<h4 id="sec-inductive-datatypes">5.14.1. Inductive datatypes</h4>

<p>The values of inductive datatypes can be seen as finite trees where
the leaves are values of basic types, numeric types, reference types,
coinductive datatypes, or arrow types.  Indeed, values of
inductive datatypes can be compared using Dafnys well-founded
<code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code> ordering.</p>

<p>An inductive datatype is declared as follows:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">D</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="err">_</span><span class="n">Ctors_</span>
</code></pre></div></div>
<p>where <em>Ctors</em> is a nonempty <code class="language-dafny highlighter-rouge"><span class="o">|</span></code>-separated list of
<em>(datatype) constructors</em> for the datatype.  Each constructor has the
form:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code>C(_params_)
</code></pre></div></div>
<p>where <em>params</em> is a comma-delimited list of types, optionally
preceded by a name for the parameter and a colon, and optionally
preceded by the keyword <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code>.  If a constructor has no parameters,
the parentheses after the constructor name may be omitted.  If no
constructor takes a parameter, the type is usually called an
<em>enumeration</em>; for example:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Friends</span> <span class="o">=</span> <span class="n">Agnes</span> <span class="o">|</span> <span class="n">Agatha</span> <span class="o">|</span> <span class="n">Jermaine</span> <span class="o">|</span> <span class="n">Jack</span>
</code></pre></div></div>

<p>For every constructor <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>, Dafny defines a <em>discriminator</em> <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code>, which
is a member that returns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> if and only if the datatype value has
been constructed using <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>.  For every named parameter <code class="language-dafny highlighter-rouge"><span class="n">p</span></code> of a
constructor <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>, Dafny defines a <em>destructor</em> <code class="language-dafny highlighter-rouge"><span class="n">p</span></code>, which is a member
that returns the <code class="language-dafny highlighter-rouge"><span class="n">p</span></code> parameter from the <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> call used to construct the
datatype value; its use requires that <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code> holds.  For example, for
the standard <code class="language-dafny highlighter-rouge"><span class="n">List</span></code> type
<!-- %check-resolve %save List.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Nil</span> <span class="o">|</span> <span class="n">Cons</span><span class="p">(</span><span class="n">head</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div></div>
<p>the following holds:
<!-- %check-verify %use List.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)</span><span class="o">.</span><span class="n">Cons?</span> <span class="o">&amp;&amp;</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note that the expression
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">head</span>
</code></pre></div></div>
<p>is not <a href="#sec-assertion-batches">well-formed</a> by itself, since <code class="language-dafny highlighter-rouge"><span class="n">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)</span><span class="o">.</span><span class="n">tail</span></code> does not necessarily satisfy
<code class="language-dafny highlighter-rouge"><span class="n">Cons?</span></code>.</p>

<p>A constructor can have the same name as
the enclosing datatype; this is especially useful for
single-constructor datatypes, which are often called
<em>record types</em>.  For example, a record type for black-and-white pixels
might be represented as follows:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Pixel</span> <span class="o">=</span> <span class="n">Pixel</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">on</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></div></div>

<p>To call a constructor, it is usually necessary only to mention the
name of the constructor, but if this is ambiguous, it is always
possible to qualify the name of constructor by the name of the
datatype.  For example, <code class="language-dafny highlighter-rouge"><span class="n">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)</span></code> above can be written
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">List</span><span class="o">.</span><span class="n">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">List</span><span class="o">.</span><span class="n">Nil</span><span class="p">)</span>
</code></pre></div></div>

<p>As an alternative to calling a datatype constructor explicitly, a
datatype value can be constructed as a change in one parameter from a
given datatype value using the <em>datatype update</em> expression.  For any
<code class="language-dafny highlighter-rouge"><span class="n">d</span></code> whose type is a datatype that includes a constructor <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> that has
a parameter (destructor) named <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, and any expression <code class="language-dafny highlighter-rouge"><span class="n">t</span></code>
of type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">f</span> <span class="o">:=</span> <span class="n">t</span><span class="p">)</span>
</code></pre></div></div>
<p>constructs a value like <code class="language-dafny highlighter-rouge"><span class="n">d</span></code> but whose <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> parameter is <code class="language-dafny highlighter-rouge"><span class="n">t</span></code>.  The
operation requires that <code class="language-dafny highlighter-rouge"><span class="n">d</span></code> satisfies <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code>.  For example, the
following equality holds:
<!-- %check-verify %use List.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(){</span>
  <span class="kr">assert</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">tail</span> <span class="o">:=</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Nil</span><span class="p">))</span> <span class="o">==</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Nil</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The datatype update expression also accepts multiple field
names, provided these are distinct. For example, a node of some
inductive datatype for trees may be updated as follows:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">node</span><span class="o">.</span><span class="p">(</span><span class="n">left</span> <span class="o">:=</span> <span class="n">L</span><span class="p">,</span> <span class="n">right</span> <span class="o">:=</span> <span class="n">R</span><span class="p">)</span>
</code></pre></div></div>

<p>The operator <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code> is defined for two operands of the same datataype.
It means <em>is properly contained in</em>. For example, in the code
<!-- %check-verify Types.19.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">X</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="o">:</span> <span class="n">X</span><span class="p">)</span> <span class="o">|</span> <span class="n">I</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="kr">method</span> <span class="n">comp</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">T</span><span class="p">(</span><span class="n">I</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="kr">var</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">I</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">z</span> <span class="o">:=</span> <span class="n">I</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="o">!</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// FAILS</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is a datatype value that holds a <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> variant, which holds a <code class="language-dafny highlighter-rouge"><span class="n">I</span></code> variant, which holds an integer <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code>.
The value <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">.</span><span class="n">t</span></code> is a portion of the datatype structure denoted by <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>, so <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span></code> is true.
Datatype values are immutable mathematical values, so the value of <code class="language-dafny highlighter-rouge"><span class="n">y</span></code> is identical to the value of
<code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">.</span><span class="n">t</span></code>, so <code class="language-dafny highlighter-rouge"><span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span></code> is true also, even though <code class="language-dafny highlighter-rouge"><span class="n">y</span></code> is constructed from the ground up, rather than as
a portion of <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>. However, <code class="language-dafny highlighter-rouge"><span class="n">z</span></code> is different than either <code class="language-dafny highlighter-rouge"><span class="n">y</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">.</span><span class="n">t</span></code> and consequently <code class="language-dafny highlighter-rouge"><span class="n">z</span> <span class="o">&lt;</span> <span class="n">x</span></code> is not provable.
Furthermore, <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code> does not include <code class="language-dafny highlighter-rouge"><span class="o">==</span></code>, so <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">&lt;</span> <span class="n">x</span></code> is false.</p>

<p>Note that only <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code> is defined; not <code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code>.</p>

<p>Also, <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code> is underspecified. With the above code, one can prove neither <code class="language-dafny highlighter-rouge"><span class="n">z</span> <span class="o">&lt;</span> <span class="n">x</span></code> nor <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span></code> and neither
<code class="language-dafny highlighter-rouge"><span class="n">z</span> <span class="o">&lt;</span> <span class="n">y</span></code> nor <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span></code>. In each pair, though, one or the other is true, so <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span></code> is provable.</p>

<h4 id="sec-coinductive-datatypes">5.14.2. Coinductive datatypes</h4>

<p>Whereas Dafny insists that there is a way to construct every inductive
datatype value from the ground up, Dafny also supports
<em>coinductive datatypes</em>, whose constructors are evaluated lazily, and
hence the language allows infinite structures.
A coinductive datatype is declared
using the keyword <code class="language-dafny highlighter-rouge"><span class="kr">codatatype</span></code>; other than that, it is declared and
used like an inductive datatype.</p>

<p>For example,
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">codatatype</span> <span class="n">IList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Nil</span> <span class="o">|</span> <span class="n">Cons</span><span class="p">(</span><span class="n">head</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">IList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
<span class="kr">codatatype</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">More</span><span class="p">(</span><span class="n">head</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
<span class="kr">codatatype</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">left</span><span class="o">:</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">value</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">right</span><span class="o">:</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div></div>
<p>declare possibly infinite lists (that is, lists that can be either
finite or infinite), infinite streams (that is, lists that are always
infinite), and infinite binary trees (that is, trees where every
branch goes on forever), respectively.</p>

<p>The paper <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/coinduction.pdf">Co-induction Simply</a>, by Leino and
Moskal[@LEINO:Dafny:Coinduction], explains Dafnys implementation and
verification of coinductive types. We capture the key features from that
paper in the following section but the reader is referred to that paper for more
complete details and to supply bibliographic references that are
omitted here.</p>

<h4 id="sec-coinduction">5.14.3. Coinduction</h4>

<p>Mathematical induction is a cornerstone of programming and program
verification. It arises in data definitions (e.g., some algebraic data
structures can be described using induction), it underlies program
semantics (e.g., it explains how to reason about finite iteration and
recursion), and it is used in proofs (e.g., supporting lemmas about
data structures use inductive proofs). Whereas induction deals with
finite things (data, behavior, etc.), its dual, coinduction, deals with
possibly infinite things. Coinduction, too, is important in programming
and program verification: it arises in data definitions (e.g., lazy
data structures), semantics (e.g., concurrency), and proofs (e.g.,
showing refinement in a coinductive big-step semantics). It is thus
desirable to have good support for both induction and coinduction in a
system for constructing and reasoning about programs.</p>

<p>Co-datatypes and co-recursive functions make it possible to use lazily
evaluated data structures (like in Haskell or Agda). <em>Greatest predicates</em>,
defined by greatest fix-points, let programs state properties of such
data structures (as can also be done in, for example, Coq). For the
purpose of writing coinductive proofs in the language, we introduce
greatest and least lemmas. A greatest lemma invokes the coinduction hypothesis
much like an inductive proof invokes the induction hypothesis. Underneath
the hood, our coinductive proofs are actually approached via induction:
greatest and least lemmas provide a syntactic veneer around this approach.</p>

<p>The following example gives a taste of how the coinductive features in
Dafny come together to give straightforward definitions of infinite
matters.
<!-- %check-verify Types.20.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// infinite streams</span>
<span class="kr">codatatype</span> <span class="n">IStream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ICons</span><span class="p">(</span><span class="n">head</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">IStream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>

<span class="c1">// pointwise product of streams</span>
<span class="kr">function</span> <span class="n">Mult</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">IStream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="n">IStream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="n">IStream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span> <span class="n">ICons</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">head</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="n">Mult</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">tail</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">tail</span><span class="p">))</span> <span class="p">}</span>

<span class="c1">// lexicographic order on streams</span>
<span class="kr">greatest</span> <span class="kr">predicate</span> <span class="n">Below</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">IStream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="n">IStream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span> <span class="n">a</span><span class="o">.</span><span class="n">head</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="o">.</span><span class="n">head</span> <span class="o">&amp;&amp;</span>
  <span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">head</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">Below</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">tail</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">tail</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// a stream is Below its Square</span>
<span class="kr">greatest</span> <span class="kr">lemma</span> <span class="n">Theorem_BelowSquare</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">IStream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">Below</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Mult</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
<span class="p">{</span> <span class="kr">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">head</span> <span class="o">&lt;=</span> <span class="n">Mult</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">a</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">Mult</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">head</span> <span class="p">{</span>
    <span class="n">Theorem_BelowSquare</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">tail</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// an incorrect property and a bogus proof attempt</span>
<span class="kr">greatest</span> <span class="kr">lemma</span> <span class="n">NotATheorem_SquareBelow</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">IStream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">Below</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// ERROR</span>
<span class="p">{</span>
  <span class="n">NotATheorem_SquareBelow</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The example defines a type <code class="language-dafny highlighter-rouge"><span class="n">IStream</span></code> of infinite streams, with constructor <code class="language-dafny highlighter-rouge"><span class="n">ICons</span></code> and
destructors <code class="language-dafny highlighter-rouge"><span class="n">head</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">tail</span></code>. Function <code class="language-dafny highlighter-rouge"><span class="n">Mult</span></code> performs pointwise
multiplication on infinite streams of integers, defined using a
co-recursive call (which is evaluated lazily). Greatest predicate <code class="language-dafny highlighter-rouge"><span class="n">Below</span></code> is
defined as a greatest fix-point, which intuitively means that the
co-predicate will take on the value true if the recursion goes on forever
without determining a different value. The greatest lemma states the theorem
<code class="language-dafny highlighter-rouge"><span class="n">Below</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Mult</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span></code>. Its body gives the proof, where the recursive
invocation of the co-lemma corresponds to an invocation of the
coinduction hypothesis.</p>

<p>The proof of the theorem stated by the first co-lemma lends
itself to the following intuitive reading: To prove that <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is below
<code class="language-dafny highlighter-rouge"><span class="n">Mult</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span></code>, check that their heads are ordered and, if the heads are
equal, also prove that the tails are ordered. The second co-lemma states
a property that does not always hold; the verifier is not fooled by the
bogus proof attempt and instead reports the property as unproved.</p>

<p>We argue that these definitions in Dafny are simple enough to level the
playing field between induction (which is familiar) and coinduction
(which, despite being the dual of induction, is often perceived as eerily
mysterious). Moreover, the automation provided by our SMT-based verifier
reduces the tedium in writing coinductive proofs. For example, it
verifies <code class="language-dafny highlighter-rouge"><span class="n">Theorem_BelowSquare</span></code> from the program text given aboveno
additional lemmas or tactics are needed. In fact, as a consequence of the
automatic-induction heuristic in Dafny, the verifier will
automatically verify <code class="language-dafny highlighter-rouge"><span class="n">Theorem_BelowSquare</span></code> even given an empty body.</p>

<p>Just like there are restrictions on when an <em>inductive hypothesis</em> can be
invoked, there are restrictions on how a <em>coinductive</em> hypothesis can be
<em>used</em>. These are, of course, taken into consideration by Dafnys verifier.
For example, as illustrated by the second greatest lemma above, invoking the
coinductive hypothesis in an attempt to obtain the entire proof goal is
futile. (We explain how this works in <a href="#sec-colemmas">the section about greatest lemmas</a>) Our initial experience
with coinduction in Dafny shows it to provide an intuitive, low-overhead
user experience that compares favorably to even the best of todays
interactive proof assistants for coinduction. In addition, the
coinductive features and verification support in Dafny have other
potential benefits. The features are a stepping stone for verifying
functional lazy programs with Dafny. Coinductive features have also
shown to be useful in defining language semantics, as needed to verify
the correctness of a compiler, so this opens the possibility that
such verifications can benefit from SMT automation.</p>

<h5 id="51431-well-founded-functionmethod-definitions">5.14.3.1. Well-Founded Function/Method Definitions</h5>
<p>The Dafny programming language supports functions and methods. A <em>function</em>
in Dafny is a mathematical function (i.e., it is well-defined,
deterministic, and pure), whereas a <em>method</em> is a body of statements that
can mutate the state of the program. A function is defined by its given
body, which is an expression. To ensure that function definitions
are mathematically consistent, Dafny insists that recursive calls be well-founded,
enforced as follows: Dafny computes the call graph of functions. The strongly connected
components within it are <em>clusters</em> of mutually recursive definitions; the clusters are arranged in
a DAG. This stratifies the functions so that a call from one cluster in the DAG to a
lower cluster is allowed arbitrarily. For an intra-cluster call, Dafny prescribes a proof
obligation that is taken through the program verifiers reasoning engine. Semantically,
each function activation is labeled by a <em>rank</em>a lexicographic tuple determined
by evaluating the functions <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause upon invocation of the function. The
proof obligation for an intra-cluster call is thus that the rank of the callee is strictly less
(in a language-defined well-founded relation) than the rank of the caller. Because
these well-founded checks correspond to proving termination of executable code, we
will often refer to them as termination checks. The same process applies to methods.</p>

<p>Lemmas in Dafny are commonly introduced by declaring a method, stating
the property of the lemma in the <em>postcondition</em> (keyword <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code>) of
the method, perhaps restricting the domain of the lemma by also giving a
<em>precondition</em> (keyword <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code>), and using the lemma by invoking
the method. Lemmas are stated, used, and proved as methods, but
since they have no use at run time, such lemma methods are typically
declared as <em>ghost</em>, meaning that they are not compiled into code. The
keyword <code class="language-dafny highlighter-rouge"><span class="kr">lemma</span></code> introduces such a method. Control flow statements
correspond to proof techniquescase splits are introduced with if
statements, recursion and loops are used for induction, and method calls
for structuring the proof. Additionally, the statement:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">x</span> <span class="o">|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">Lemma</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div></div>
<p>is used to invoke <code class="language-dafny highlighter-rouge"><span class="n">Lemma</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> on all <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> for which <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> holds. If
<code class="language-dafny highlighter-rouge"><span class="n">Lemma</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> ensures <code class="language-dafny highlighter-rouge"><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>, then the forall statement establishes
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span>
</code></pre></div></div>

<h5 id="51432-defining-coinductive-datatypes">5.14.3.2. Defining Coinductive Datatypes</h5>
<p>Each value of an inductive datatype is finite, in the sense that it can
be constructed by a finite number of calls to datatype constructors. In
contrast, values of a coinductive datatype, or co-datatype for short,
can be infinite. For example, a co-datatype can be used to represent
infinite trees.</p>

<p>Syntactically, the declaration of a co-datatype in Dafny looks like that
of a datatype, giving prominence to the constructors (following Coq). The
following example defines a co-datatype Stream of possibly
infinite lists.</p>

<!-- %check-verify %save Stream.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">codatatype</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">SNil</span> <span class="o">|</span> <span class="n">SCons</span><span class="p">(</span><span class="n">head</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">tail</span><span class="o">:</span> <span class="n">Stream</span><span class="p">)</span>
<span class="kr">function</span> <span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">SCons</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">}</span>
<span class="kr">function</span> <span class="n">FivesUp</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="kr">decreases</span> <span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">then</span>
    <span class="n">SCons</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">FivesUp</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
  <span class="kr">else</span>
    <span class="n">FivesUp</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-dafny highlighter-rouge"><span class="n">Stream</span></code> is a coinductive datatype whose values are possibly infinite
lists. Function <code class="language-dafny highlighter-rouge"><span class="n">Up</span></code> returns a stream consisting of all integers upwards
of <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">FivesUp</span></code> returns a stream consisting of all multiples of 5
upwards of <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> . The self-call in <code class="language-dafny highlighter-rouge"><span class="n">Up</span></code> and the first self-call in <code class="language-dafny highlighter-rouge"><span class="n">FivesUp</span></code>
sit in productive positions and are therefore classified as co-recursive
calls, exempt from termination checks. The second self-call in <code class="language-dafny highlighter-rouge"><span class="n">FivesUp</span></code> is
not in a productive position and is therefore subject to termination
checking; in particular, each recursive call must decrease the rank
defined by the <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause.</p>

<p>Analogous to the common finite list datatype, <code class="language-dafny highlighter-rouge"><span class="n">Stream</span></code> declares two
constructors, <code class="language-dafny highlighter-rouge"><span class="n">SNil</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">SCons</span></code>. Values can be destructed using match
expressions and statements. In addition, like for inductive datatypes,
each constructor <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> automatically gives rise to a discriminator <code class="language-dafny highlighter-rouge"><span class="n">C?</span></code> and
each parameter of a constructor can be named in order to introduce a
corresponding destructor. For example, if <code class="language-dafny highlighter-rouge"><span class="n">xs</span></code> is the stream
<code class="language-dafny highlighter-rouge"><span class="n">SCons</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span></code>, then <code class="language-dafny highlighter-rouge"><span class="n">xs</span><span class="o">.</span><span class="n">SCons?</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">x</span></code> hold. In contrast
to datatype declarations, there is no grounding check for
co-datatypessince a codatatype admits infinite values, the type is
nevertheless inhabited.</p>

<h5 id="51433-creating-values-of-co-datatypes">5.14.3.3. Creating Values of Co-datatypes</h5>
<p>To define values of co-datatypes, one could imagine a co-function
language feature: the body of a co-function could include possibly
never-ending self-calls that are interpreted by a greatest fix-point
semantics (akin to a <strong>CoFixpoint</strong> in Coq). Dafny uses a different design:
it offers only functions (not co-functions), but it classifies each
intra-cluster call as either <em>recursive</em> or <em>co-recursive</em>. Recursive calls
are subject to termination checks. Co-recursive calls may be
never-ending, which is what is needed to define infinite values of a
co-datatype. For example, function <code class="language-dafny highlighter-rouge"><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></code> in the preceding example is defined as the
stream of numbers from <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> upward: it returns a stream that starts with <code class="language-dafny highlighter-rouge"><span class="n">n</span></code>
and continues as the co-recursive call <code class="language-dafny highlighter-rouge"><span class="n">Up</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></code>.</p>

<p>To ensure that co-recursive calls give rise to mathematically consistent definitions,
they must occur only in productive positions. This says that it must be possible to determine
each successive piece of a co-datatype value after a finite amount of work. This
condition is satisfied if every co-recursive call is syntactically guarded by a constructor
of a co-datatype, which is the criterion Dafny uses to classify intra-cluster calls as being
either co-recursive or recursive. Calls that are classified as co-recursive are exempt from
termination checks.</p>

<p>A consequence of the productivity checks and termination checks is that, even in the
absence of talking about least or greatest fix-points of self-calling functions, all functions
in Dafny are deterministic. Since there cannot be multiple fix-points,
the language allows one function to be involved in both recursive and co-recursive calls,
as we illustrate by the function <code class="language-dafny highlighter-rouge"><span class="n">FivesUp</span></code>.</p>

<h5 id="sec-co-equality">5.14.3.4. Co-Equality</h5>
<p>Equality between two values of a co-datatype is a built-in co-predicate.
It has the usual equality syntax <code class="language-dafny highlighter-rouge"><span class="n">s</span> <span class="o">==</span> <span class="n">t</span></code>, and the corresponding prefix
equality is written <code class="language-dafny highlighter-rouge"><span class="n">s</span> <span class="o">==</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="n">t</span></code>. And similarly for <code class="language-dafny highlighter-rouge"><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span></code>
and <code class="language-dafny highlighter-rouge"><span class="n">s</span> <span class="o">!=</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="n">t</span></code>.</p>

<h5 id="sec-copredicates">5.14.3.5. Greatest predicates</h5>

<p>Determining properties of co-datatype values may require an infinite
number of observations. To that end, Dafny provides <em>greatest predicates</em>
which are function declarations that use the <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span> <span class="kr">predicate</span></code> keyword phrase.
Self-calls to a greatest predicate need not terminate. Instead, the value
defined is the greatest fix-point of the given recurrence equations.
Continuing the preceding example, the following code defines a
greatest predicate that holds for exactly those streams whose payload consists
solely of positive integers. The greatest predicate definition implicitly also
gives rise to a corresponding prefix predicate, <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="err">#</span></code>. The syntax for
calling a prefix predicate sets apart the argument that specifies the
prefix length, as shown in the last line; for this figure, we took the
liberty of making up a coordinating syntax for the signature of the
automatically generated prefix predicate (which is not part of
Dafny syntax).</p>

<!-- %check-resolve %use Stream.tmp %save Pos.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">greatest</span> <span class="kr">predicate</span> <span class="n">Pos</span><span class="p">[</span><span class="kt">nat</span><span class="p">](</span><span class="n">s</span><span class="o">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">match</span> <span class="n">s</span>
  <span class="kr">case</span> <span class="n">SNil</span> <span class="o">=&gt;</span> <span class="kc">true</span>
  <span class="kr">case</span> <span class="n">SCons</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Pos</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The following code is automatically generated by the Dafny compiler:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">Pos</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">:</span> <span class="kt">nat</span><span class="p">](</span><span class="n">s</span><span class="o">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">decreases</span> <span class="err">_</span><span class="n">k</span>
<span class="p">{</span> <span class="kr">if</span> <span class="err">_</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kc">true</span> <span class="kr">else</span>
  <span class="kr">match</span> <span class="n">s</span>
  <span class="kr">case</span> <span class="n">SNil</span> <span class="o">=&gt;</span> <span class="kc">true</span>
  <span class="kr">case</span> <span class="n">SCons</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Pos</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">rest</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Some restrictions apply. To guarantee that the greatest fix-point always
exists, the (implicit functor defining the) greatest predicate must be
monotonic. This is enforced by a syntactic restriction on the form of the
body of greatest predicates: after conversion to negation normal form (i.e.,
pushing negations down to the atoms), intra-cluster calls of
greatest predicates must appear only in <em>positive</em> positionsthat is, they must
appear as atoms and must not be negated. Additionally, to guarantee
soundness later on, we require that they appear in <em>continous</em>
positionsthat is, in negation normal form, when they appear under
existential quantification, the quantification needs to be limited to a
finite range<sup id="fnref:fn-copredicate-restriction" role="doc-noteref"><a href="#fn:fn-copredicate-restriction" class="footnote" rel="footnote">7</a></sup>. Since the evaluation of a greatest predicate might not
terminate, greatest predicates are always ghost. There is also a restriction on
the call graph that a cluster containing a greatest predicate must contain only
greatest predicates, no other kinds of functions.</p>

<p>extreme predicates and lemmas, one in which <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span></code> has type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> and one in
which it has type <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code> (the default). The continuous restriction
applies only when <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span></code> is <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code>. Also, higher-order function support in Dafny is
    rather modest and typical reasoning patterns do not involve them, so this
    restriction is not as limiting as it would have been in, e.g., Coq.</p>

<p>A <strong>greatest predicate</strong> declaration of <code class="language-dafny highlighter-rouge"><span class="n">P</span></code> defines not just a greatest predicate, but
also a corresponding <em>prefix predicate</em> <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="err">#</span></code>. A prefix predicate is a
finite unrolling of a co-predicate. The prefix predicate is constructed
from the co-predicate by</p>

<ul>
  <li>
    <p>adding a parameter <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> to denote the prefix length,</p>
  </li>
  <li>
    <p>adding the clause <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="err">_</span><span class="n">k</span><span class="p">;</span></code> to the prefix predicate (the
greatest predicate itself is not allowed to have a decreases clause),</p>
  </li>
  <li>
    <p>replacing in the body of the greatest predicate every intra-cluster
call <code class="language-dafny highlighter-rouge"><span class="n">Q</span><span class="p">(</span><span class="n">args</span><span class="p">)</span></code> to a greatest predicate by a call <code class="language-dafny highlighter-rouge"><span class="n">Q</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">](</span><span class="n">args</span><span class="p">)</span></code>
to the corresponding prefix predicate, and then</p>
  </li>
  <li>
    <p>prepending the body with <code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="err">_</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kc">true</span> <span class="kr">else</span></code>.</p>
  </li>
</ul>

<p>For example, for greatest predicate <code class="language-dafny highlighter-rouge"><span class="n">Pos</span></code>, the definition of the prefix
predicate <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="err">#</span></code> is as suggested above. Syntactically, the prefix-length
argument passed to a prefix predicate to indicate how many times to
unroll the definition is written in square brackets, as in <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">s</span><span class="p">)</span></code>.
In the Dafny grammar this is called a <code class="language-dafny highlighter-rouge"><span class="n">HashCall</span></code>. The definition of
<code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="err">#</span></code> is available only at clusters strictly higher than that of <code class="language-dafny highlighter-rouge"><span class="n">Pos</span></code>;
that is, <code class="language-dafny highlighter-rouge"><span class="n">Pos</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="err">#</span></code> must not be in the same cluster. In other
words, the definition of <code class="language-dafny highlighter-rouge"><span class="n">Pos</span></code> cannot depend on <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="err">#</span></code>.</p>

<h5 id="51436-coinductive-proofs">5.14.3.6. Coinductive Proofs</h5>

<p>From what we have said so far, a program can make use of properties of
co-datatypes. For example, a method that declares <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></code> as a
precondition can rely on the stream <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> containing only positive integers.
In this section, we consider how such properties are established in the
first place.</p>

<h6 id="514361-properties-of-prefix-predicates">5.14.3.6.1. Properties of Prefix Predicates</h6>

<p>Among other possible strategies for establishing coinductive properties
we take the time-honored approach of reducing coinduction to
induction. More precisely, Dafny passes to the SMT solver an
assumption <code class="language-dafny highlighter-rouge"><span class="n">D</span><span class="p">(</span><span class="n">P</span><span class="p">)</span></code> for every greatest predicate <code class="language-dafny highlighter-rouge"><span class="n">P</span></code>, where:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">D</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">=</span> <span class="kr">forall</span> <span class="n">x</span> <span class="err"></span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="kr">forall</span> <span class="n">k</span> <span class="err"></span> <span class="n">P</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>In other words, a greatest predicate is true iff its corresponding prefix
predicate is true for all finite unrollings.</p>

<p>In Sec. 4 of the paper [Co-induction Simply] a soundness theorem of such
assumptions is given, provided the greatest predicates meet the continous
restrictions. An example proof of <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="p">(</span><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></code> for every <code class="language-dafny highlighter-rouge"><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span></code> is
shown here:</p>

<!-- %check-verify %use Pos.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">lemma</span> <span class="n">UpPosLemma</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="kr">ensures</span> <span class="n">Pos</span><span class="p">(</span><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">{</span>
  <span class="kr">forall</span> <span class="n">k</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="p">{</span> <span class="n">UpPosLemmaK</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kr">lemma</span> <span class="n">UpPosLemmaK</span><span class="p">(</span><span class="n">k</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="kr">ensures</span> <span class="n">Pos</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="kr">decreases</span> <span class="n">k</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// this establishes Pos#[k-1](Up(n).tail)</span>
    <span class="n">UpPosLemmaK</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The lemma <code class="language-dafny highlighter-rouge"><span class="n">UpPosLemma</span></code> proves <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="p">(</span><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></code> for every <code class="language-dafny highlighter-rouge"><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span></code>. We first
show <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">Up</span><span class="p">(</span><span class="n">n</span> <span class="p">))</span></code>, for <code class="language-dafny highlighter-rouge"><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span></code> and an arbitrary <code class="language-dafny highlighter-rouge"><span class="n">k</span></code>, and then use
the forall statement to show <code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">k</span> <span class="err"></span> <span class="n">Pos</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></code>. Finally, the axiom
<code class="language-dafny highlighter-rouge"><span class="n">D</span><span class="p">(</span><span class="n">Pos</span><span class="p">)</span></code> is used (automatically) to establish the greatest predicate.</p>

<h6 id="sec-colemmas">5.14.3.6.2. Greatest lemmas</h6>

<p>As we just showed, with help of the <code class="language-dafny highlighter-rouge"><span class="n">D</span></code> axiom we can now prove a
greatest predicate by inductively proving that the corresponding prefix
predicate holds for all prefix lengths <code class="language-dafny highlighter-rouge"><span class="n">k</span></code>. In this section, we introduce
<em>greatest lemma</em> declarations, which bring about two benefits. The first benefit
is that greatest lemmas are syntactic sugar and reduce the tedium of having to
write explicit quantifications over <code class="language-dafny highlighter-rouge"><span class="n">k</span></code>. The second benefit is that, in
simple cases, the bodies of greatest lemmas can be understood as coinductive
proofs directly. As an example consider the following greatest lemma.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">greatest</span> <span class="kr">lemma</span> <span class="n">UpPosLemma</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="kr">ensures</span> <span class="n">Pos</span><span class="p">(</span><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="p">{</span>
  <span class="n">UpPosLemma</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This greatest lemma can be understood as follows: <code class="language-dafny highlighter-rouge"><span class="n">UpPosLemma</span></code> invokes itself
co-recursively to obtain the proof for <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="p">(</span><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">tail</span><span class="p">)</span></code> (since <code class="language-dafny highlighter-rouge"><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">tail</span></code>
equals <code class="language-dafny highlighter-rouge"><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></code>). The proof glue needed to then conclude <code class="language-dafny highlighter-rouge"><span class="n">Pos</span><span class="p">(</span><span class="n">Up</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></code> is
provided automatically, thanks to the power of the SMT-based verifier.</p>

<h6 id="sec-prefix-lemmas">5.14.3.6.3. Prefix Lemmas</h6>

<p>To understand why the above <code class="language-dafny highlighter-rouge"><span class="n">UpPosLemma</span></code> greatest lemma code is a sound proof,
let us now describe the details of the desugaring of greatest lemmas. In
analogy to how a <strong>greatest predicate</strong> declaration defines both a greatest predicate and
a prefix predicate, a <strong>greatest lemma</strong> declaration defines both a greatest lemma and
<em>prefix lemma</em>. In the call graph, the cluster containing a greatest lemma must
contain only greatest lemmas and prefix lemmas, no other methods or function.
By decree, a greatest lemma and its corresponding prefix lemma are always
placed in the same cluster. Both greatest lemmas and prefix lemmas are always
ghost code.</p>

<p>The prefix lemma is constructed from the greatest lemma by</p>

<ul>
  <li>
    <p>adding a parameter <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> to denote the prefix length,</p>
  </li>
  <li>
    <p>replacing in the greatest lemmas postcondition the positive continuous
occurrences of greatest predicates by corresponding prefix predicates,
passing in <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span></code> as the prefix-length argument,</p>
  </li>
  <li>
    <p>prepending <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span></code> to the (typically implicit) <strong>decreases</strong> clause of the greatest lemma,</p>
  </li>
  <li>
    <p>replacing in the body of the greatest lemma every intra-cluster call
<code class="language-dafny highlighter-rouge"><span class="n">M</span><span class="p">(</span><span class="n">args</span><span class="p">)</span></code> to a greatest lemma by a call <code class="language-dafny highlighter-rouge"><span class="n">M</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">](</span><span class="n">args</span><span class="p">)</span></code> to the
corresponding prefix lemma, and then</p>
  </li>
  <li>
    <p>making the bodys execution conditional on <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span></code>.</p>
  </li>
</ul>

<p>Note that this rewriting removes all co-recursive calls of greatest lemmas,
replacing them with recursive calls to prefix lemmas. These recursive
calls are, as usual, checked to be terminating. We allow the pre-declared
identifier <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span></code> to appear in the original body of the
greatest lemma.<sup id="fnref:fn-co-predicate-co-lemma-diffs" role="doc-noteref"><a href="#fn:fn-co-predicate-co-lemma-diffs" class="footnote" rel="footnote">8</a></sup></p>

<p>We can now think of the body of the greatest lemma as being replaced by a
<strong>forall</strong> call, for every <em>k</em> , to the prefix lemma. By construction,
this new body will establish the greatest lemmas declared postcondition (on
account of the <code class="language-dafny highlighter-rouge"><span class="n">D</span></code> axiom, and remembering that only the positive
continuous occurrences of greatest predicates in the greatest lemmas postcondition
are rewritten), so there is no reason for the program verifier to check
it.</p>

<p>The actual desugaring of our greatest lemma <code class="language-dafny highlighter-rouge"><span class="n">UpPosLemma</span></code> is in fact the
previous code for the <code class="language-dafny highlighter-rouge"><span class="n">UpPosLemma</span></code> lemma except that <code class="language-dafny highlighter-rouge"><span class="n">UpPosLemmaK</span></code> is
named <code class="language-dafny highlighter-rouge"><span class="n">UpPosLemma</span><span class="err">#</span></code> and modulo a minor syntactic difference in how the
<code class="language-dafny highlighter-rouge"><span class="n">k</span></code> argument is passed.</p>

<p>In the recursive call of the prefix lemma, there is a proof obligation
that the prefixlength argument <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span></code> is a natural number.
Conveniently, this follows from the fact that the body has been wrapped
in an <code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="err">_</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span></code> statement. This also means that the postcondition must
hold trivially when <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span></code>, or else a postcondition violation will be
reported. This is an appropriate design for our desugaring, because
greatest lemmas are expected to be used to establish greatest predicates, whose
corresponding prefix predicates hold trivially when <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span></code>. (To prove
other predicates, use an ordinary lemma, not a greatest lemma.)</p>

<p>It is interesting to compare the intuitive understanding of the
coinductive proof in using a greatest lemma with the inductive proof in using
a lemma. Whereas the inductive proof is performing proofs for deeper
and deeper equalities, the greatest lemma can be understood as producing the
infinite proof on demand.</p>

<h5 id="sec-abstemious">5.14.3.7. Abstemious and voracious functions</h5>

<p>Some functions on codatatypes are <em>abstemious</em>, meaning that they do not
need to unfold a datatype instance very far (perhaps just one destructor call)
to prove a relevant property. Knowing this is the case can aid the proofs of
properties about the function. The attribute <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">abstemious</span><span class="p">}</span></code> can be applied to
a function definition to indicate this.</p>

<p><em>TODO: Say more about the effect of this attribute and when it should be applied
(and likely, correct the paragraph above).</em></p>

<h2 id="sec-member-declaration">6. Member declarations</h2>

<p>Members are the various kinds of methods, the various kinds of functions, mutable fields,
and constant fields. These are usually associated with classes, but they also may be
declared (with limitations) in traits, newtypes and datatypes (but not in subset types or type synonyms).</p>

<h3 id="sec-field-declaration">6.1. Field Declarations (<a href="#g-field-declaration">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">c</span><span class="o">:</span> <span class="kt">int</span>  <span class="c1">// no initialization</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="mi">123</span><span class="o">:</span> <span class="kt">bv10</span>  <span class="c1">// name may be a sequence of digits</span>
  <span class="kr">var</span> <span class="n">d</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">e</span><span class="o">:</span> <span class="kt">real</span>  <span class="c1">// type is required</span>
<span class="p">}</span>
</code></pre></div></div>
<p>A field declaration is not permitted in a value type nor as a member of a module
(despite there being an implicit unnamed class).</p>

<p>The field name is either an
identifier (that is not allowed to start with a leading underscore) or
some digits. Digits are used if you want to number your fields, e.g. 0,
1, etc. The digits do not denote numbers but sequences of digits,
so 0, 00, 0_0 are all different.</p>

<p>A field x of some type T is declared as:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="n">T</span>
</code></pre></div></div>

<p>A field declaration declares one or more fields of the enclosing class.
Each field is a named part of the state of an object of that class. A
field declaration is similar to but distinct from a variable declaration
statement. Unlike for local variables and bound variables, the type is
required and will not be inferred.</p>

<p>Unlike method and function declarations, a field declaration
is not permitted as a member of a module, even though there is an implicit class.
Fields can be declared in either an explicit
class or a trait. A class that inherits from multiple traits will
have all the fields declared in any of its parent traits.</p>

<p>Fields that are declared as <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> can only be used in specifications,
not in code that will be compiled into executable code.</p>

<p>Fields may not be declared static.</p>

<h3 id="sec-constant-field-declaration">6.2. Constant Field Declarations (<a href="#g-const-declaration">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">c</span><span class="o">:</span> <span class="kt">int</span>
<span class="kr">ghost</span> <span class="kr">const</span> <span class="n">d</span> <span class="o">:=</span> <span class="mi">5</span>
<span class="kr">class</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">e</span><span class="o">:</span> <span class="kt">bool</span>
  <span class="kr">static</span> <span class="kr">const</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>
<p>A <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> declaration declares a name bound to a value,
which value is fixed after initialization.</p>

<p>The declaration must either have a type or an initializing expression (or both).
If the type is omitted, it is inferred from the initializing expression.</p>

<ul>
  <li>A const declaration may include the <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code> modifiers, but no
others.</li>
  <li>A const declaration may appear within a module or within any declaration
that may contain members (class, trait, datatype, newtype).</li>
  <li>If it is in a module, it is implicitly <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code>, and may not also be declared
<code class="language-dafny highlighter-rouge"><span class="kr">static</span></code>.</li>
  <li>If the declaration has an initializing expression that is a ghost
expression, then the ghost-ness of the declaration is inferred; the <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code>
modifier may be omitted.</li>
  <li>If the declaration includes the <code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code> modifier, then uses of the declared
variable know its name and type but not its value. The value can be made known for
reasoning purposes by using the <a href="#sec-reveal-statement">reveal statement</a>.</li>
  <li>The initialization expression may refer to other constant fields that are in scope and declared either
before or after this declaration, but circular references are not allowed.</li>
</ul>

<h3 id="sec-method-declaration">6.3. Method Declarations (<a href="#g-method-declaration">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">requires</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{}</span>
<span class="kr">method</span> <span class="n">p</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="kr">method</span> <span class="n">q</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">s</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">t</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span> <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="p">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">t</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="kr">ghost</span> <span class="kr">method</span> <span class="n">g</span><span class="p">()</span> <span class="p">{}</span>
<span class="kr">class</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">method</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span>
  <span class="kr">constructor</span> <span class="n">Init</span><span class="p">()</span> <span class="p">{}</span>
  <span class="kr">static</span> <span class="kr">method</span> <span class="n">g</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="kr">lemma</span> <span class="n">L</span><span class="p">(</span><span class="n">p</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">ensures</span> <span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span> <span class="p">{}</span>
<span class="kr">twostate</span> <span class="kr">lemma</span> <span class="n">TL</span><span class="p">(</span><span class="n">p</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">ensures</span> <span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span> <span class="p">{}</span>
<span class="kr">least</span> <span class="kr">lemma</span> <span class="n">LL</span><span class="p">[</span><span class="kt">nat</span><span class="p">](</span><span class="n">p</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">ensures</span> <span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span> <span class="p">{}</span>
<span class="kr">greatest</span> <span class="kr">lemma</span> <span class="n">GL</span><span class="p">(</span><span class="n">p</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">ensures</span> <span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span> <span class="p">{}</span>
<span class="kr">abstract</span> <span class="kr">module</span> <span class="n">M</span> <span class="p">{</span> <span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">module</span> <span class="n">N</span> <span class="kr">refines</span> <span class="n">M</span> <span class="p">{</span> <span class="kr">method</span> <span class="n">m</span> <span class="o">...</span> <span class="p">{}</span> <span class="p">}</span>
</code></pre></div></div>

<p>Method declarations include a variety of related types of methods:</p>
<ul>
  <li>method</li>
  <li>constructor</li>
  <li>lemma</li>
  <li>twostate lemma</li>
  <li>least lemma</li>
  <li>greatest lemma</li>
</ul>

<p>A method signature specifies the method generic parameters,
input parameters and return parameters.
The formal parameters are not allowed to have <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> specified
if <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> was already specified for the method.
Within the body of a method, formal (input) parameters are immutable, that is,
they may not be assigned to, though their array elements or fields may be
assigned, if otherwise permitted.
The out-parameters are mutable and must be assigned in the body of the method.</p>

<p>An <code class="language-dafny highlighter-rouge"><span class="n">ellipsis</span></code> is used when a method or function is being redeclared
in a module that refines another module. (cf. <a href="#sec-module-refinement">Section 10</a>)
In that case the signature is
copied from the module that is being refined. This works because
Dafny does not support method or function overloading, so the
name of the class method uniquely identifies it without the
signature.</p>

<p>See <a href="#sec-method-specification">Section 7.2</a> for a description of the method specification.</p>

<p>Here is an example of a method declaration.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">att1</span><span class="p">}{</span><span class="o">:</span><span class="n">att2</span><span class="p">}</span> <span class="n">M</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="n">B</span><span class="p">,</span> <span class="n">c</span><span class="o">:</span> <span class="n">C</span><span class="p">)</span>
                                        <span class="kr">returns</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="n">Y</span><span class="p">,</span> <span class="n">z</span><span class="o">:</span> <span class="n">Z</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">Pre</span>
  <span class="kr">modifies</span> <span class="n">Frame</span>
  <span class="kr">ensures</span> <span class="n">Post</span>
  <span class="kr">decreases</span> <span class="n">Rank</span>
<span class="p">{</span>
  <span class="n">Body</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where <code class="language-dafny highlighter-rouge"><span class="o">:</span><span class="n">att1</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">:</span><span class="n">att2</span></code> are attributes of the method,
<code class="language-dafny highlighter-rouge"><span class="n">T1</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">T2</span></code> are type parameters of the method (if generic),
<code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span></code> are the methods in-parameters, <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span></code> are the
methods out-parameters, <code class="language-dafny highlighter-rouge"><span class="n">Pre</span></code> is a boolean expression denoting the
methods precondition, <code class="language-dafny highlighter-rouge"><span class="n">Frame</span></code> denotes a set of objects whose fields may
be updated by the method, <code class="language-dafny highlighter-rouge"><span class="n">Post</span></code> is a boolean expression denoting the
methods postcondition, <code class="language-dafny highlighter-rouge"><span class="n">Rank</span></code> is the methods variant function, and
<code class="language-dafny highlighter-rouge"><span class="n">Body</span></code> is a list of statements that implements the method. <code class="language-dafny highlighter-rouge"><span class="n">Frame</span></code> can be a list
of expressions, each of which is a set of objects or a single object, the
latter standing for the singleton set consisting of that one object. The
methods frame is the union of these sets, plus the set of objects
allocated by the method body. For example, if <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">d</span></code> are parameters
of a class type <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>, then</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">modifies</span> <span class="p">{</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">}</span>
<span class="kr">modifies</span> <span class="p">{</span><span class="n">c</span><span class="p">}</span> <span class="o">+</span> <span class="p">{</span><span class="n">d</span><span class="p">}</span>
<span class="kr">modifies</span> <span class="n">c</span><span class="p">,</span> <span class="p">{</span><span class="n">d</span><span class="p">}</span>
<span class="kr">modifies</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
</code></pre></div></div>

<p>all mean the same thing.</p>

<p>If the method is an <em>extreme lemma</em> ( a <code class="language-dafny highlighter-rouge"><span class="kr">least</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span></code> lemma), then the
method signature may also state the type of the <em>k</em> parameter as either <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> or <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code>.
These are described
in <a href="#sec-friendliness">Section 12.5.3</a> and subsequent sections.</p>

<h4 id="631-ordinary-methods">6.3.1. Ordinary methods</h4>

<p>A method can be declared as ghost by preceding the declaration with the
keyword <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> and as static by preceding the declaration with the keyword <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code>.
The default is non-static (i.e., instance) for methods declared in a type and non-ghost.
An instance method has an implicit receiver parameter, <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>.
A static method M in a class C can be invoked by <code class="language-dafny highlighter-rouge"><span class="n">C</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="err"></span><span class="p">)</span></code>.</p>

<p>An ordinary method is declared with the <code class="language-dafny highlighter-rouge"><span class="kr">method</span></code> keyword;
<a href="#sec-constructor-methods">the section about constructors</a> explains methods that instead use the
<code class="language-dafny highlighter-rouge"><span class="kr">constructor</span></code> keyword; <a href="#sec-lemmas">the section about lemmas</a> discusses methods that are
declared with the <code class="language-dafny highlighter-rouge"><span class="kr">lemma</span></code> keyword. Methods declared with the
<code class="language-dafny highlighter-rouge"><span class="kr">least</span> <span class="kr">lemma</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span> <span class="kr">lemma</span></code> keyword phrases
are discussed later in the context of extreme
predicates (see <a href="#sec-colemmas">the section about greatest lemmas</a>).</p>

<p>A method without a body is <em>abstract</em>. A method is allowed to be
abstract under the following circumstances:</p>

<ul>
  <li>It contains an <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code> attribute</li>
  <li>It contains an <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> attribute (in this case, to be runnable, the method must have a body in non-Dafny compiled code in the target language.)</li>
  <li>It is a declaration in an abstract module.
Note that when there is no body, Dafny assumes that the <em>ensures</em>
clauses are true without proof.</li>
</ul>

<h4 id="sec-constructor-methods">6.3.2. Constructors</h4>
<p>To write structured object-oriented programs, one often relies on
objects being constructed only in certain ways.  For this purpose, Dafny
provides <em>constructor (method)s</em>.
A constructor is declared with the keyword
<code class="language-dafny highlighter-rouge"><span class="kr">constructor</span></code> instead of <code class="language-dafny highlighter-rouge"><span class="kr">method</span></code>; constructors are permitted only in classes.
A constructor is allowed to be declared as <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code>, in which case it
can only be used in ghost contexts.</p>

<p>A constructor can only be called at the time an object is allocated (see
object-creation examples below). Moreover, when a class contains a
constructor, every call to <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> for a class must be accompanied
by a call to one of its constructors. A class may
declare no constructors or one or more constructors.</p>

<p>In general, a constructor is responsible for initializating the
instance fields of its class. However, any field that is given an
initializer in its declaration may not be reassigned in the body
of the constructor.</p>

<h5 id="6321-classes-with-no-explicit-constructors">6.3.2.1. Classes with no explicit constructors</h5>

<p>For a class that declares no constructors, an instance of the class is
created with
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">;</span>
</code></pre></div></div>
<p>This allocates an object and initializes its fields to values of their
respective types (and initializes each <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> field with a RHS to its specified
value). The RHS of a <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> field may depend on other <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">var</span></code> fields,
but circular dependencies are not allowed.</p>

<p>This simple form of <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> is allowed only if the class declares no constructors,
which is not possible to determine in every scope.
It is easy to determine whether or not a class declares any constructors if the
class is declared in the same module that performs the <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code>. If the class is
declared in a different module and that module exports a constructor, then it is
also clear that the class has a constructor (and thus this simple form of <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code>
cannot be used). (Note that an export set that <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code> a class <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> also exports
the anonymous constructor of <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>, if any.)
But if the module that declares <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> does not export any constructors
for <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>, then callers outside the module do not know whether or not <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> has a
constructor. Therefore, this simple form of <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> is allowed only for classes that
are declared in the same module as the use of <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code>.</p>

<p>The simple <code class="language-dafny highlighter-rouge"><span class="kr">new</span> <span class="n">C</span></code> is allowed in ghost contexts. Also, unlike the forms of <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code>
that call a constructor or initialization method, it can be used in a simultaneous
assignment; for example
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">,</span> <span class="kr">new</span> <span class="n">C</span><span class="p">,</span> <span class="mi">15</span><span class="p">;</span>
</code></pre></div></div>
<p>is legal.</p>

<p>As a shorthand for writing
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">;</span>
<span class="n">c</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</code></pre></div></div>
<p>where <code class="language-dafny highlighter-rouge"><span class="n">Init</span></code> is an initialization method (see the top of <a href="#sec-class-types">the section about class types</a>),
one can write
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</code></pre></div></div>
<p>but it is more typical in such a case to declare a constructor for the class.</p>

<p>(The syntactic support for initialization methods is provided for historical
reasons. It may be deprecated in some future version of Dafny. In most cases,
a constructor is to be preferred.)</p>

<h5 id="6322-classes-with-one-or-more-constructors">6.3.2.2. Classes with one or more constructors</h5>

<p>Like other class members, constructors have names. And like other members,
their names must be distinct, even if their signatures are different.
Being able to name constructors promotes names like <code class="language-dafny highlighter-rouge"><span class="n">InitFromList</span></code> or
<code class="language-dafny highlighter-rouge"><span class="n">InitFromSet</span></code> (or just <code class="language-dafny highlighter-rouge"><span class="n">FromList</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">FromSet</span></code>).
Unlike other members, one constructor is allowed to be <em>anonymous</em>;
in other words, an <em>anonymous constructor</em> is a constructor whose name is
essentially the empty string.  For example:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">Item</span> <span class="p">{</span>
  <span class="kr">constructor</span> <span class="n">I</span><span class="p">(</span><span class="n">xy</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// ...</span>
  <span class="kr">constructor</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The named constructor is invoked as
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="n">i</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Item</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</code></pre></div></div>
<p>The anonymous constructor is invoked as
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="n">m</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Item</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="mi">29</span><span class="p">);</span>
</code></pre></div></div>
<p>dropping the <code class="language-dafny highlighter-rouge"><span class="o">.</span></code>.</p>

<h5 id="6323-two-phase-constructors">6.3.2.3. Two-phase constructors</h5>

<p>The body of a constructor contains two sections,
an initialization phase and a post-initialization phase, separated by a <code class="language-dafny highlighter-rouge"><span class="kr">new</span><span class="p">;</span></code> statement.
If there is no <code class="language-dafny highlighter-rouge"><span class="kr">new</span><span class="p">;</span></code> statement, the entire body is the initialization phase.
The initialization phase is intended to initialize field variables
that were not given values in their declaration; it may not reassign
to fields that do have initializers in their declarations.
In this phase, uses of the object reference <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code> are restricted;
a program may use <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code></p>

<ul>
  <li>as the receiver on the LHS,</li>
  <li>as the entire RHS of an assignment to a field of <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>,</li>
  <li>and as a member of a set on the RHS that is being assigned to a field of <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>.</li>
</ul>

<p>A <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> field with a RHS is not allowed to be assigned anywhere else.
A <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> field without a RHS may be assigned only in constructors, and more precisely
only in the initialization phase of constructors. During this phase, a <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> field
may be assigned more than once; whatever value the <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> field has at the end of the
initialization phase is the value it will have forever thereafter.</p>

<p>For a constructor declared as <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code>, the initialization phase is allowed to assign
both ghost and non-ghost fields. For such an object, values of non-ghost fields at
the end of the initialization phase are in effect no longer changeable.</p>

<p>There are no restrictions on expressions or statements in the post-initialization phase.</p>

<h4 id="sec-lemmas">6.3.3. Lemmas</h4>
<p>Sometimes there are steps of logic required to prove a program correct,
but they are too complex for Dafny to discover and use on its own. When
this happens, we can often give Dafny assistance by providing a lemma.
This is done by declaring a method with the <code class="language-dafny highlighter-rouge"><span class="kr">lemma</span></code> keyword.
Lemmas are implicitly ghost methods and the <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> keyword cannot
be applied to them.</p>

<p>Syntactically, lemmas can be placed where ghost methods can be placed, but they serve
a significantly different function. First of all, a lemma is forbidden to have
<code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause: it may not change anything about even the ghost state; ghost methods
may have <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clauses and may change ghost (but not non-ghost) state.
Furthermore, a lemma is not allowed to allocate any new objects.
And a lemma may be used in the program text in places where ghost methods may not,
such as within expressions (cf. <a href="sec-top-level-expression">Section 21.1</a>).</p>

<p>Lemmas may, but typically do not, have out-parameters.</p>

<p>In summary, a lemma states a logical fact, summarizing an inference that the verifier
cannot do on its own. Explicitly calling a lemma in the program text tells the verifier
to use that fact at that location with the actual arguments substituted for the
formal parameters. The lemma is proved separately for all cases of its formal parameters
that satisfy the preconditions of the lemma.</p>

<p>For an example, see the <code class="language-dafny highlighter-rouge"><span class="n">FibProperty</span></code> lemma in
<a href="#sec-proofs-in-dafny">Section 12.5.2</a>.</p>

<p>See <a href="../OnlineTutorial/Lemmas">the Dafny Lemmas tutorial</a>
for more examples and hints for using lemmas.</p>

<h4 id="sec-two-state">6.3.4. Two-state lemmas and functions</h4>

<p>The heap is an implicit parameter to every function, though a function is only allowed
to read those parts of the mutable heap that it admits to in its <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause.
Sometimes, it is useful for a function to take two heap parameters, for example, so
the function can return the difference between the value of a field in the two heaps.
Such a <em>two-state function</em> is declared by <code class="language-dafny highlighter-rouge"><span class="kr">twostate</span> <span class="kr">function</span></code> (or <code class="language-dafny highlighter-rouge"><span class="kr">twostate</span> <span class="kr">predicate</span></code>,
which is the same as a <code class="language-dafny highlighter-rouge"><span class="kr">twostate</span> <span class="kr">function</span></code> that returns a <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code>). A two-state function
is always ghost. It is appropriate to think of these two implicit heap parameters as
representing a current heap and an old heap.</p>

<p>For example, the predicate
<!-- %check-verify %save Increasing.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">Cell</span> <span class="p">{</span> <span class="kr">var</span> <span class="n">data</span><span class="o">:</span> <span class="kt">int</span>  <span class="kr">constructor</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="kr">twostate</span> <span class="kr">predicate</span> <span class="n">Increasing</span><span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="n">Cell</span><span class="p">)</span>
  <span class="kr">reads</span> <span class="n">c</span>
<span class="p">{</span>
  <span class="kr">old</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span>
<span class="p">}</span>
</code></pre></div></div>
<p>returns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> if the value of <code class="language-dafny highlighter-rouge"><span class="n">c</span><span class="o">.</span><span class="n">data</span></code> has not been reduced from the old state to the
current. Dereferences in the current heap are written as usual (e.g., <code class="language-dafny highlighter-rouge"><span class="n">c</span><span class="o">.</span><span class="n">data</span></code>) and
must, as usual, be accounted for in the functions <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause. Dereferences in the
old heap are enclosed by <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> (e.g., <code class="language-dafny highlighter-rouge"><span class="kr">old</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></code>), just like when one dereferences
a  methods initial heap. The function is allowed to read anything in the old heap;
the <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause only declares dependencies on locations in the current heap.
Consequently, the frame axiom for a two-state function is sensitive to any change
in the old-heap parameter; in other words, the frame axiom says nothing about two
invocations of the two-state function with different old-heap parameters.</p>

<p>At a call site, the two-state functions current-heap parameter is always passed in
as the callers current heap. The two-state functions old-heap parameter is by
default passed in as the callers old heap (that is, the initial heap if the caller
is a method and the old heap if the caller is a two-state function). While there is
never a choice in which heap gets passed as the current heap, the caller can use
any preceding heap as the argument to the two-state functions old-heap parameter.
This is done by labeling a state in the caller and passing in the label, just like
this is done with the built-in <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> function.</p>

<p>For example, the following assertions all hold:
<!-- %check-verify %use Increasing.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Caller</span><span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="n">Cell</span><span class="p">)</span>
  <span class="kr">modifies</span> <span class="n">c</span>
<span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kr">label</span> <span class="n">L</span><span class="o">:</span>
  <span class="kr">assert</span> <span class="n">Increasing</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">Increasing</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="o">!</span><span class="n">Increasing</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The first call to <code class="language-dafny highlighter-rouge"><span class="n">Increasing</span></code> uses <code class="language-dafny highlighter-rouge"><span class="n">Caller</span></code>s initial state as the old-heap parameter,
and so does the second call. The third call instead uses as the old-heap parameter
the heap at label <code class="language-dafny highlighter-rouge"><span class="n">L</span></code>, which is why the third call returns <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>.
As shown in the example, an explicitly given old-heap parameter is given after
an <code class="language-dafny highlighter-rouge"><span class="err">@</span></code>-sign (which follows the name of the function and any explicitly given type
parameters) and before the open parenthesis (after which the ordinary parameters are
given).</p>

<p>A two-state function is allowed to be called only from a two-state context, which
means a method, a two-state lemma (see below), or another two-state function.
Just like a label used with an <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> expression, any label used in a call to a
two-state function must denote a program point that <em>dominates</em> the call. This means
that any control leading to the call must necessarily have passed through the labeled
program point.</p>

<p>Any parameter (including the receiver parameter, if any) passed to a two-state function
must have been allocated already in the old state. For example, the second call to
<code class="language-dafny highlighter-rouge"><span class="n">Diff</span></code> in method <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> is illegal, since <code class="language-dafny highlighter-rouge"><span class="n">d</span></code> was not allocated on entry to <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>:
<!-- %check-verify Types.11.expect %use Increasing.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">twostate</span> <span class="kr">function</span> <span class="n">Diff</span><span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="n">Cell</span><span class="p">,</span> <span class="n">d</span><span class="o">:</span> <span class="n">Cell</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">reads</span> <span class="n">d</span>
<span class="p">{</span>
  <span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="kr">old</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">M</span><span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="n">Cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">d</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Cell</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="kr">label</span> <span class="n">L</span><span class="o">:</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">Diff</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">Diff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// error: d is not allocated in old state</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A two-state function may declare that it only assumes a parameter to be allocated
in the current heap. This is done by preceding the parameter with the <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> modifier,
as illustrated in the following example, where the first call to <code class="language-dafny highlighter-rouge"><span class="n">DiffAgain</span></code> is legal:
<!-- %check-verify Types.12.expect %use Increasing.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">twostate</span> <span class="kr">function</span> <span class="n">DiffAgain</span><span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="n">Cell</span><span class="p">,</span> <span class="kr">new</span> <span class="n">d</span><span class="o">:</span> <span class="n">Cell</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">reads</span> <span class="n">d</span>
<span class="p">{</span>
  <span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="kr">old</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">P</span><span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="n">Cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">d</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Cell</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">DiffAgain</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">DiffAgain</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// error: d is not allocated in old state</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A <em>two-state lemma</em> works in an analogous way. It is a lemma with both a current-heap
parameter and an old-heap parameter, it can use <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> expressions in its
specification (including in the precondition) and body, its parameters may
use the <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> modifier, and the old-heap parameter is by default passed in as
the callers old heap, which can be changed by using an <code class="language-dafny highlighter-rouge"><span class="err">@</span></code>-parameter.</p>

<p>Here is an example of something useful that can be done with a two-state lemma:
<!-- %check-verify %use Increasing.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="n">Cell</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">reads</span> <span class="n">s</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="p">[]</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>
<span class="p">}</span>

<span class="kr">twostate</span> <span class="kr">lemma</span> <span class="n">IncSumDiff</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="n">Cell</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="kr">forall</span> <span class="n">c</span> <span class="o">::</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span> <span class="o">==&gt;</span> <span class="n">Increasing</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="kr">old</span><span class="p">(</span><span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">s</span> <span class="o">==</span> <span class="p">[]</span> <span class="p">{</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">calc</span> <span class="p">{</span>
      <span class="kr">old</span><span class="p">(</span><span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="o">==</span>  <span class="c1">// def. SeqSum</span>
      <span class="kr">old</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]));</span>
    <span class="o">==</span>  <span class="c1">// distribute old</span>
      <span class="kr">old</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="kr">old</span><span class="p">(</span><span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]));</span>
    <span class="o">&lt;=</span>  <span class="p">{</span> <span class="kr">assert</span> <span class="n">Increasing</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="p">}</span>
      <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="kr">old</span><span class="p">(</span><span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]));</span>
    <span class="o">&lt;=</span>  <span class="p">{</span> <span class="n">IncSumDiff</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]);</span> <span class="p">}</span>
      <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]);</span>
    <span class="o">==</span>  <span class="c1">// def. SeqSum</span>
      <span class="n">SeqSum</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A two-state function can be used as a first-class function value, where the receiver
(if any), type parameters (if any), and old-heap parameter are determined at the
time the first-class value is mentioned. While the receiver and type parameters can
be explicitly instantiated in such a use (for example, <code class="language-dafny highlighter-rouge"><span class="n">p</span><span class="o">.</span><span class="n">F</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code> for a two-state
instance function <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> that takes one type parameter), there is currently no syntactic
support for giving the old-heap parameter explicitly. A caller can work
around this restriction by using (fancy-word alert!) eta-expansion, meaning
wrapping a lambda expression around the call, as in <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">=&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">F</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>.
The following example illustrates using such an eta-expansion:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">P</span> <span class="p">{</span>
  <span class="kr">twostate</span> <span class="kr">function</span> <span class="n">F</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">X</span><span class="p">)</span><span class="o">:</span> <span class="n">X</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">EtaExample</span><span class="p">(</span><span class="n">p</span><span class="o">:</span> <span class="n">P</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="kr">ghost</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">label</span> <span class="n">L</span><span class="o">:</span>
  <span class="n">f</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">F</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="sec-function-declaration">6.4. Function Declarations (<a href="#g-function-declaration">grammar</a>)</h3>

<h4 id="641-functions">6.4.1. Functions</h4>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">real</span> <span class="p">{</span> <span class="n">i</span> <span class="ow">as</span> <span class="kt">real</span> <span class="p">}</span>
<span class="kr">function</span> <span class="n">g</span><span class="p">()</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">function</span> <span class="n">h</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">k</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span> <span class="kr">requires</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="mi">1</span> <span class="p">}</span>
</code></pre></div></div>

<p>Functions may be declared as ghost. If so, all the formal parameters and
return values are ghost; if it is not a ghost function, then
individual parameters may be declared ghost as desired.</p>

<p>See <a href="#sec-function-specification">Section 7.3</a> for a description of the function specification.
A Dafny function is a pure mathematical function. It is allowed to
read memory that was specified in its <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> expression but is not
allowed to have any side effects.</p>

<p>Here is an example function declaration:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">att1</span><span class="p">}{</span><span class="o">:</span><span class="n">att2</span><span class="p">}</span> <span class="n">F</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="n">B</span><span class="p">,</span> <span class="n">c</span><span class="o">:</span> <span class="n">C</span><span class="p">)</span><span class="o">:</span> <span class="n">T</span>
  <span class="kr">requires</span> <span class="n">Pre</span>
  <span class="kr">reads</span> <span class="n">Frame</span>
  <span class="kr">ensures</span> <span class="n">Post</span>
  <span class="kr">decreases</span> <span class="n">Rank</span>
<span class="p">{</span>
  <span class="n">Body</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where <code class="language-dafny highlighter-rouge"><span class="o">:</span><span class="n">att1</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">:</span><span class="n">att2</span></code> are attributes of the function, if any, <code class="language-dafny highlighter-rouge"><span class="n">T1</span></code>
and <code class="language-dafny highlighter-rouge"><span class="n">T2</span></code> are type parameters of the function (if generic), <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span></code> are
the functions parameters, <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is the type of the functions result,
<code class="language-dafny highlighter-rouge"><span class="n">Pre</span></code> is a boolean expression denoting the functions precondition,
<code class="language-dafny highlighter-rouge"><span class="n">Frame</span></code> denotes a set of objects whose fields the function body may
depend on, <code class="language-dafny highlighter-rouge"><span class="n">Post</span></code> is a boolean expression denoting the functions
postcondition, <code class="language-dafny highlighter-rouge"><span class="n">Rank</span></code> is the functions variant function, and <code class="language-dafny highlighter-rouge"><span class="n">Body</span></code> is
an expression that defines the functions return value. The precondition
allows a function to be partial, that is, the precondition says when the
function is defined (and Dafny will verify that every use of the function
meets the precondition).</p>

<p>The postcondition is usually not needed, since
the body of the function gives the full definition. However, the
postcondition can be a convenient place to declare properties of the
function that may require an inductive proof to establish, such as when
the function is recursive. For example:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">Factorial</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">requires</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span>
  <span class="kr">ensures</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">Factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="n">Factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div>

<p>says that the result of Factorial is always positive, which Dafny
verifies inductively from the function body.</p>

<p>Within a postcondition, the result of the function is designated by
a call of the function, such as <code class="language-dafny highlighter-rouge"><span class="n">Factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></code> in the example above.
Alternatively, a name for the function result can be given in the signature,
as in the following rewrite of the example above.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">Factorial</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">f</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span>
  <span class="kr">ensures</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">f</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="n">Factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Pre v4.0, a function is <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> by default, and cannot be called from non-ghost
code. To make it non-ghost, replace the keyword <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> with the two
keywords <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">method</span></code>. From v4.0 on, a function is non-ghost by
default. To make it ghost, replace the keyword <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> with the two keywords <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">function</span></code>.
(See the <a href="#sec-function-syntax">function-syntax option</a> for a description
of the migration path for this change in behavior.}</p>

<p>Like methods, functions can be either <em>instance</em> (which they are by default when declared within a type) or
<em>static</em> (when the function declaration contains the keyword <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code> or is declared in a module).
An instance function, but not a static function, has an implicit receiver parameter, <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>.
A static function <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> in a class <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> can be invoked
by <code class="language-dafny highlighter-rouge"><span class="n">C</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="err"></span><span class="p">)</span></code>. This provides a convenient way to declare a number of helper
functions in a separate class.</p>

<p>As for methods, a <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> is used when declaring
a function in a module refinement (cf. <a href="#sec-module-refinement">Section 10</a>).
 For example, if module <code class="language-dafny highlighter-rouge"><span class="n">M0</span></code> declares
function <code class="language-dafny highlighter-rouge"><span class="n">F</span></code>, a module <code class="language-dafny highlighter-rouge"><span class="n">M1</span></code> can be declared to refine <code class="language-dafny highlighter-rouge"><span class="n">M0</span></code> and
<code class="language-dafny highlighter-rouge"><span class="n">M1</span></code> can then refine <code class="language-dafny highlighter-rouge"><span class="n">F</span></code>. The refinement function, <code class="language-dafny highlighter-rouge"><span class="n">M1</span><span class="o">.</span><span class="n">F</span></code> can have
a <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> which means to copy the signature from
<code class="language-dafny highlighter-rouge"><span class="n">M0</span><span class="o">.</span><span class="n">F</span></code>. A refinement function can furnish a body for a function
(if <code class="language-dafny highlighter-rouge"><span class="n">M0</span><span class="o">.</span><span class="n">F</span></code> does not provide one). It can also add <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code>
clauses.</p>

<p>If a function definition does not have a body, the program that contains it may still be verified.
The function itself has nothing to verify.
However, any calls of a body-less function are treated as unverified assumptions by the caller,
asserting the preconditions and assuming the postconditions.
Because body-less functions are unverified assumptions, Dafny will not compile them and will complain if called by <a href="#command-line"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> or even <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code></a></p>

<h4 id="642-predicates">6.4.2. Predicates</h4>
<p>A function that returns a <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code> result is called a <em>predicate</em>. As an
alternative syntax, a predicate can be declared by replacing the <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code>
keyword with the <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code> keyword and possibly omitting a declaration of the
return type (if it is not named).</p>

<h4 id="sec-function-by-method">6.4.3. Function-by-method</h4>

<p>A function with a <code class="language-dafny highlighter-rouge"><span class="kr">by</span> <span class="kr">method</span></code> clause declares a <em>function-by-method</em>.
A function-by-method gives a way to implement a
(deterministic, side-effect free) function by a method (whose body may be
nondeterministic and may allocate objects that it modifies). This can
be useful if the best implementation uses nondeterminism (for example,
because it uses <code class="language-dafny highlighter-rouge"><span class="o">:|</span></code> in a nondeterministic way) in a way that does not
affect the result, or if the implementation temporarily makes use of some
mutable data structures, or if the implementation is done with a loop.
For example, here is the standard definition of the Fibonacci function
but with an efficient implementation that uses a loop:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span> <span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span> <span class="kr">by</span> <span class="kr">method</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="n">n</span>
    <span class="kr">invariant</span> <span class="n">x</span> <span class="o">==</span> <span class="n">Fib</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">Fib</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">by</span> <span class="kr">method</span></code> clause is allowed only for non-ghost <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code>
declarations (without <code class="language-dafny highlighter-rouge"><span class="kr">twostate</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">least</span></code>, and <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span></code>, but
possibly with <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code>); it inherits the in-parameters, attributes, and <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code>
clauses of the function. The method also gets one out-parameter, corresponding
to the functions result value (and the name of it, if present). Finally,
the method gets an empty <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause and a postcondition
<code class="language-dafny highlighter-rouge"><span class="kr">ensures</span> <span class="n">r</span> <span class="o">==</span> <span class="n">F</span><span class="p">(</span><span class="n">args</span><span class="p">)</span></code>, where <code class="language-dafny highlighter-rouge"><span class="n">r</span></code> is the name of the out-parameter and
<code class="language-dafny highlighter-rouge"><span class="n">F</span><span class="p">(</span><span class="n">args</span><span class="p">)</span></code> is the function with its arguments. In other words, the method
body must compute and return exactly what the function says, and must
do so without modifying any previously existing heap state.</p>

<p>The function body of a function-by-method is allowed to be ghost, but the
method body must be compilable. In non-ghost contexts, the compiler turns a
call of the function-by-method into a call that leads to the method body.</p>

<p>Note, the method body of a function-by-method may contain <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statements.
This means that the run-time evaluation of an expression may have print effects.
If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">track</span><span class="o">-</span><span class="kr">print</span><span class="o">-</span><span class="n">effects</span></code> is enabled, this use of print in a function context
will be disallowed.</p>

<h4 id="sec-opaque">6.4.4. Function Hiding</h4>
<p>A function is said to be <em>revealed</em> at a location if the
body of the function is visible for verification at that point, otherwise it is considered <em>hidden</em>.</p>

<p>Functions are revealed by default, but can be hidden using the <code class="language-dafny highlighter-rouge"><span class="n">hide</span></code> statement, which takes either a specific function or a wildcard, to hide all functions. Hiding a function can speed up verification of a proof if the body of that function is not needed for the proof. See the <a href="#hide-statement">hide statement</a> for more information.</p>

<p>Although mostly made obsolete by the hide statement, a function can also be hidden using the <code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code> keyword, or using the option <code class="language-dafny highlighter-rouge"><span class="n">default</span><span class="o">-</span><span class="kr">function</span><span class="o">-</span><span class="n">opacity</span></code>. Here are the rules regarding those:</p>

<p>Inside the module where the function is declared:</p>
<ul>
  <li>If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">default</span><span class="o">-</span><span class="kr">function</span><span class="o">-</span><span class="n">opacity</span></code> is set to <code class="language-dafny highlighter-rouge"><span class="n">transparent</span></code> (default), then:
    <ul>
      <li>if there is no <code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code> modifier, the function is transparent.</li>
      <li>if there is an <code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code> modifier, then the function is opaque. If the function is mentioned in a <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> statement, then
 its body is available starting at that <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> statement.</li>
    </ul>
  </li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">default</span><span class="o">-</span><span class="kr">function</span><span class="o">-</span><span class="n">opacity</span></code> is set to <code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code>, then:
    <ul>
      <li>if there is no <a href="#sec-transparent"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">transparent</span><span class="p">}</span></code> attribute</a>, the function is opaque. If the function is mentioned in a <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> statement, then the body of the function is available starting at that <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> statement.</li>
      <li>if there is a <a href="#sec-transparent"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">transparent</span><span class="p">}</span></code> attribute</a>, then the function is transparent.</li>
    </ul>
  </li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">default</span><span class="o">-</span><span class="kr">function</span><span class="o">-</span><span class="n">opacity</span></code> is set to <code class="language-dafny highlighter-rouge"><span class="n">autoRevealDependencies</span></code>, then:
    <ul>
      <li>if there is no <a href="#sec-transparent"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">transparent</span><span class="p">}</span></code> attribute</a>, the function is opaque. However, the body of the function is available inside any callable that depends on this function via an implicitly inserted <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> statement, unless the callable has the <a href="#sec-autorevealdependencies"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="n">autoRevealDependencies</span> <span class="n">k</span><span class="p">}</span></code> attribute</a> for some natural number <code class="language-dafny highlighter-rouge"><span class="n">k</span></code> which is too low.</li>
      <li>if there is a <a href="#sec-transparent"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">transparent</span><span class="p">}</span></code> attribute</a>, then the function is transparent.</li>
    </ul>
  </li>
</ul>

<p>Outside the module where the function is declared, the function is
  visible only if it was listed in the export set by which the contents
  of its module was imported. In that case, if the function was exported
  with <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code>, the rules are the same within the importing module as when the function is used inside
  its declaring module. If the function is exported only with <code class="language-dafny highlighter-rouge"><span class="kr">provides</span></code> it is
  always hidden and is not permitted to be used in a reveal statement.</p>

<p>More information about the Boogie implementation of opaquenes is <a href="https://github.com/dafny-lang/dafny/blob/master/docs/Compilation/Boogie.md">here</a>.</p>

<h4 id="645-extreme-least-or-greatest-predicates-and-lemmas">6.4.5. Extreme (Least or Greatest) Predicates and Lemmas</h4>
<p>See <a href="#sec-friendliness">Section 12.5.3</a> for descriptions
of extreme predicates and lemmas.</p>

<h4 id="sec-older-parameters">6.4.6. <code class="language-dafny highlighter-rouge"><span class="n">older</span></code> parameters in predicates</h4>

<p>A parameter of any predicate (more precisely, of any
boolean-returning, non-extreme function) can be marked as
<code class="language-dafny highlighter-rouge"><span class="n">older</span></code>. This specifies that the truth of the predicate implies that
the allocatedness of the parameter follows from the allocatedness of
the non-<code class="language-dafny highlighter-rouge"><span class="n">older</span></code> parameters.</p>

<p>To understand what this means and why this attribute is useful,
consider the following example, which specifies reachability between
nodes in a directed graph. A <code class="language-dafny highlighter-rouge"><span class="n">Node</span></code> is declared to have any number of
children:</p>

<!-- %check-verify %save Node.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">children</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There are several ways one could specify reachability between
nodes. One way (which is used in <code class="language-dafny highlighter-rouge"><span class="n">Test</span><span class="o">/</span><span class="n">dafny1</span><span class="o">/</span><span class="n">SchorrWaite</span><span class="o">.</span><span class="n">dfy</span></code> in the
Dafny test suite) is to define a type <code class="language-dafny highlighter-rouge"><span class="n">Path</span></code>, representing lists of
<code class="language-dafny highlighter-rouge"><span class="n">Node</span></code>s, and to define a predicate that checks if a given list of
<code class="language-dafny highlighter-rouge"><span class="n">Node</span></code>s is indeed a path between two given nodes:</p>

<!-- %check-verify %use Node.tmp %save ReachableVia.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">Empty</span> <span class="o">|</span> <span class="n">Extend</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>

<span class="kr">predicate</span> <span class="n">ReachableVia</span><span class="p">(</span><span class="n">source</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">p</span><span class="o">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">sink</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">S</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">reads</span> <span class="n">S</span>
  <span class="kr">decreases</span> <span class="n">p</span>
<span class="p">{</span>
  <span class="kr">match</span> <span class="n">p</span>
  <span class="kr">case</span> <span class="n">Empty</span> <span class="o">=&gt;</span>
    <span class="n">source</span> <span class="o">==</span> <span class="n">sink</span>
  <span class="kr">case</span> <span class="n">Extend</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="n">n</span> <span class="ow">in</span> <span class="n">S</span> <span class="o">&amp;&amp;</span> <span class="n">sink</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="o">&amp;&amp;</span> <span class="n">ReachableVia</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In a nutshell, the definition of <code class="language-dafny highlighter-rouge"><span class="n">ReachableVia</span></code> says</p>

<ul>
  <li>An empty path lets <code class="language-dafny highlighter-rouge"><span class="n">source</span></code> reach <code class="language-dafny highlighter-rouge"><span class="n">sink</span></code> just when
<code class="language-dafny highlighter-rouge"><span class="n">source</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">sink</span></code> are the same node.</li>
  <li>A path <code class="language-dafny highlighter-rouge"><span class="n">Extend</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></code> lets <code class="language-dafny highlighter-rouge"><span class="n">source</span></code> reach <code class="language-dafny highlighter-rouge"><span class="n">sink</span></code> just when
the path <code class="language-dafny highlighter-rouge"><span class="n">prefix</span></code> lets <code class="language-dafny highlighter-rouge"><span class="n">source</span></code> reach <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">sink</span></code> is one of
the children nodes of <code class="language-dafny highlighter-rouge"><span class="n">n</span></code>.</li>
</ul>

<p>To be admissible by Dafny, the recursive predicate must be shown to
terminate. Termination is assured by the specification <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="n">p</span></code>,
since every such datatype value has a finite structure and every
recursive call passes in a path that is structurally included in the
previous. Predicate <code class="language-dafny highlighter-rouge"><span class="n">ReachableVia</span></code> must also declare (an upper bound
on) which heap objects it depends on. For this purpose, the
predicate takes an additional parameter <code class="language-dafny highlighter-rouge"><span class="n">S</span></code>, which is used to limit
the set of intermediate nodes in the path. More precisely, predicate
<code class="language-dafny highlighter-rouge"><span class="n">ReachableVia</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sink</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span></code> returns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> if and only if <code class="language-dafny highlighter-rouge"><span class="n">p</span></code>
is a list of nodes in <code class="language-dafny highlighter-rouge"><span class="n">S</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">source</span></code> can reach <code class="language-dafny highlighter-rouge"><span class="n">sink</span></code> via <code class="language-dafny highlighter-rouge"><span class="n">p</span></code>.</p>

<p>Using predicate <code class="language-dafny highlighter-rouge"><span class="n">ReachableVia</span></code>, we can now define reachability in <code class="language-dafny highlighter-rouge"><span class="n">S</span></code>:</p>

<!-- %check-resolve Types.13.expect %use ReachableVia.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">Reachable</span><span class="p">(</span><span class="n">source</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">sink</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">S</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">reads</span> <span class="n">S</span>
<span class="p">{</span>
  <span class="kr">exists</span> <span class="n">p</span> <span class="o">::</span> <span class="n">ReachableVia</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sink</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This looks like a good definition of reachability, but Dafny wont
admit it. The reason is twofold:</p>

<ul>
  <li>
    <p>Quantifiers and comprehensions are allowed to range only over
allocated state. Ater all, Dafny is a type-safe language where every
object reference is <em>valid</em> (that is, a pointer to allocated storage
of the right type)it should not be possible, not even through a
bound variable in a quantifier or comprehension, for a program to
obtain an object reference that isnt valid.</p>
  </li>
  <li>
    <p>This property is ensured by disallowing <em>open-ended</em> quantifiers.
More precisely, the object references that a quantifier may range
over must be shown to be confined to object references that were
allocated before some of the non-<code class="language-dafny highlighter-rouge"><span class="n">older</span></code> parameters passed to the
predicate. Quantifiers that are not open-ended are called
<em>close-ended</em>. Note that close-ended refers only to the object
references that the quantification or comprehension ranges overit
does not say anything about values of other types, like integers.</p>
  </li>
</ul>

<p>Often, it is easy to show that a quantifier is close-ended. In fact,
if the type of a bound variable does not contain any object
references, then the quantifier is trivially close-ended. For example,</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">Square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>is trivially close-ended.</p>

<p>Another innocent-looking quantifier occurs in the following example:</p>

<!-- %check-resolve Types.14.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">IsCommutative</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">forall</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">r</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// error: open-ended quantifier</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since nothing is known about type <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>, this quantifier might be
open-ended.  For example, if <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> were passed in as a class type, then
the quantifier would be open-ended. One way to fix this predicate is
to restrict it to non-heap based types, which is indicated with the
<code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span></code> type characteristic (see <a href="#sec-non-heap-based">Section 5.3.1.4</a>):</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ghost</span> <span class="kr">predicate</span> <span class="n">IsCommutative</span><span class="o">&lt;</span><span class="n">X</span><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="c1">// X is restricted to non-heap types</span>
<span class="p">{</span>
  <span class="kr">forall</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">r</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// allowed</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Another way to make <code class="language-dafny highlighter-rouge"><span class="n">IsCommutative</span></code> close-ended is to constrain the values
of the bound variables <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">y</span></code>. This can be done by adding a parameter
to the predicate and limiting the quantified values to ones in the given set:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">IsCommutativeInS</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">S</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">forall</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">S</span> <span class="o">==&gt;</span> <span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">r</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// close-ended</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Through a simple syntactic analysis, Dafny detects the antecedents
<code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">in</span> <span class="n">S</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">y</span> <span class="ow">in</span> <span class="n">S</span></code>, and since <code class="language-dafny highlighter-rouge"><span class="n">S</span></code> is a parameter and thus can only be
passed in as something that the caller has already allocated, the
quantifier in <code class="language-dafny highlighter-rouge"><span class="n">IsCommutativeInS</span></code> is determined to be close-ended.</p>

<p>Note, the <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">in</span> <span class="n">S</span></code> trick does not work for the motivating example,
<code class="language-dafny highlighter-rouge"><span class="n">Reachable</span></code>. If you try to write</p>

<!-- %check-resolve Types.15.expect %use ReachableVia.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">Reachable</span><span class="p">(</span><span class="n">source</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">sink</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">S</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">reads</span> <span class="n">S</span>
<span class="p">{</span>
  <span class="kr">exists</span> <span class="n">p</span> <span class="o">::</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">S</span> <span class="o">&amp;&amp;</span> <span class="n">ReachableVia</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sink</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="c1">// type error: p</span>
<span class="p">}</span>
</code></pre></div></div>

<p>you will get a type error, because <code class="language-dafny highlighter-rouge"><span class="n">p</span> <span class="ow">in</span> <span class="n">S</span></code> does not make sense if <code class="language-dafny highlighter-rouge"><span class="n">p</span></code>
has type <code class="language-dafny highlighter-rouge"><span class="n">Path</span></code>. We need some other way to justify that the
quantification in <code class="language-dafny highlighter-rouge"><span class="n">Reachable</span></code> is close-ended.</p>

<p>Dafny offers a way to extend the <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">in</span> <span class="n">S</span></code> trick to more situations.
This is where the <code class="language-dafny highlighter-rouge"><span class="n">older</span></code> modifier comes in. Before we apply <code class="language-dafny highlighter-rouge"><span class="n">older</span></code>
in the <code class="language-dafny highlighter-rouge"><span class="n">Reachable</span></code> example, lets first look at what <code class="language-dafny highlighter-rouge"><span class="n">older</span></code> does in a
less cluttered example.</p>

<p>Suppose we rewrite <code class="language-dafny highlighter-rouge"><span class="n">IsCommutativeInS</span></code> using a programmer-defined predicate <code class="language-dafny highlighter-rouge"><span class="n">In</span></code>:</p>

<!-- %check-resolve Types.16.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">In</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span>
<span class="p">}</span>

<span class="kr">predicate</span> <span class="n">IsCommutativeInS</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">S</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">forall</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">In</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">In</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">r</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">r</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1">// error: open-ended?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The simple syntactic analysis that looks for <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">in</span> <span class="n">S</span></code> finds nothing
here, because the <code class="language-dafny highlighter-rouge"><span class="ow">in</span></code> operator is relegated to the body of predicate
<code class="language-dafny highlighter-rouge"><span class="n">In</span></code>. To inform the analysis that <code class="language-dafny highlighter-rouge"><span class="n">In</span></code> is a predicate that, in effect,
is like <code class="language-dafny highlighter-rouge"><span class="ow">in</span></code>, you can mark parameter <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> with <code class="language-dafny highlighter-rouge"><span class="n">older</span></code>:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">In</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="n">older</span> <span class="n">x</span><span class="o">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This causes the simple syntactic analysis to accept the quantifier in
<code class="language-dafny highlighter-rouge"><span class="n">IsCommutativeInS</span></code>. Adding <code class="language-dafny highlighter-rouge"><span class="n">older</span></code> also imposes a semantic check on
the body of predicate <code class="language-dafny highlighter-rouge"><span class="n">In</span></code>, enforced by the verifier. The semantic
check is that all the object references in the value <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> are older (or
equally old as) the object references that are part of the other
parameters, <em>in the event that the predicate returns true</em>. That is,
<code class="language-dafny highlighter-rouge"><span class="n">older</span></code> is designed to help the caller only if the predicate returns
<code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>, and the semantic check amounts to nothing if the predicate
returns <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>.</p>

<p>Finally, lets get back to the motivating example. To allow the quantifier
in <code class="language-dafny highlighter-rouge"><span class="n">Reachable</span></code>, mark parameter <code class="language-dafny highlighter-rouge"><span class="n">p</span></code> of <code class="language-dafny highlighter-rouge"><span class="n">ReachableVia</span></code> with <code class="language-dafny highlighter-rouge"><span class="n">older</span></code>:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">children</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kr">datatype</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">Empty</span> <span class="o">|</span> <span class="n">Extend</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>

<span class="kr">ghost</span> <span class="kr">predicate</span> <span class="n">Reachable</span><span class="p">(</span><span class="n">source</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">sink</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">S</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">reads</span> <span class="n">S</span>
<span class="p">{</span>
  <span class="kr">exists</span> <span class="n">p</span> <span class="o">::</span> <span class="n">ReachableVia</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sink</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="c1">// allowed because of 'older p' on ReachableVia</span>
<span class="p">}</span>

<span class="kr">ghost</span> <span class="kr">predicate</span> <span class="n">ReachableVia</span><span class="p">(</span><span class="n">source</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">older</span> <span class="n">p</span><span class="o">:</span> <span class="n">Path</span><span class="p">,</span> <span class="n">sink</span><span class="o">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">S</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="kr">reads</span> <span class="n">S</span>
  <span class="kr">decreases</span> <span class="n">p</span>
<span class="p">{</span>
  <span class="kr">match</span> <span class="n">p</span>
  <span class="kr">case</span> <span class="n">Empty</span> <span class="o">=&gt;</span>
    <span class="n">source</span> <span class="o">==</span> <span class="n">sink</span>
  <span class="kr">case</span> <span class="n">Extend</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="n">n</span> <span class="ow">in</span> <span class="n">S</span> <span class="o">&amp;&amp;</span> <span class="n">sink</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="o">&amp;&amp;</span> <span class="n">ReachableVia</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This example is more involved than the simpler <code class="language-dafny highlighter-rouge"><span class="n">In</span></code> example
above. Because of the <code class="language-dafny highlighter-rouge"><span class="n">older</span></code> modifier on the parameter, the quantifier in
<code class="language-dafny highlighter-rouge"><span class="n">Reachable</span></code> is allowed. For intuition, you can think of the effect of
<code class="language-dafny highlighter-rouge"><span class="n">older</span> <span class="n">p</span></code> as adding an antecedent <code class="language-dafny highlighter-rouge"><span class="n">p</span> <span class="ow">in</span> <span class="p">{</span><span class="n">source</span><span class="p">}</span> <span class="o">+</span> <span class="p">{</span><span class="n">sink</span><span class="p">}</span> <span class="o">+</span> <span class="n">S</span></code>
(but, as we have seen, this is not type correct). The semantic check
imposed on the body of <code class="language-dafny highlighter-rouge"><span class="n">ReachableVia</span></code> makes sure that, if the
predicate returns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>, then every object reference in <code class="language-dafny highlighter-rouge"><span class="n">p</span></code> is as old
as some object reference in another parameter to the predicate.</p>

<h3 id="65-nameonly-formal-parameters-and-default-value-expressions">6.5. Nameonly Formal Parameters and Default-Value Expressions</h3>

<p>A formal parameter of a method, constructor in a class, iterator,
function, or datatype constructor can be declared with an expression
denoting a <em>default value</em>. This makes the parameter <em>optional</em>,
as opposed to <em>required</em>.</p>

<p>For example,
<!-- %check-resolve %save f.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
</code></pre></div></div>
<p>may be called as either
<!-- %check-resolve %use f.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="kr">const</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>
<p>where <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code> is equivalent to <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span></code> in this case.</p>

<p>The above function may also be called as
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>
<p>using names; actual arguments with names may be given in any order,
though they must be after actual arguments without names.</p>

<p>Formal parameters may also be declared <code class="language-dafny highlighter-rouge"><span class="kr">nameonly</span></code>, in which case a call site
must always explicitly name the formal when providing its actual argument.</p>

<p>For example, a function <code class="language-dafny highlighter-rouge"><span class="n">ff</span></code> declared as
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">ff</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="kr">nameonly</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
</code></pre></div></div>
<p>must be called either by listing the value for x and then y with a name,
as in <code class="language-dafny highlighter-rouge"><span class="n">ff</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">4</span><span class="p">)</span></code> or by giving both actuals by name (in any order).
A <code class="language-dafny highlighter-rouge"><span class="kr">nameonly</span></code> formal may also have a default value and thus be optional.</p>

<p>Any formals after a <code class="language-dafny highlighter-rouge"><span class="kr">nameonly</span></code> formal must either be <code class="language-dafny highlighter-rouge"><span class="kr">nameonly</span></code> themselves or have default values.</p>

<p>The formals of datatype constructors are not required to have names.
A nameless formal may not have a default value, nor may it follow a formal
that has a default value.</p>

<p>The default-value expression for a parameter is allowed to mention the
other parameters, including <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code> (for instance methods and instance
functions), but not the implicit <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span></code> parameter in least and greatest
predicates and lemmas. The default value of a parameter may mention
both preceding and subsequent parameters, but there may not be any
dependent cycle between the parameters and their default-value
expressions.</p>

<p>The <a href="#sec-assertion-batches">well-formedness</a> of default-value expressions is checked independent
of the precondition of the enclosing declaration. For a function, the
parameter default-value expressions may only read what the functions
<code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause allows. For a datatype constructor, parameter default-value
expressions may not read anything. A default-value expression may not be
involved in any recursive or mutually recursive calls with the enclosing
declaration.</p>

<!--PDF NEWPAGE-->
<h2 id="sec-specifications">7. Specifications</h2>

<p>Specifications describe logical properties of Dafny methods, functions,
lambdas, iterators and loops. They specify preconditions, postconditions,
invariants, what memory locations may be read or modified, and
termination information by means of <em>specification clauses</em>.
For each kind of specification, zero or more specification
clauses (of the type accepted for that type of specification)
may be given, in any order.</p>

<p>We document specifications at these levels:</p>

<ul>
  <li>At the lowest level are the various kinds of specification clauses,
e.g., a <code class="language-dafny highlighter-rouge"><span class="n">RequiresClause</span></code>.</li>
  <li>Next are the specifications for entities that need them,
e.g., a <code class="language-dafny highlighter-rouge"><span class="n">MethodSpec</span></code>, which typically consist of a sequence of
specification clauses.</li>
  <li>At the top level are the entity declarations that include
the specifications, e.g., <code class="language-dafny highlighter-rouge"><span class="n">MethodDecl</span></code>.</li>
</ul>

<p>This section documents the first two of these in a bottom-up manner.
We first document the clauses and then the specifications
that use them.</p>

<p>Specification clauses typically appear in a sequence. They all begin with a 
keyword and do not end with semicolons.</p>

<h3 id="sec-specification-clauses">7.1. Specification Clauses</h3>

<p>Within expressions in specification clauses, you can use
<a href="#sec-list-of-specification-expressions">specification expressions</a> along with any <a href="#sec-expressions">other expressions</a> you need.</p>

<h4 id="sec-requires-clause">7.1.1. Requires Clause (<a href="#g-requires-clause">grammar</a>)</h4>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="kc">true</span>
  <span class="kr">requires</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="kr">requires</span> <span class="n">L</span><span class="o">:</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses specify preconditions for methods,
functions, lambda expressions and iterators. Dafny checks
that the preconditions are met at all call sites. The
callee may then assume the preconditions hold on entry.</p>

<p>If no <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause is specified, then a default implicit
clause <code class="language-dafny highlighter-rouge"><span class="kr">requires</span> <span class="kc">true</span></code> is used.</p>

<p>If more than one <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause is given, then the
precondition is the conjunction of all of the expressions
from all of the <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses, with a collected list
of all the given Attributes. The order of conjunctions
(and hence the order of <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses with respect to each other)
can be important: earlier conjuncts can set conditions that
establish that later conjuncts are well-defined.</p>

<p>The attributes recognized for requires clauses are discussed in <a href="#sec-verification-attributes-on-assertions">Section 11.4</a>.</p>

<p>A requires clause can have <a href="#sec-error-attribute">custom error and success messages</a>.</p>

<h4 id="sec-ensures-clause">7.1.2. Ensures Clause (<a href="#g-ensures-clause">grammar</a>)</h4>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span>
</code></pre></div></div>

<p>An <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause specifies the post condition for a
method, function or iterator.</p>

<p>If no <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause is specified, then a default implicit
clause <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span> <span class="kc">true</span></code> is used.</p>

<p>If more than one <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause is given, then the
postcondition is the conjunction of all of the expressions
from all of the <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses, with a
collected list of all the given Attributes.
The order of conjunctions
(and hence the order of <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses with respect to each other)
can be important: earlier conjuncts can set conditions that
establish that later conjuncts are well-defined.</p>

<p>The attributes recognized for ensures clauses are discussed in <a href="#sec-verification-attributes-on-assertions">Section 11.4</a>.</p>

<p>An ensures clause can have <a href="#sec-error-attribute">custom error and success messages</a>.</p>

<h4 id="sec-decreases-clause">7.1.3. Decreases Clause (<a href="#g-decreases-clause">grammar</a>)</h4>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">decreases</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
<span class="kr">method</span> <span class="n">n</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">decreases</span> <span class="o">*</span>
</code></pre></div></div>
<p>Decreases clauses are used to prove termination in the
presence of recursion. If more than one <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause is given
it is as if a single <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause had been given with the
collected list of arguments and a collected list of Attributes. That is,</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">decreases</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>
<span class="kr">decreases</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span>
</code></pre></div></div>

<p>is equivalent to</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">decreases</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span>
</code></pre></div></div>
<p>Note that changing the order of multiple <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clauses will change
the order of the expressions within the equivalent single <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code>
clause, and will therefore have different semantics.</p>

<p>Loops and compiled methods (but not functions and not ghost methods,
including lemmas) can be specified to be possibly non-terminating.
This is done by declaring the method or loop with <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="o">*</span></code>, which
causes the proof of termination to be skipped. If a <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> is present
in a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause, no other expressions are allowed in the
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause. A method that contains a possibly non-terminating
loop or a call to a possibly non-terminating method must itself be
declared as possibly non-terminating.</p>

<p>Termination metrics in Dafny, which are declared by <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clauses,
are lexicographic tuples of expressions. At each recursive (or mutually
recursive) call to a function or method, Dafny checks that the effective
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause of the callee is strictly smaller than the effective
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause of the caller.</p>

<p>What does strictly smaller mean? Dafny provides a built-in
 well-founded order for every type and, in some cases, between types. For
 example, the Boolean <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> is strictly smaller than <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>, the
 integer <code class="language-dafny highlighter-rouge"><span class="mi">78</span></code> is strictly smaller than <code class="language-dafny highlighter-rouge"><span class="mi">102</span></code>, the set <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span></code> is strictly
 smaller than (because it is a proper subset of) the set <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span></code>, and for <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> of type <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;</span></code> where
 <code class="language-dafny highlighter-rouge"><span class="n">Color</span></code> is some inductive datatype, the color <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code> is strictly less than
 <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> (provided <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> is nonempty).</p>

<p>What does effective decreases clause mean? Dafny always appends a
top element to the lexicographic tuple given by the user. This top
element cannot be syntactically denoted in a Dafny program and it never
occurs as a run-time value either. Rather, it is a fictitious value,
which here we will denote $\top$, such that each value that can ever occur
in a Dafny program is strictly less than $\top$. Dafny sometimes also
prepends expressions to the lexicographic tuple given by the user. The
effective decreases clause is any such prefix, followed by the
user-provided decreases clause, followed by $\top$. We said user-provided
decreases clause, but if the user completely omits a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause,
then Dafny will usually make a guess at one, in which case the effective
decreases clause is any prefix followed by the guess followed by $\top$.</p>

<p>Here is a simple but interesting example: the Fibonacci function.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span> <span class="o">:</span> <span class="kt">nat</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this example, Dafny supplies a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="n">n</span></code> clause.</p>

<p>Lets take a look at the kind of example where a mysterious-looking
decreases clause like Rank, 0 is useful.</p>

<p>Consider two mutually recursive methods, <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>:
<!-- %check-verify Specifications.1.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To prove termination of <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>, Dafny needs to have effective
decreases clauses for A and B such that:</p>

<ul>
  <li>
    <p>the measure for the callee <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> is strictly smaller than the measure
for the caller <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>, and</p>
  </li>
  <li>
    <p>the measure for the callee <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></code> is strictly smaller than the measure
for the caller <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>.</p>
  </li>
</ul>

<p>Satisfying the second of these conditions is easy, but what about the
first? Note, for example, that declaring both <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> with decreases x
does not work, because that wont prove a strict decrease for the call
from <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>.</p>

<p>Heres one possibility:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">decreases</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
<span class="p">{</span>
  <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">decreases</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For the call from <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>, the lexicographic tuple <code class="language-dafny highlighter-rouge"><span class="s2">"x, 0"</span></code> is
strictly smaller than <code class="language-dafny highlighter-rouge"><span class="s2">"x, 1"</span></code>, and for the call from <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></code>, the
lexicographic tuple <code class="language-dafny highlighter-rouge"><span class="s2">"x-1, 1"</span></code> is strictly smaller than <code class="language-dafny highlighter-rouge"><span class="s2">"x, 0"</span></code>.</p>

<p>Two things to note: First, the choice of 0 and 1 as the second
 components of these lexicographic tuples is rather arbitrary. It could
 just as well have been false and true, respectively, or the sets
 <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span></code> and <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span></code>. Second, the keyword <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> often gives rise to
 an intuitive English reading of the declaration. For example, you might
 say that the recursive calls in the definition of the familiar Fibonacci
 function <code class="language-dafny highlighter-rouge"><span class="n">Fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></code> decreases n. But when the lexicographic tuple contains
 constants, the English reading of the declaration becomes mysterious and
 may give rise to questions like how can you decrease the constant 0?.
 The keyword is just thata keyword. It says here comes a list of
 expressions that make up the lexicographic tuple we want to use for the
 termination measure. What is important is that one effective decreases
 clause is compared against another one, and it certainly makes sense to
 compare something to a constant (and to compare one constant to
 another).</p>

<p>We can simplify things a little bit by remembering that Dafny appends
 $\top$ to the user-supplied decreases clause. For the A-and-B example,
 this lets us drop the constant from the <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause of A:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
   <span class="kr">decreases</span> <span class="n">x</span>
<span class="p">{</span>
  <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">decreases</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The effective decreases clause of <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> is $(x, \top)$ and the effective
decreases clause of <code class="language-dafny highlighter-rouge"><span class="n">B</span></code> is $(x, 0, \top)$. These tuples still satisfy the two
conditions $(x, 0, \top) &lt; (x, \top)$ and $(x-1, \top) &lt; (x, 0, \top)$. And
as before, the constant 0 is arbitrary; anything less than $\top$ (which
is any Dafny expression) would work.</p>

<p>Lets take a look at one more example that better illustrates the utility
of $\top$. Consider again two mutually recursive methods, call them <code class="language-dafny highlighter-rouge"><span class="n">Outer</span></code>
and <code class="language-dafny highlighter-rouge"><span class="n">Inner</span></code>, representing the recursive counterparts of what iteratively
might be two nested loops:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Outer</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// set y to an arbitrary non-negative integer</span>
  <span class="kr">var</span> <span class="n">y</span> <span class="o">:|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">Outer</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The body of <code class="language-dafny highlighter-rouge"><span class="n">Outer</span></code> uses an assign-such-that statement to represent some
computation that takes place before <code class="language-dafny highlighter-rouge"><span class="n">Inner</span></code> is called. It sets y to some
arbitrary non-negative value. In a more concrete example, <code class="language-dafny highlighter-rouge"><span class="n">Inner</span></code> would do
some work for each y and then continue as <code class="language-dafny highlighter-rouge"><span class="n">Outer</span></code> on the next smaller
x.</p>

<p>Using a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause $(x, y)$ for <code class="language-dafny highlighter-rouge"><span class="n">Inner</span></code> seems natural, but if
we dont have any bound on the size of the $y$ computed by <code class="language-dafny highlighter-rouge"><span class="n">Outer</span></code>,
there is no expression we can write in the <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause of <code class="language-dafny highlighter-rouge"><span class="n">Outer</span></code>
that is sure to lead to a strictly smaller value for $y$ when <code class="language-dafny highlighter-rouge"><span class="n">Inner</span></code>
is called. $\top$ to the rescue. If we arrange for the effective
decreases clause of <code class="language-dafny highlighter-rouge"><span class="n">Outer</span></code> to be $(x, \top)$ and the effective decreases
clause for <code class="language-dafny highlighter-rouge"><span class="n">Inner</span></code> to be $(x, y, \top)$, then we can show the strict
decreases as required. Since $\top$ is implicitly appended, the two
decreases clauses declared in the program text can be:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Outer</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">decreases</span> <span class="n">x</span>
<span class="p">{</span>
  <span class="c1">// set y to an arbitrary non-negative integer</span>
  <span class="kr">var</span> <span class="n">y</span> <span class="o">:|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">decreases</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">Outer</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Moreover, remember that if a function or method has no user-declared
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause, Dafny will make a guess. The guess is (usually)
the list of arguments of the function/method, in the order given. This is
exactly the decreases clauses needed here. Thus, Dafny successfully
verifies the program without any explicit <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clauses:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Outer</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">y</span> <span class="o">:|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">Outer</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The ingredients are simple, but the end result may seem like magic. 
For many users, however, there may be no magic at all 
 the end result may be so natural that the user never even has to 
be bothered to think about that there was a need to prove 
termination in the first place.</p>

<p>Dafny also prepends two expressions to the user-specified (or guessed) tuple of expressions
in the decreases clause. The first expression is the ordering of
the module containing the decreases clause in the dependence-ordering of 
modules. That is, a module that neither imports or defines (as submodules) any other modules 
has the lowest value in the order and every other module has a value that is higher than
that of any module it defines or imports. As a module cannot call a method in a
module that it does not depend on, this is an effective first component to the
overall decreases tuple.</p>

<p>The second prepended expression represents the position
of the method in the call graph within a module. Dafny analyzes the call-graph of the 
module, grouping all methods into mutually-recursive groups.
Any method that calls nothing else is at the lowest level (say level 0).
Absent recursion, every method has a level value strictly greater than any method it calls.
Methods that are mutually recursive are at the same level and they are above
the level of anything else they call. With this level value prepended to 
the decreases clause, the decreases tuple automatically decreases on any
calls in a non-recursive context.</p>

<p>Though Dafny fixes a well-founded order that it uses when checking
termination, Dafny does not normally surface this ordering directly in
expressions. However, it is possible to write such ordering constraints
using <a href="#sec-termination-ordering-expressions"><code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="kr">to</span></code> expressions</a>.</p>

<h4 id="sec-frame-expression">7.1.4. Framing (<a href="#g-frame-expression">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="o">*</span>
<span class="n">o</span>
<span class="n">o</span><span class="p">`</span><span class="n">a</span>
<span class="p">`</span><span class="n">a</span>
<span class="p">{</span> <span class="n">o</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="p">}</span>
<span class="p">{}</span>
</code></pre></div></div>

<p>Frame expressions are used to denote the set of memory locations
that a Dafny program element may read or write. 
They are used in <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clauses.
A frame expression is a set expression. The form <code class="language-dafny highlighter-rouge"><span class="p">{}</span></code> is the empty set.
The type of the frame expression is <code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span></code>.</p>

<p>Note that framing only applies to the heap, or memory accessed through
references. Local variables are not stored on the heap, so they cannot be
mentioned (well, they are not in scope in the declaration) in frame
annotations. Note also that types like sets, sequences, and multisets are
value types, and are treated like integers or local variables. Arrays and
objects are reference types, and they are stored on the heap (though as
always there is a subtle distinction between the reference itself and the
value it points to.)</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">FrameField</span></code> construct is used to specify a field of a
class object. The identifier following the back-quote is the
name of the field being referenced.
If the <code class="language-dafny highlighter-rouge"><span class="n">FrameField</span></code> is preceded by an expression the expression
must be a reference to an object having that field.
If the <code class="language-dafny highlighter-rouge"><span class="n">FrameField</span></code> is not preceded by an expression then
the frame expression is referring to that field of the current
object (<code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>). This form is only used within a method of a class or trait.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">FrameField</span></code> can be useful in the following case:
When a method modifies only one field, rather than writing</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x0</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x1</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x2</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x3</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x4</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">method</span> <span class="n">M</span><span class="p">()</span>
    <span class="kr">modifies</span> <span class="kr">this</span>
    <span class="kr">ensures</span> <span class="kr">unchanged</span><span class="p">(`</span><span class="n">x0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">unchanged</span><span class="p">(`</span><span class="n">x1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">unchanged</span><span class="p">(`</span><span class="n">x2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">unchanged</span><span class="p">(`</span><span class="n">x3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">unchanged</span><span class="p">(`</span><span class="n">x4</span><span class="p">)</span>
  <span class="p">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>one can write the more concise:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x0</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x1</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x2</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x3</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">x4</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">method</span> <span class="n">M</span><span class="p">()</span>
    <span class="kr">modifies</span> <span class="p">`</span><span class="n">i</span>
  <span class="p">{</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Theres (unfortunately) no form of it for array
elements  but to account for unchanged elements, you can always write
<code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="o">::</span> <span class="kr">unchanged</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></code>.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">FrameField</span></code> is not taken into consideration for
lambda expressions.</p>

<h4 id="sec-reads-clause">7.1.5. Reads Clause (<a href="#g-reads-clause">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">o</span><span class="o">:</span> <span class="kt">object</span>
<span class="kr">const</span> <span class="n">o</span><span class="p">,</span> <span class="n">oo</span><span class="o">:</span> <span class="kt">object</span>
<span class="kr">function</span> <span class="n">f</span><span class="p">()</span>
  <span class="kr">reads</span> <span class="o">*</span>
<span class="kr">function</span> <span class="n">g</span><span class="p">()</span>
  <span class="kr">reads</span> <span class="n">o</span><span class="p">,</span> <span class="n">oo</span>
<span class="kr">function</span> <span class="n">h</span><span class="p">()</span>
  <span class="kr">reads</span> <span class="p">{</span> <span class="n">o</span> <span class="p">}</span>
<span class="kr">method</span> <span class="n">f</span><span class="p">()</span>
  <span class="kr">reads</span> <span class="o">*</span>
<span class="kr">method</span> <span class="n">g</span><span class="p">()</span>
  <span class="kr">reads</span> <span class="n">o</span><span class="p">,</span> <span class="n">oo</span>
<span class="kr">method</span> <span class="n">h</span><span class="p">()</span>
  <span class="kr">reads</span> <span class="p">{</span> <span class="n">o</span> <span class="p">}</span>
</code></pre></div></div>

<p>Functions are not allowed to have side effects; they may also be restricted in
what they can read. The <em>reading frame</em> of a function (or predicate) consists of all
the heap memory locations that the function is allowed to read. The reason we
might limit what a function can read is so that when we write to memory,
we can be sure that functions that did not read that part of memory have
the same value they did before. For example, we might have two arrays,
one of which we know is sorted. If we did not put a reads annotation on
the sorted predicate, then when we modify the unsorted array, we cannot
determine whether the other array stopped being sorted. While we might be
able to give invariants to preserve it in this case, it gets even more
complex when manipulating data structures. In this case, framing is
essential to making the verification process feasible.</p>

<p>By default, methods are not required to list the memory location they read.
However, there are use cases for restricting what methods can read as well.
In particular, if you want to verify that imperative code is safe to execute concurrently when compiled,
you can specify that a method does not read or write any shared state,
and therefore cannot encounter race conditions or runtime crashes related to
unsafe communication between concurrent executions.
See <a href="#sec-concurrent-attribute">the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">concurrent</span><span class="p">}</span></code> attribute</a> for more details.</p>

<p>It is not just the body of a function or method that is subject to <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code>
checks, but also its precondition and the <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause itself.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause can list a wildcard <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, which allows the enclosing
function or method to read anything. 
This is the implicit default for methods with no <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses,
allowing methods to read whatever they like.
The default for functions, however, is to not allow reading any memory.
Allowing functions to read arbitrary memory is more problematic:
in many cases, and in particular in all cases
where the function is defined recursively, this makes it next to
impossible to make any use of the function. Nevertheless, as an
experimental feature, the language allows it (and it is sound).
If a <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause uses <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, then the <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause is not allowed to
mention anything else (since anything else would be irrelevant, anyhow).</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause specifies the set of memory locations that a function,
lambda, or method may read. The readable memory locations are all the fields
of all of the references given in the set specified in the frame expression
and the single fields given in <a href="#sec-frame-expression"><code class="language-dafny highlighter-rouge"><span class="n">FrameField</span></code></a> elements of the frame expression.
For example, in
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">var</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span>

  <span class="kr">predicate</span> <span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="n">C</span><span class="p">)</span> 
    <span class="kr">reads</span> <span class="kr">this</span><span class="p">,</span> <span class="n">c</span><span class="p">`</span><span class="n">x</span>
  <span class="p">{</span>
    <span class="kr">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">x</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>the <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause allows reading <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">x</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="p">,</span><span class="n">y</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">c</span><span class="o">.</span><span class="n">x</span></code> (which may be the same
memory location as <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">x</span></code>).
}</p>

<p>If more than one <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause is given
in a specification the effective read set is the union of the sets
specified. If there are no <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses the effective read set is
empty. If <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> is given in a <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause it means any memory may be
read.</p>

<p>If a <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause refers to a sequence or multiset, that collection
(call it <code class="language-dafny highlighter-rouge"><span class="n">c</span></code>) is converted to a set by adding an implicit set
comprehension of the form <code class="language-dafny highlighter-rouge"><span class="kt">set</span> <span class="n">o</span><span class="o">:</span> <span class="kt">object</span> <span class="o">|</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">c</span></code> before computing the
union of object sets from other <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses.</p>

<p>An expression in a <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause is also allowed to be a function call whose value is 
a collection of references. Such an expression is converted to a set by taking the
union of the functions image over all inputs. For example, if <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> is
a function from <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> to <code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span></code>, then <code class="language-dafny highlighter-rouge"><span class="kr">reads</span> <span class="n">F</span></code> has the meaning</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">set</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">o</span><span class="o">:</span> <span class="kt">object</span> <span class="o">|</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">::</span> <span class="n">o</span>
</code></pre></div></div>

<p>For each function value <code class="language-dafny highlighter-rouge"><span class="n">f</span></code>, Dafny defines the function <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">reads</span></code>,
which takes the same arguments as <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> and returns that set of objects
that <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> reads (according to its reads clause) with those arguments.
<code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="o">.</span><span class="kr">reads</span></code> has type <code class="language-dafny highlighter-rouge"><span class="n">T</span> <span class="err">~</span><span class="o">&gt;</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span></code>, where <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is the input type(s) of <code class="language-dafny highlighter-rouge"><span class="n">f</span></code>.</p>

<p>This is particularly useful when wanting to specify the reads set of
another function. For example, function <code class="language-dafny highlighter-rouge"><span class="n">Sum</span></code> adds up the values of
<code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> ranges from <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code>:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">Sum</span><span class="p">(</span><span class="n">f</span><span class="o">:</span> <span class="kt">int</span> <span class="err">~</span><span class="o">&gt;</span> <span class="kt">real</span><span class="p">,</span> <span class="n">lo</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hi</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">real</span>
  <span class="kr">requires</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span>
  <span class="kr">requires</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">::</span> <span class="n">f</span><span class="o">.</span><span class="kr">requires</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="kr">reads</span> <span class="n">f</span><span class="o">.</span><span class="kr">reads</span>
  <span class="kr">decreases</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span> <span class="kr">then</span> <span class="mf">0.0</span> <span class="kr">else</span>
    <span class="n">f</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="o">+</span> <span class="n">Sum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Its <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> specification says that <code class="language-dafny highlighter-rouge"><span class="n">Sum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span></code> may read anything
that <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> may read on any input.  (The specification
<code class="language-dafny highlighter-rouge"><span class="kr">reads</span> <span class="n">f</span><span class="o">.</span><span class="kr">reads</span></code> gives an overapproximation of what <code class="language-dafny highlighter-rouge"><span class="n">Sum</span></code> will actually
read. More precise would be to specify that <code class="language-dafny highlighter-rouge"><span class="n">Sum</span></code> reads only what <code class="language-dafny highlighter-rouge"><span class="n">f</span></code>
reads on the values from <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code>, but the larger set denoted by
<code class="language-dafny highlighter-rouge"><span class="kr">reads</span> <span class="n">f</span><span class="o">.</span><span class="kr">reads</span></code> is easier to write down and is often good enough.)</p>

<p>Without such <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> function, one could also write the more precise
and more verbose:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">Sum</span><span class="p">(</span><span class="n">f</span><span class="o">:</span> <span class="kt">int</span> <span class="err">~</span><span class="o">&gt;</span> <span class="kt">real</span><span class="p">,</span> <span class="n">lo</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hi</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">real</span>
  <span class="kr">requires</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span>
  <span class="kr">requires</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">::</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">==&gt;</span> <span class="n">f</span><span class="o">.</span><span class="kr">requires</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="kr">reads</span> <span class="kt">set</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="o">|</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="kr">reads</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">::</span> <span class="n">o</span>
  <span class="kr">decreases</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span> <span class="kr">then</span> <span class="mf">0.0</span> <span class="kr">else</span>
    <span class="n">f</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="o">+</span> <span class="n">Sum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note, only <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses, not <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clauses, are allowed to
include functions as just described.</p>

<p>Iterator specifications also allow <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses,
with the same syntax and interpretation of arguments as above,
but the meaning is quite different!
See <a href="#sec-iterator-types">Section 5.11</a> for more details.</p>

<h4 id="sec-modifies-clause">7.1.6. Modifies Clause (<a href="#g-modifies-clause">grammar</a>)</h4>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span> <span class="p">{</span> <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span> <span class="p">}</span>
<span class="kr">const</span> <span class="n">o</span><span class="o">:</span> <span class="kt">object?</span>
<span class="kr">const</span> <span class="n">p</span><span class="o">:</span> <span class="n">A?</span>
<span class="kr">method</span> <span class="n">M</span><span class="p">()</span>
  <span class="kr">modifies</span> <span class="p">{</span> <span class="n">o</span><span class="p">,</span> <span class="n">p</span> <span class="p">}</span>
<span class="kr">method</span> <span class="n">N</span><span class="p">()</span>
  <span class="kr">modifies</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">method</span> <span class="n">Q</span><span class="p">()</span>
  <span class="kr">modifies</span> <span class="n">o</span><span class="p">,</span> <span class="n">p</span><span class="p">`</span><span class="n">f</span>
</code></pre></div></div>

<p>By default, methods are allowed to read
whatever memory they like, but they are required to list which parts of
memory they modify, with a <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> annotation. These are almost identical
to their <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> cousins, except they say what can be changed, rather than
what the definition depends on. In combination with reads,
modification restrictions allow Dafny to prove properties of code that
would otherwise be very difficult or impossible. Reads and modifies are
one of the tools that allow Dafny to work on one method at a time,
because they restrict what would otherwise be arbitrary modifications of
memory to something that Dafny can reason about.</p>

<p>Just as for a <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause, the memory locations allowed to be modified
in a method are all the fields of any object reference in the frame expression
set and any specific field denoted by a <a href="#sec-frame-expression"><code class="language-dafny highlighter-rouge"><span class="n">FrameField</span></code></a> in the <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause.
For example, in
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">next</span><span class="o">:</span> <span class="n">C?</span>
  <span class="kr">var</span> <span class="n">value</span><span class="o">:</span> <span class="kt">int</span>

  <span class="kr">method</span> <span class="n">M</span><span class="p">()</span> 
    <span class="kr">modifies</span> <span class="n">next</span>
  <span class="p">{</span> 
    <span class="o">...</span> 
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>method <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> is permitted to modify <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">value</span></code>
but not <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">next</span></code>. To be allowed to modify <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">next</span></code>, the modifies clause
must include <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>, or some expression that evaluates to <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code>, or <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="p">`</span><span class="n">next</span></code>.</p>

<p>If an object is newly allocated within the body of a method
or within the scope of a <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> statement or a loops <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause,
 then the fields of that object may always be modified.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause specifies the set of memory locations that a
method, iterator or loop body may modify. If more than one <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code>
clause is given in a specification, the effective modifies set is the
union of the sets specified. If no <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause is given the
effective modifies set is empty. There is no wildcard (<code class="language-dafny highlighter-rouge"><span class="o">*</span></code>) allowed in
a modifies clause. A loop can also have a
<code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause. If none is given, the loop may modify anything
the enclosing context is allowed to modify.</p>

<p>Note that <em>modifies</em> here is used in the sense of <em>writes</em>. That is, a field
that may not be modified may not be written to, even with the same value it
already has or even if the value is restored later. The terminology and
semantics varies among specification languages. Some define frame conditions
in this sense (a) of <em>writes</em> and others in the sense (b) that allows writing
a field with the same value or changing the value so long as the original
value is restored by the end of the scope. For example, JML defines
<code class="language-dafny highlighter-rouge"><span class="n">assignable</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> as synonyms in the sense (a), though KeY
interprets JMLs <code class="language-dafny highlighter-rouge"><span class="n">assigns</span><span class="o">/</span><span class="kr">modifies</span></code> in sense (b).
ACSL and ACSL++ use the <code class="language-dafny highlighter-rouge"><span class="n">assigns</span></code> keyword, but with <em>modify</em> (b) semantics.
Ada/SPARKs dataflow contracts encode <em>write</em> (a) semantics.</p>

<h4 id="sec-invariant-clause">7.1.7. Invariant Clause (<a href="#g-invariant-clause">grammar</a>)</h4>

<p>Examples:
<!-- %check-resolve-warn Specifications.2.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kr">while</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span>
    <span class="kr">invariant</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span>
<span class="p">}</span>
</code></pre></div></div>

<p>An <code class="language-dafny highlighter-rouge"><span class="kr">invariant</span></code> clause is used to specify an invariant
for a loop. If more than one <code class="language-dafny highlighter-rouge"><span class="kr">invariant</span></code> clause is given for
a loop, the effective invariant is the conjunction of
the conditions specified, in the order given in the source text.</p>

<p>The invariant must hold on entry to the loop. And assuming it
is valid on entry to a particular iteration of the loop, 
Dafny must be able to prove that it then
holds at the end of that iteration of the loop.</p>

<p>An invariant can have <a href="#sec-error-attribute">custom error and success messages</a>.</p>

<h3 id="sec-method-specification">7.2. Method Specification (<a href="#g-method-specification">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">next</span><span class="o">:</span> <span class="n">C?</span>
  <span class="kr">var</span> <span class="n">value</span><span class="o">:</span> <span class="kt">int</span>

  <span class="kr">method</span> <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
    <span class="kr">requires</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="kr">modifies</span> <span class="n">next</span>
    <span class="kr">decreases</span> <span class="n">i</span>
    <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span>
  <span class="p">{</span> 
    <span class="o">...</span> 
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A method specification consists of zero or more <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code>,
<code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clauses, in any order.
A method does not need <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses in most cases,
because methods are allowed to read any memory by default,
but <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses are supported for use cases such as verifying safe concurrent execution.
See <a href="#sec-concurrent-attribute">the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">concurrent</span><span class="p">}</span></code> attribute</a> for more details.</p>

<h3 id="sec-function-specification">7.3. Function Specification (<a href="#g-function-specification">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">next</span><span class="o">:</span> <span class="n">C?</span>
  <span class="kr">var</span> <span class="n">value</span><span class="o">:</span> <span class="kt">int</span>

  <span class="kr">function</span> <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
    <span class="kr">requires</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="kr">reads</span> <span class="kr">this</span>
    <span class="kr">decreases</span> <span class="n">i</span>
    <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span>
  <span class="p">{</span> 
    <span class="mi">0</span> 
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A function specification is zero or more <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code>,
<code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clauses, in any order. A function
specification does not have <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clauses because functions are not
allowed to modify any memory.</p>

<h3 id="sec-lambda-specification">7.4. Lambda Specification (<a href="#g-lambda-specification">grammar</a>)</h3>

<p>A lambda specification provides a specification for a lambda function expression;
it consists of zero or more <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses.
Any <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses may not have labels or attributes.
Lambda specifications do not have <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses because the body
is never opaque.
Lambda specifications do not have <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code>
clauses because lambda expressions do not have names and thus cannot be recursive. A
lambda specification does not have <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clauses because lambdas
are not allowed to modify any memory.</p>

<h3 id="sec-iterator-specification">7.5. Iterator Specification (<a href="#g-iterator-specification">grammar</a>)</h3>

<p>An iterator specification may contains <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code>, 
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">yield</span> <span class="kr">requires</span><span class="p">,</span> </code>ensures<code class="language-dafny highlighter-rouge">
<span class="n">and</span> </code>yield ensures` clauses.</p>

<p>An iterator specification applies both to the iterators constructor
method and to its <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code> method.</p>
<ul>
  <li>The <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code>
clauses apply to both of them (but <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses have a <a href="#sec-iterator-types">different meaning on iterators</a> than on functions or methods).</li>
  <li>The <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses apply to the constructor.</li>
  <li>The <code class="language-dafny highlighter-rouge"><span class="kr">yield</span> <span class="kr">requires</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">yield</span> <span class="kr">ensures</span></code> clauses apply to the <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code> method.</li>
</ul>

<p>Examples of iterators, including iterator specifications, are given in
<a href="#sec-iterator-types">Section 5.11</a>. Briefly</p>
<ul>
  <li>a requires clause gives a precondition for creating an iterator</li>
  <li>an ensures clause gives a postcondition when the iterator exits (after all iterations are complete)</li>
  <li>a decreases clause is used to show that the iterator will eventually terminate</li>
  <li>a yield requires clause is a precondition for calling <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code></li>
  <li>a yield ensures clause is a postcondition for calling <code class="language-dafny highlighter-rouge"><span class="n">MoveNext</span></code></li>
  <li>a reads clause gives a set of memory locations that will be unchanged after a <code class="language-dafny highlighter-rouge"><span class="kr">yield</span></code> statement</li>
  <li>a modifies clause gives a set of memory locations the iterator may write to</li>
</ul>

<h3 id="sec-loop-specification">7.6. Loop Specification (<a href="#g-loop-specification">grammar</a>)</h3>

<p>A loop specification provides the information Dafny needs to
prove properties of a loop. It contains <code class="language-dafny highlighter-rouge"><span class="kr">invariant</span></code>,
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code>, and <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clauses.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">invariant</span></code> clause
is effectively a precondition and it along with the
negation of the loop test condition provides the postcondition.
The <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause is used to prove termination.</p>

<h3 id="77-auto-generated-boilerplate-specifications">7.7. Auto-generated boilerplate specifications</h3>

<p>AutoContracts is an experimental feature that inserts much of the dynamic-frames boilerplate
into a class. The user simply</p>
<ul>
  <li>marks the class with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autocontracts</span><span class="p">}</span></code> and</li>
  <li>declares a function (or predicate) called Valid().</li>
</ul>

<p>AutoContracts then</p>

<ul>
  <li>Declares, unless there already exist members with these names:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ghost</span> <span class="kr">var</span> <span class="n">Repr</span><span class="o">:</span> <span class="kt">set</span><span class="p">(</span><span class="kt">object</span><span class="p">)</span>
<span class="kr">predicate</span> <span class="n">Valid</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>For function/predicate <code class="language-dafny highlighter-rouge"><span class="n">Valid</span><span class="p">()</span></code>, inserts
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">reads</span> <span class="kr">this</span><span class="p">,</span> <span class="n">Repr</span>
<span class="kr">ensures</span> <span class="n">Valid</span><span class="p">()</span> <span class="o">==&gt;</span> <span class="kr">this</span> <span class="ow">in</span> <span class="n">Repr</span>
</code></pre></div>    </div>
  </li>
  <li>Into body of <code class="language-dafny highlighter-rouge"><span class="n">Valid</span><span class="p">()</span></code>, inserts (at the beginning of the body)
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">this</span> <span class="ow">in</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="kc">null</span> <span class="o">!</span><span class="ow">in</span> <span class="n">Repr</span>
</code></pre></div>    </div>
    <p>and also inserts, for every array-valued field <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> declared in the class:
<!-- %no-check --></p>
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">==&gt;</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">Repr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</code></pre></div>    </div>
    <p>and for every field <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> of a class type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> has a field called <code class="language-dafny highlighter-rouge"><span class="n">Repr</span></code>, also inserts
<!-- %no-check --></p>
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">(</span><span class="n">F</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">==&gt;</span> <span class="n">F</span> <span class="ow">in</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="n">F</span><span class="o">.</span><span class="n">Repr</span> <span class="n">SUBSET</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="kr">this</span> <span class="o">!</span><span class="ow">in</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="n">F</span><span class="o">.</span><span class="n">Valid</span><span class="p">())</span>
</code></pre></div>    </div>
    <p>except, if <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> is declared with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autocontracts</span> <span class="kc">false</span><span class="p">}</span></code>, then the implication will not
be added.</p>
  </li>
  <li>For every constructor, inserts
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ensures</span> <span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="kr">fresh</span><span class="p">(</span><span class="n">Repr</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>At the end of the body of the constructor, adds
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="n">Repr</span> <span class="o">:=</span> <span class="p">{</span><span class="kr">this</span><span class="p">};</span>
 <span class="kr">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">Repr</span> <span class="o">:=</span> <span class="n">Repr</span> <span class="o">+</span> <span class="p">{</span><span class="n">A</span><span class="p">};</span> <span class="p">}</span>
 <span class="kr">if</span> <span class="p">(</span><span class="n">F</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">Repr</span> <span class="o">:=</span> <span class="n">Repr</span> <span class="o">+</span> <span class="p">{</span><span class="n">F</span><span class="p">}</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">Repr</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>In all the following cases, no <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause or <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause is added if the user
has given one.</p>

<ul>
  <li>For every non-static non-ghost method that is not a simple query method,
inserts
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">requires</span> <span class="n">Valid</span><span class="p">()</span>
 <span class="kr">modifies</span> <span class="n">Repr</span>
 <span class="kr">ensures</span> <span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="kr">fresh</span><span class="p">(</span><span class="n">Repr</span> <span class="o">-</span> <span class="kr">old</span><span class="p">(</span><span class="n">Repr</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li>At the end of the body of the method, inserts
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">A</span> <span class="ow">in</span> <span class="n">Repr</span><span class="p">))</span> <span class="p">{</span> <span class="n">Repr</span> <span class="o">:=</span> <span class="n">Repr</span> <span class="o">+</span> <span class="p">{</span><span class="n">A</span><span class="p">};</span> <span class="p">}</span>
 <span class="kr">if</span> <span class="p">(</span><span class="n">F</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">F</span> <span class="ow">in</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="n">F</span><span class="o">.</span><span class="n">Repr</span> <span class="n">SUBSET</span> <span class="n">Repr</span><span class="p">))</span> <span class="p">{</span> <span class="n">Repr</span> <span class="o">:=</span> <span class="n">Repr</span> <span class="o">+</span> <span class="p">{</span><span class="n">F</span><span class="p">}</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">Repr</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>For every non-static non-twostate method that is either ghost or is a simple query method,
add:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">requires</span> <span class="n">Valid</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>For every non-static twostate method, inserts
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">requires</span> <span class="kr">old</span><span class="p">(</span><span class="n">Valid</span><span class="p">())</span>
</code></pre></div>    </div>
  </li>
  <li>For every non-Valid non-static function, inserts
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">requires</span> <span class="n">Valid</span><span class="p">()</span>
 <span class="kr">reads</span> <span class="n">Repr</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="sec-well-formedness-specifications">7.8. Well-formedness of specifications</h3>

<p>Dafny ensures that the <a href="#sec-requires-clause"><code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses</a>
and <a href="#sec-ensures-clause"><code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses</a>, which are expressions,
are <a href="#sec-assertion-batches">well-formed</a> independent of the body
they belong to.
Examples of conditions this rules out are null pointer dereferencing,
out-of-bounds array access, and division by zero.
Hence, when declaring the following method:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Test</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">j</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">&gt;=</span> <span class="mi">1</span>
  <span class="kr">ensures</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">==&gt;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span>
<span class="p">{</span>
  <span class="n">j</span> <span class="o">:=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">divisor</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">divisor</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">j</span> <span class="o">:=</span> <span class="n">j</span> <span class="o">/</span> <span class="n">divisor</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dafny will split the verification in two <a href="#sec-assertion-batches">assertion batches</a>
that will roughly look like the following lemmas:</p>

<!-- %check-verify %options --allow-axioms -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">lemma</span> <span class="n">Test_WellFormed</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">array?</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">assume</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>       <span class="c1">// From the definition of a</span>
  <span class="kr">assert</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>       <span class="c1">// for the `requires a.Length &gt;= 1`</span>
  <span class="kr">assume</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// After well-formedness, we assume the requires</span>
  <span class="kr">assert</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>       <span class="c1">// Again for the `a.Length % 2`</span>
  <span class="kr">if</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>     <span class="c1">// Again for the final `a.Length`</span>
    <span class="kr">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Because of the 10 / a.Length</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Test_Correctness</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">array?</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span> <span class="c1">// Here we assume the well-formedness of the condition</span>
  <span class="kr">assume</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>       <span class="c1">// for the `requires a.Length &gt;= 1`</span>
  <span class="kr">assume</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>       <span class="c1">// Again for the `a.Length % 2`</span>
  <span class="kr">if</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="kr">assume</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>     <span class="c1">// Again for the final `a.Length`</span>
    <span class="kr">assume</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Because of the 10 / a.Length</span>
  <span class="p">}</span>

  <span class="c1">// Now the body is translated</span>
  <span class="kr">var</span> <span class="n">j</span> <span class="o">:=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>          <span class="c1">// For `var divisor := a.Length;`</span>
  <span class="kr">var</span> <span class="n">divisor</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span><span class="p">;</span>
  <span class="kr">if</span> <span class="o">*</span> <span class="p">{</span>
    <span class="kr">assume</span> <span class="n">divisor</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">j</span> <span class="o">:=</span> <span class="n">j</span> <span class="o">/</span> <span class="n">divisor</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">assume</span> <span class="n">divisor</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">==&gt;</span> <span class="n">divisor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">==&gt;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For this reason the IDE typically reports at least two <a href="#sec-assertion-batches">assertion batches</a>
when hovering a method.</p>

<!--PDF NEWPAGE-->
<h2 id="sec-statements">8. Statements (<a href="#g-statement">grammar</a>)</h2>

<p>Many of Dafnys statements are similar to those in traditional
programming languages, but a number of them are significantly different.
Dafnys various kinds of statements are described in subsequent sections.</p>

<p>Statements have zero or more labels and end with either a semicolon (<code class="language-dafny highlighter-rouge"><span class="p">;</span></code>) or a closing curly brace (}).</p>

<h3 id="sec-labeled-statement">8.1. Labeled Statement (<a href="#g-labeled-statement">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span> <span class="p">{</span> <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span> <span class="p">}</span>
<span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">label</span> <span class="n">x</span><span class="o">:</span>
  <span class="kr">while</span> <span class="kc">true</span> <span class="p">{</span>
     <span class="kr">if</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span> <span class="kr">break</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">a</span><span class="o">.</span><span class="n">f</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">label</span> <span class="n">y</span><span class="o">:</span>
  <span class="n">a</span><span class="o">.</span><span class="n">f</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">y</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A labeled statement is just</p>
<ul>
  <li>the keyword <code class="language-dafny highlighter-rouge"><span class="kr">label</span></code></li>
  <li>followed by an identifier, which is the label,</li>
  <li>followed by a colon</li>
  <li>and a statement.</li>
</ul>

<p>The label may be
referenced in a <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> statement within the labeled statement
(see <a href="#sec-break-continue-statement">Section 8.14</a>). That is, the break or continue that
mentions the label must be <em>enclosed</em> in the labeled statement.</p>

<p>The label may also be used in an <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> expression (<a href="#sec-old-expression">Section 9.22</a>). In this case, the label
must have been encountered during the control flow en route to the <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code>
expression. We say in this case that the (program point of the) label <em>dominates</em>
the (program point of the) use of the label.
Similarly, labels are used to indicate previous states in calls of <a href="#sec-two-state">two-state predicates</a>,
<a href="#sec-fresh-expression">fresh expressions</a>, <a href="#sec-unchanged-expression">unchanged expressions</a>, 
and <a href="#sec-allocated-expression">allocated expressions</a>.</p>

<p>A statement can be given several labels. It makes no difference which of these
labels is used to reference the statementthey are synonyms of each other.
The labels must be distinct from each other, and are not allowed to be the
same as any previous enclosing or <a href="#sec-two-state">dominating label</a>.</p>

<h3 id="sec-block-statement">8.2. Block Statement (<a href="#g-block-statement">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{</span>
  <span class="kr">print</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A block statement is a sequence of zero or more statements enclosed by curly braces.
Local variables declared in the block end their scope at the end of the block.</p>

<h3 id="sec-return-statement">8.3. Return Statement (<a href="#g-return-statement">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">n</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">q</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">p</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">q</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A return statement can only be used in a method. It is used
to terminate the execution of the method.</p>

<p>To return a value from a method, the value is assigned to one
of the named out-parameters sometime before a return statement.
In fact, the out-parameters act very much like local variables,
and can be assigned to more than once. Return statements are
used when one wants to return before reaching the end of the
body block of the method.</p>

<p>Return statements can be just the <code class="language-dafny highlighter-rouge"><span class="kr">return</span></code> keyword (where the current values
of the out-parameters are used), or they can take a list of expressions to
return. If a list is given, the number of expressions given must be the same
as the number of named out-parameters. These expressions are
evaluated, then they are assigned to the out-parameters, and then the
method terminates.</p>

<h3 id="sec-yield-statement">8.4. Yield Statement (<a href="#g-yield-statement">grammar</a>)</h3>

<p>A yield statement may only be used in an iterator.
See <a href="#sec-iterator-types">iterator types</a> for more details
about iterators.</p>

<p>The body of an iterator is a <em>co-routine</em>. It is used
to yield control to its caller, signaling that a new
set of values for the iterators yield (out-)parameters (if any)
are available. Values are assigned to the yield parameters
at or before a yield statement.
In fact, the yield parameters act very much like local variables,
and can be assigned to more than once. Yield statements are
used when one wants to return new yield parameter values
to the caller. Yield statements can be just the
<code class="language-dafny highlighter-rouge"><span class="kr">yield</span></code> keyword (where the current values of the yield parameters
are used), or they can take a list of expressions to yield.
If a list is given, the number of expressions given must be the
same as the number of named iterator out-parameters.
These expressions are then evaluated, then they are
assigned to the yield parameters, and then the iterator
yields.</p>

<h3 id="sec-update-and-call-statement">8.5. Update and Call Statements (<a href="#g-update-and-call-statement">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span> <span class="p">{</span> <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span> <span class="p">}</span>
<span class="kr">class</span> <span class="n">D</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">constructor</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">this</span><span class="o">.</span><span class="n">i</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">q</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="kr">method</span> <span class="n">r</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">t</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="kr">return</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span> <span class="p">}</span>
<span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">ss</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tt</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">c</span><span class="o">:</span> <span class="n">C?</span><span class="p">,</span> <span class="n">a</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">d</span><span class="o">:</span> <span class="n">D?</span><span class="p">;</span>
  <span class="n">q</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">ss</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">f</span> <span class="o">:=</span> <span class="n">r</span><span class="p">();</span>
  <span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">;</span>
  <span class="n">d</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">D</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="n">ss</span><span class="p">,</span> <span class="n">tt</span> <span class="o">:=</span> <span class="mi">212</span><span class="p">,</span> <span class="mi">33</span><span class="p">;</span>
  <span class="n">ss</span> <span class="o">:|</span> <span class="n">ss</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">ss</span> <span class="o">:=</span> <span class="o">*</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This statement corresponds to familiar assignment or method call statements,
with variations. If more than one
left-hand side is used, these must denote different l-values, unless the
corresponding right-hand sides also denote the same value.</p>

<p>The update statement serves several logical purposes.</p>

<h4 id="851-method-call-with-no-out-parameters">8.5.1. Method call with no out-parameters</h4>
<p>1) Examples of method calls take this form
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">m</span><span class="p">();</span>
<span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span><span class="o">:</span><span class="n">attr</span><span class="p">}</span> <span class="p">;</span>
<span class="n">e</span><span class="o">.</span><span class="n">f</span><span class="p">()</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="mi">45</span><span class="p">);</span>
</code></pre></div></div>

<p>As there are no left-hand-side locations to receive values, this form is allowed only for 
methods that have no out-parameters.</p>

<h4 id="852-method-call-with-out-parameters">8.5.2. Method call with out-parameters</h4>

<p>This form uses <code class="language-dafny highlighter-rouge"><span class="o">:=</span></code> to denote the assignment of the out-parameters of the method to the 
corresponding number of LHS values.
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">e</span><span class="p">()</span><span class="o">.</span><span class="n">f</span> <span class="o">:=</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span><span class="o">:</span><span class="n">attr</span><span class="p">};</span>
</code></pre></div></div>

<p>In this case, the right-hand-side must be a method call and the number of
left-hand sides must match the number of out-parameters of the
method that is called.
Note that the result of a method call is not allowed to be used as an argument of
another method call, as if it were an expression.</p>

<h4 id="853-parallel-assignment">8.5.3. Parallel assignment</h4>

<p>A parallel-assignment has one-or-more right-hand-side expressions,
which may be function calls but may not be method calls.
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
</code></pre></div></div>
<p>The above example swaps the values of <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">y</span></code>. If more than one
left-hand side is used, these must denote different l-values, unless the
corresponding right-hand sides also denote the same value. There must
be an equal number of left-hand sides and right-hand sides.
The most common case has only one RHS and one LHS.</p>

<h4 id="sec-havoc-statement">8.5.4. Havoc assignment</h4>
<p>The form with a right-hand-side that is <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> is a <em>havoc</em> assignment.
It assigns an arbitrary but type-correct value to the corresponding left-hand-side.
It can be mixed with other assignments of computed values.
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span> <span class="o">:=</span> <span class="o">*</span><span class="p">;</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="855-such-that-assignment">8.5.5. Such-that assignment</h4>

<p>This form has one or more left-hand-sides, a <code class="language-dafny highlighter-rouge"><span class="o">:|</span></code> symbol and then a boolean expression on the right.
The effect is to assign values to the left-hand-sides that satisfy the 
RHS condition.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:|</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>
<p>This is read as assign values to <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">y</span></code> such that <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span></code> is true.
The given boolean expression need not constrain the LHS values uniquely:
the choice of satisfying values is non-deterministic. 
This can be used to make a choice as in the
following example where we choose an element in a set.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Sum</span><span class="p">(</span><span class="n">X</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">s</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="kr">var</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">X</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">Y</span> <span class="o">!=</span> <span class="p">{}</span>
    <span class="kr">decreases</span> <span class="n">Y</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">:|</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">;</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">Y</span> <span class="o">:=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">Y</span> <span class="o">-</span> <span class="p">{</span><span class="n">y</span><span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dafny will report an error if it cannot prove that values
exist that satisfy the condition.</p>

<p>In this variation, with an <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> keyword
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>    <span class="n">y</span> <span class="o">:|</span> <span class="kr">assume</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">;</span>
</code></pre></div></div>
<p>Dafny assumes without proof that an appropriate value exists.</p>

<p>Note that the syntax</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code>    Lhs ":"
</code></pre></div></div>

<p>is interpreted as a label in which the user forgot the <code class="language-dafny highlighter-rouge"><span class="kr">label</span></code> keyword.</p>

<h4 id="856-method-call-with-a-by-proof">8.5.6. Method call with a <code class="language-dafny highlighter-rouge"><span class="kr">by</span></code> proof</h4>

<p>The purpose of this form of a method call is to seperate the called methods
precondition and its proof from the rest of the correctness proof of the
calling method.</p>

<!-- %check-verify Statements.16.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">opaque</span> <span class="kr">predicate</span> <span class="n">P</span><span class="p">()</span> <span class="p">{</span> <span class="kc">true</span> <span class="p">}</span>

<span class="kr">lemma</span> <span class="n">ProveP</span><span class="p">()</span> <span class="kr">ensures</span> <span class="n">P</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">reveal</span> <span class="n">P</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">P</span><span class="p">()</span>
  <span class="kr">ensures</span> <span class="n">r</span> <span class="o">==</span> <span class="n">i</span>
<span class="p">{</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>

<span class="kr">method</span> <span class="n">C</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">M</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="kr">by</span> <span class="p">{</span> <span class="c1">// We prove 3 != 0 outside of the by proof</span>
    <span class="n">ProveP</span><span class="p">();</span>          <span class="c1">// Prove precondtion  </span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">// Use postcondition</span>
  <span class="kr">assert</span> <span class="n">P</span><span class="p">();</span>          <span class="c1">// Fails</span>
<span class="p">}</span>
</code></pre></div></div>

<p>By placing the call to lemma <code class="language-dafny highlighter-rouge"><span class="n">ProveP</span></code> inside of the by block, we can not use
<code class="language-dafny highlighter-rouge"><span class="n">P</span></code> after the method call. The well-formedness checks of the arguments to the
method call are not subject to the separation.</p>

<h3 id="sec-update-with-failure-statement">8.6. Update with Failure Statement (<code class="language-dafny highlighter-rouge"><span class="o">:-</span></code>) (<a href="#g-update-with-failure-statement">grammar</a>)</h3>

<p>See the subsections below for examples.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code><sup id="fnref:elephant" role="doc-noteref"><a href="#fn:elephant" class="footnote" rel="footnote">9</a></sup> statement is an alternate form of the <code class="language-dafny highlighter-rouge"><span class="o">:=</span></code> statement that allows for abrupt return if a failure is detected.
This is a language feature somewhat analogous to exceptions in other languages.</p>

<p>An update-with-failure statement uses <em>failure-compatible</em> types.
A failure-compatible type is a type that has the following (non-static) members (each with no in-parameters and one out-parameter):</p>

<ul>
  <li>a non-ghost function <code class="language-dafny highlighter-rouge"><span class="n">IsFailure</span><span class="p">()</span></code> that returns a <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></li>
  <li>an optional non-ghost function <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span><span class="p">()</span></code> that returns a value assignable to the first out-parameter of the caller</li>
  <li>an optional function <code class="language-dafny highlighter-rouge"><span class="n">Extract</span><span class="p">()</span></code>
(PropagateFailure and Extract were permitted to be methods (but deprecated) prior to Dafny 4. They will be required to be functions in Dafny 4.)</li>
</ul>

<p>A failure-compatible type with an <code class="language-dafny highlighter-rouge"><span class="n">Extract</span></code> member is called <em>value-carrying</em>.</p>

<p>To use this form of update,</p>

<ul>
  <li>if the RHS of the update-with-failure statement is a method call, the first out-parameter of the callee must be failure-compatible</li>
  <li>if instead, the RHS of the update-with-failure statement is one or more expressions, the first of these expressions must be a value with a failure-compatible type</li>
  <li>the caller must have a first out-parameter whose type matches the output of <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code> applied to the first output of the callee, unless an
<code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code>, or <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> keyword is used after <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> (cf. <a href="#sec-failure-return-keyword">Section 8.6.7</a>).</li>
  <li>if the failure-compatible type of the RHS does not have an <code class="language-dafny highlighter-rouge"><span class="n">Extract</span></code> member,
then the LHS of the <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> statement has one less expression than the RHS
(or than the number of out-parameters from the method call), the value of the first out-parameter or expression being dropped
(see the discussion and examples in <a href="#sec-simple-fc-return">Section 8.6.2</a>)</li>
  <li>if the failure-compatible type of the RHS does have an <code class="language-dafny highlighter-rouge"><span class="n">Extract</span></code> member,
then the LHS of the <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> statement has the same number of expressions as the RHS
(or as the number of out-parameters from the method call)
and the type of the first LHS expression must be assignable from the return type of the <code class="language-dafny highlighter-rouge"><span class="n">Extract</span></code> member</li>
  <li>the <code class="language-dafny highlighter-rouge"><span class="n">IsFailure</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code> methods may not be ghost</li>
  <li>the LHS expression assigned the output of the <code class="language-dafny highlighter-rouge"><span class="n">Extract</span></code> member is ghost precisely if <code class="language-dafny highlighter-rouge"><span class="n">Extract</span></code> is ghost</li>
</ul>

<p>The following subsections show various uses and alternatives.</p>

<h4 id="sec-failure-compatible-types">8.6.1. Failure compatible types</h4>

<p>A simple failure-compatible type is the following:
<!-- %check-resolve %save Status.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Status</span> <span class="o">=</span>
<span class="o">|</span> <span class="n">Success</span>
<span class="o">|</span> <span class="n">Failure</span><span class="p">(</span><span class="n">error</span><span class="o">:</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">predicate</span> <span class="n">IsFailure</span><span class="p">()</span> <span class="p">{</span> <span class="kr">this</span><span class="o">.</span><span class="n">Failure?</span>  <span class="p">}</span>
  <span class="kr">function</span> <span class="n">PropagateFailure</span><span class="p">()</span><span class="o">:</span> <span class="n">Status</span>
    <span class="kr">requires</span> <span class="n">IsFailure</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Failure</span><span class="p">(</span><span class="kr">this</span><span class="o">.</span><span class="n">error</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A commonly used alternative that carries some value information is something like this generic type:
<!-- %check-resolve %save Outcome.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Outcome</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span>
<span class="o">|</span> <span class="n">Success</span><span class="p">(</span><span class="n">value</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span>
<span class="o">|</span> <span class="n">Failure</span><span class="p">(</span><span class="n">error</span><span class="o">:</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">predicate</span> <span class="n">IsFailure</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">this</span><span class="o">.</span><span class="n">Failure?</span>
  <span class="p">}</span>
  <span class="kr">function</span> <span class="n">PropagateFailure</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">()</span><span class="o">:</span> <span class="n">Outcome</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
    <span class="kr">requires</span> <span class="n">IsFailure</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Failure</span><span class="p">(</span><span class="kr">this</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="c1">// this is Outcome&lt;U&gt;.Failure(...)</span>
  <span class="p">}</span>
  <span class="kr">function</span> <span class="n">Extract</span><span class="p">()</span><span class="o">:</span> <span class="n">T</span>
    <span class="kr">requires</span> <span class="o">!</span><span class="n">IsFailure</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kr">this</span><span class="o">.</span><span class="n">value</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="sec-simple-fc-return">8.6.2. Simple status return with no other outputs</h4>

<p>The simplest use of this failure-return style of programming is to have a method call that just returns a non-value-carrying <code class="language-dafny highlighter-rouge"><span class="n">Status</span></code> value:
<!-- %check-resolve %use Status.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="n">Status</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="kr">return</span> <span class="n">Failure</span><span class="p">(</span><span class="s2">"negative"</span><span class="p">);</span> <span class="p">}</span>
  <span class="kr">return</span> <span class="n">Success</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Caller</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">rr</span><span class="o">:</span> <span class="n">Status</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">:-</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that there is no LHS to the <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> statement.
If <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code> returns <code class="language-dafny highlighter-rouge"><span class="n">Failure</span></code>, then the caller immediately returns,
not executing any statements following the call of <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code>.
The value returned by <code class="language-dafny highlighter-rouge"><span class="n">Caller</span></code> (the value of <code class="language-dafny highlighter-rouge"><span class="n">rr</span></code> in the code above) is the result of <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code> applied to the value returned by <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code>, which is often just the same value.
If <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code> does not return <code class="language-dafny highlighter-rouge"><span class="n">Failure</span></code> (that is, returns a value for which <code class="language-dafny highlighter-rouge"><span class="n">IsFailure</span><span class="p">()</span></code> is <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>)
then that return value is forgotten and execution proceeds normally with the statements following the call of <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code> in the body of <code class="language-dafny highlighter-rouge"><span class="n">Caller</span></code>.</p>

<p>The desugaring of the <code class="language-dafny highlighter-rouge"><span class="o">:-</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code> statement is
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">tmp</span><span class="p">;</span>
<span class="n">tmp</span> <span class="o">:=</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="kr">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">rr</span> <span class="o">:=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">();</span>
  <span class="kr">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In this and subsequent examples of desugaring, the <code class="language-dafny highlighter-rouge"><span class="n">tmp</span></code> variable is a new, unique variable, unused elsewhere in the calling member.</p>

<h4 id="sec-multiple-output-fc">8.6.3. Status return with additional outputs</h4>

<p>The example in the previous subsection affects the program only through side effects or the status return itself.
It may well be convenient to have additional out-parameters, as is allowed for <code class="language-dafny highlighter-rouge"><span class="o">:=</span></code> updates;
these out-parameters behave just as for <code class="language-dafny highlighter-rouge"><span class="o">:=</span></code>.
Here is an example:</p>

<!-- %check-resolve %use Status.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="n">Status</span><span class="p">,</span> <span class="n">v</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">w</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="kr">return</span> <span class="n">Failure</span><span class="p">(</span><span class="s2">"negative"</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="kr">return</span> <span class="n">Success</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Caller</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">rr</span><span class="o">:</span> <span class="n">Status</span><span class="p">,</span> <span class="n">k</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">:-</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">k</span> <span class="o">:=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code> has two outputs in addition to the <code class="language-dafny highlighter-rouge"><span class="n">Status</span></code> output.
The LHS of the <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> statement accordingly has two l-values to receive those outputs.
The recipients of those outputs may be any sort of l-values;
here they are a local variable and an out-parameter of the caller.
Those outputs are assigned in the <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> call regardless of the <code class="language-dafny highlighter-rouge"><span class="n">Status</span></code> value:</p>

<ul>
  <li>If <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code> returns a failure value as its first output, then the other outputs are assigned, 
the <em>callers</em> first out-parameter (here <code class="language-dafny highlighter-rouge"><span class="n">rr</span></code>) is assigned the value of <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code>, and the caller returns.</li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code> returns a non-failure value as its first output, then the other outputs are assigned and the
caller continues execution as normal.</li>
</ul>

<p>The desugaring of the <code class="language-dafny highlighter-rouge"><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">:-</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code> statement is
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">tmp</span><span class="p">;</span>
<span class="n">tmp</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="kr">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">rr</span> <span class="o">:=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">();</span>
  <span class="kr">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="sec-value-carrying">8.6.4. Failure-returns with additional data</h4>

<p>The failure-compatible return value can carry additional data as shown in the <code class="language-dafny highlighter-rouge"><span class="n">Outcome</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> example above.
In this case there is a (first) LHS l-value to receive this additional data. The type of that first LHS
value is one that is assignable from the result of the <code class="language-dafny highlighter-rouge"><span class="n">Extract</span></code> function, not the actual first out-parameter.</p>

<!-- %check-resolve %use Outcome.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="n">Outcome</span><span class="o">&lt;</span><span class="kt">nat</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">v</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="kr">return</span> <span class="n">Failure</span><span class="p">(</span><span class="s2">"negative"</span><span class="p">),</span> <span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="p">;</span> <span class="p">}</span>
  <span class="kr">return</span> <span class="n">Success</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Caller</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">rr</span><span class="o">:</span> <span class="n">Outcome</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">:-</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">k</span> <span class="o">:=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Suppose <code class="language-dafny highlighter-rouge"><span class="n">Caller</span></code> is called with an argument of <code class="language-dafny highlighter-rouge"><span class="mi">10</span></code>.
Then <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code> is called with argument <code class="language-dafny highlighter-rouge"><span class="mi">10</span></code>
and returns <code class="language-dafny highlighter-rouge"><span class="n">r</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">v</span></code> of <code class="language-dafny highlighter-rouge"><span class="n">Outcome</span><span class="o">&lt;</span><span class="kt">nat</span><span class="o">&gt;.</span><span class="n">Success</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span></code> and <code class="language-dafny highlighter-rouge"><span class="mi">20</span></code>.
Here <code class="language-dafny highlighter-rouge"><span class="n">r</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span></code> is <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>, so control proceeds normally.
The <code class="language-dafny highlighter-rouge"><span class="n">j</span></code> is assigned the result of <code class="language-dafny highlighter-rouge"><span class="n">r</span><span class="o">.</span><span class="n">Extract</span><span class="p">()</span></code>, which will be <code class="language-dafny highlighter-rouge"><span class="mi">10</span></code>,
and <code class="language-dafny highlighter-rouge"><span class="n">k</span></code> is assigned <code class="language-dafny highlighter-rouge"><span class="mi">20</span></code>.
Control flow proceeds to the next line, where <code class="language-dafny highlighter-rouge"><span class="n">k</span></code> now gets the value <code class="language-dafny highlighter-rouge"><span class="mi">40</span></code>.</p>

<p>Suppose instead that <code class="language-dafny highlighter-rouge"><span class="n">Caller</span></code> is called with an argument of <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="mi">1</span></code>.
Then <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code> is called with the value <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="mi">1</span></code>
 and returns <code class="language-dafny highlighter-rouge"><span class="n">r</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">v</span></code> with values <code class="language-dafny highlighter-rouge"><span class="n">Outcome</span><span class="o">&lt;</span><span class="kt">nat</span><span class="o">&gt;.</span><span class="n">Failure</span><span class="p">(</span><span class="s2">"negative"</span><span class="p">)</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="mi">2</span></code>.
<code class="language-dafny highlighter-rouge"><span class="n">k</span></code> is assigned the value of <code class="language-dafny highlighter-rouge"><span class="n">v</span></code> (-2).
But <code class="language-dafny highlighter-rouge"><span class="n">r</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span></code> is <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>, so control proceeds directly to return from <code class="language-dafny highlighter-rouge"><span class="n">Caller</span></code>.
The first out-parameter of <code class="language-dafny highlighter-rouge"><span class="n">Caller</span></code> (<code class="language-dafny highlighter-rouge"><span class="n">rr</span></code>) gets the value of <code class="language-dafny highlighter-rouge"><span class="n">r</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">()</span></code>,
which is <code class="language-dafny highlighter-rouge"><span class="n">Outcome</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;.</span><span class="n">Failure</span><span class="p">(</span><span class="s2">"negative"</span><span class="p">)</span></code>; <code class="language-dafny highlighter-rouge"><span class="n">k</span></code> already has the value <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="mi">2</span></code>.
The rest of the body of <code class="language-dafny highlighter-rouge"><span class="n">Caller</span></code> is skipped.
In this example, the first out-parameter of <code class="language-dafny highlighter-rouge"><span class="n">Caller</span></code> has a failure-compatible type
so the exceptional return will propagate up the call stack.
It will keep propagating up the call stack
as long as there are callers with this first special output type
and calls that use <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code>
and the return value keeps having <code class="language-dafny highlighter-rouge"><span class="n">IsFailure</span><span class="p">()</span></code> true.</p>

<p>The desugaring of the <code class="language-dafny highlighter-rouge"><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">:-</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code> statement in this example is
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">tmp</span><span class="p">;</span>
<span class="n">tmp</span><span class="p">,</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="kr">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">rr</span> <span class="o">:=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">();</span>
  <span class="kr">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">j</span> <span class="o">:=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">Extract</span><span class="p">();</span>
</code></pre></div></div>

<h4 id="sec-failure-expressions">8.6.5. RHS with expression list</h4>

<p>Instead of a failure-returning method call on the RHS of the statement,
the RHS can instead be a list of expressions.
As for a <code class="language-dafny highlighter-rouge"><span class="o">:=</span></code> statement, in this form, the expressions on the left and right sides of <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> must correspond,
just omitting a LHS l-value for the first RHS expression if its type is not value-carrying.
The semantics is very similar to that in the previous subsection.</p>

<ul>
  <li>The first RHS expression must have a failure-compatible type.</li>
  <li>All the assignments of RHS expressions to LHS values except for the first RHS value are made.</li>
  <li>If the first RHS value (say <code class="language-dafny highlighter-rouge"><span class="n">r</span></code>) responds <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">r</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span></code>,
then <code class="language-dafny highlighter-rouge"><span class="n">r</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">()</span></code> is assigned to the first out-parameter of the <em>caller</em>
and the execution of the callers body is ended.</li>
  <li>If the first RHS value (say <code class="language-dafny highlighter-rouge"><span class="n">r</span></code>) responds <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">r</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span></code>, then
    <ul>
      <li>if the type of <code class="language-dafny highlighter-rouge"><span class="n">r</span></code> is value-carrying, then <code class="language-dafny highlighter-rouge"><span class="n">r</span><span class="o">.</span><span class="n">Extract</span><span class="p">()</span></code> is assigned to the first LHS value of the <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> statement;
if <code class="language-dafny highlighter-rouge"><span class="n">r</span></code> is not value-carrying, then the corresponding LHS l-value is omitted</li>
      <li>execution of the callers body continues with the statement following the <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> statement.</li>
    </ul>
  </li>
</ul>

<p>A RHS with a method call cannot be mixed with a RHS containing multiple expressions.</p>

<p>For example, the desugaring of
<!-- %check-resolve %use Status.tmp --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="n">Status</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">rr</span><span class="o">:</span> <span class="n">Status</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">k</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">:-</span> <span class="n">r</span><span class="p">,</span> <span class="mi">7</span><span class="p">;</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>is
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">k</span><span class="p">;</span>
<span class="kr">var</span> <span class="n">tmp</span><span class="p">;</span>
<span class="n">tmp</span><span class="p">,</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">r</span><span class="p">,</span> <span class="mi">7</span><span class="p">;</span>
<span class="kr">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">rr</span> <span class="o">:=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">();</span>
  <span class="kr">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="sec-failure-with-declaration">8.6.6. Failure with initialized declaration.</h4>

<p>The <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> syntax can also be used in initialization, as in
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">:-</span> <span class="n">M</span><span class="p">();</span>
</code></pre></div></div>
<p>This is equivalent to
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
<span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">:-</span> <span class="n">M</span><span class="p">();</span>
</code></pre></div></div>
<p>with the semantics as described above.</p>

<h4 id="sec-failure-return-keyword">8.6.7. Keyword alternative</h4>

<p>In any of the above described uses of <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code>, the <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> token may be followed immediately by the keyword <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code>.</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> means that the RHS evaluation is expected to be successful, but that
the verifier should prove that this is so; that is, the verifier should prove
<code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="o">!</span><span class="n">r</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span></code> (where <code class="language-dafny highlighter-rouge"><span class="n">r</span></code> is the status return from the callee)
(cf. <a href="#sec-assert-statement">Section 8.17</a>)</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> means that the RHS evaluation should be assumed to be successful,
as if the statement <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="o">!</span><span class="n">r</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span></code> followed the evaluation of the RHS
(cf. <a href="#sec-assume-statement">Section 8.18</a>)</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> means that the RHS evaluation should be assumed to be successful
(like using <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> above), but that the compiler should include a
run-time check for success. This is equivalent to including
<code class="language-dafny highlighter-rouge"><span class="kr">expect</span> <span class="o">!</span><span class="n">r</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span></code> after the RHS evaluation; that is, if the status
return is a failure, the program halts.
(cf. <a href="#sec-expect-statement">Section 8.19</a>)</li>
</ul>

<p>In each of these cases, there is no abrupt return from the caller. Thus
there is no evaluation of <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code>. Consequently the first
out-parameter of the caller need not match the return type of
<code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code>; indeed, the failure-compatible type returned by the
callee need not have a <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code> member.</p>

<p>The equivalent desugaring replaces
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">rr</span> <span class="o">:=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">();</span>
  <span class="kr">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>with
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">expect</span> <span class="o">!</span><span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">(),</span> <span class="n">tmp</span><span class="p">;</span>
</code></pre></div></div>
<p>or
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">assert</span> <span class="o">!</span><span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">();</span>
</code></pre></div></div>
<p>or
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">assume</span> <span class="o">!</span><span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">();</span>
</code></pre></div></div>

<p>There is a grammatical nuance that the user should be aware of.
The keywords <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code>, and <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> can start an expression.
For example, <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">;</span> <span class="n">E</span></code> can be an expression. However, in
<code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="o">:-</span> <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span> <span class="n">E</span><span class="p">;</span></code> the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> is parsed as the keyword associated with
<code class="language-dafny highlighter-rouge"><span class="o">:-</span></code>. To have the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> considered part of the expression use parentheses:
<code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="o">:-</span> <span class="p">(</span><span class="kr">assert</span> <span class="n">P</span><span class="p">;</span> <span class="n">E</span><span class="p">);</span></code>.</p>

<h4 id="868-key-points">8.6.8. Key points</h4>

<p>There are several points to note.</p>

<ul>
  <li>The first out-parameter of the callee is special.
It has a special type and that type indicates that the value is inspected to see if an abrupt return
from the caller is warranted.
This type is often a datatype, as shown in the examples above, but it may be any type with the appropriate members.</li>
  <li>The restriction on the type of callers first out-parameter is
just that it must be possible (perhaps through generic instantiation and type inference, as in these examples) 
for <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code> applied to the failure-compatible output from the callee to produce a value of 
the callers first out-parameter type.
If the callers first out-parameter type is failure-compatible (which it need not be),
then failures can be propagated up the call chain.
If the keyword form (e.g. <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code>) of the statement is used, then no <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code> member
is needed, because no failure can occur, and there is no restriction on the callers first out-parameter.</li>
  <li>In the statement <code class="language-dafny highlighter-rouge"><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">:-</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code>,
when the callees return value has an <code class="language-dafny highlighter-rouge"><span class="n">Extract</span></code> member,
the type of <code class="language-dafny highlighter-rouge"><span class="n">j</span></code> is not the type of the first out-parameter of <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code>.
Rather it is a type assignable from the output type of <code class="language-dafny highlighter-rouge"><span class="n">Extract</span></code> applied to the first out-value of <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code>.</li>
  <li>A method like <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code> with a special first out-parameter type can still be used in the normal way:
<code class="language-dafny highlighter-rouge"><span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">Callee</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></code>.
Now <code class="language-dafny highlighter-rouge"><span class="n">r</span></code> gets the first output value from <code class="language-dafny highlighter-rouge"><span class="n">Callee</span></code>, of type <code class="language-dafny highlighter-rouge"><span class="n">Status</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">Outcome</span><span class="o">&lt;</span><span class="kt">nat</span><span class="o">&gt;</span></code> in the examples above.
No special semantics or exceptional control paths apply.
Subsequent code can do its own testing of the value of <code class="language-dafny highlighter-rouge"><span class="n">r</span></code>
and whatever other computations or control flow are desired.</li>
  <li>The caller and callee can have any (positive) number of output arguments,
as long as the callees first out-parameter has a failure-compatible type
and the callers first out-parameter type matches <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code>.</li>
  <li>If there is more than one LHS, the LHSs must denote different l-values, 
unless the RHS is a list of expressions and the corresponding RHS values are equal.</li>
  <li>The LHS l-values are evaluated before the RHS method call,
in case the method call has side-effects or return values that modify the l-values prior to assignments being made.</li>
</ul>

<p>It is important to note the connection between the failure-compatible types used in the caller and callee,
if they both use them.
They do not have to be the same type, but they must be closely related,
as it must be possible for the callees <code class="language-dafny highlighter-rouge"><span class="n">PropagateFailure</span></code> to return a value of the callers failure-compatible type.
In practice this means that one such failure-compatible type should be used for an entire program.
If a Dafny program uses a library shared by multiple programs, the library should supply such a type 
and it should be used by all the client programs (and, effectively, all Dafny libraries).
It is also the case that it is inconvenient to mix types such as <code class="language-dafny highlighter-rouge"><span class="n">Outcome</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Status</span></code> above within the same program.
If there is a mix of failure-compatible types, then the program will need to use <code class="language-dafny highlighter-rouge"><span class="o">:=</span></code> statements and code for
explicit handling of failure values.</p>

<h4 id="sec-failure-return-and-exceptions">8.6.9. Failure returns and exceptions</h4>

<p>The <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> mechanism is like the exceptions used in other programming languages, with some similarities and differences.</p>

<ul>
  <li>There is essentially just one kind of exception in Dafny,
the variations of the failure-compatible data type.</li>
  <li>Exceptions are passed up the call stack whether or not intervening methods are aware of the possibility of an exception,
that is, whether or not the intervening methods have declared that they throw exceptions.
Not so in Dafny: a failure is passed up the call stack only if each caller has a failure-compatible first out-parameter, is itself called in a <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> statement, and returns a value that responds true to <code class="language-dafny highlighter-rouge"><span class="n">IsFailure</span><span class="p">()</span></code>.</li>
  <li>All methods that contain failure-return callees must explicitly handle those failures
using either <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> statements or using <code class="language-dafny highlighter-rouge"><span class="o">:=</span></code> statements with a LHS to receive the failure value.</li>
</ul>

<h3 id="sec-variable-declaration-statement">8.7. Variable Declaration Statement (<a href="#g-variable-declaration-statement">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// x's type is inferred, not necessarily 'int'</span>
  <span class="kr">var</span> <span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">k</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// settles x's type</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A variable declaration statement is used to declare one or more local variables in
a method or function. The type of each local variable must be given
unless its type can be inferred, either from a given initial value, or
from other uses of the variable. If initial values are given, the number
of values must match the number of variables declared.</p>

<p>The scope of the declared variable extends to the end of the block in which it is
declared. However, be aware that if a simple variable declaration is followed
by an expression (rather than a subsequent statement) then the <code class="language-dafny highlighter-rouge"><span class="kr">var</span></code> begins a
<a href="#sec-let-expression">Let Expression</a> and the scope of the introduced variables is
only to the end of the expression. In this case, though, the <code class="language-dafny highlighter-rouge"><span class="kr">var</span></code> is in an expression
context, not a statement context.</p>

<p>Note that the type of each variable must be given individually. The following code</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="kr">var</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">;</span>
<span class="kr">var</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:-</span> <span class="n">m</span><span class="p">();</span>
<span class="kr">var</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">:|</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span>
<span class="kr">var</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">:=</span> <span class="n">makePair</span><span class="p">();</span>
<span class="kr">var</span> <span class="n">Cons</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">ConsMaker</span><span class="p">();</span>
</code></pre></div></div>
<p>does not declare both <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">y</span></code> to be of type <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>. Rather it will give an
error explaining that the type of <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is underspecified if it cannot be
inferred from uses of x.</p>

<p>The variables can be initialized with syntax similar to update statements (cf. <a href="#sec-update-and-call-statement">Section 8.5</a>).</p>

<p>If the RHS is a call, then any variable receiving the value of a
formal ghost out-parameter will automatically be declared as ghost, even
if the <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> keyword is not part of the variable declaration statement.</p>

<p>The left-hand side can also contain a tuple of patterns that will be
matched against the right-hand-side. For example:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">returnsTuple</span><span class="p">()</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="kr">function</span> <span class="n">usesTuple</span><span class="p">()</span> <span class="o">:</span> <span class="kt">int</span>
<span class="p">{</span>
    <span class="kr">var</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">:=</span> <span class="n">returnsTuple</span><span class="p">();</span>
    <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The initialization with failure operator <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> returns from the enclosing method if the initializer evaluates to a failure value of a failure-compatible type (see <a href="#sec-update-with-failure-statement">Section 8.6</a>).</p>

<h3 id="sec-guard">8.8. Guards (<a href="#g-guard">grammar</a>)</h3>

<p>Examples (in <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> statements):
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">if</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span> <span class="kr">print</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
  <span class="kr">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="kr">print</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Guards are used in <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">while</span></code> statements as boolean expressions. Guards
take two forms.</p>

<p>The first and most common form is just a boolean expression.</p>

<p>The second form is either <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> or <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">*</span><span class="p">)</span></code>. These have the same meaning. An
unspecified boolean value is returned. The value returned
may be different each time it is executed.</p>

<h3 id="sec-binding-guards">8.9. Binding Guards (<a href="#g-binding-guard">grammar</a>)</h3>

<p>Examples (in <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> statements):
<!-- %check-resolve-warn Statements.13.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">k</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">:|</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>An <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> statement can also take a <em>binding guard</em>.
Such a guard checks if there exist values for the given variables that satisfy the given expression.
If so, it binds some satisfying values to the variables and proceeds
into the then branch; otherwise it proceeds with the else branch,
where the bound variables are not in scope.</p>

<p>In other words, the statement</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">if</span> <span class="n">x</span> <span class="o">:|</span> <span class="n">P</span> <span class="p">{</span> <span class="n">S</span> <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span> <span class="n">T</span> <span class="p">}</span>
</code></pre></div></div>

<p>has the same meaning as</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">if</span> <span class="kr">exists</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span> <span class="p">{</span> <span class="kr">var</span> <span class="n">x</span> <span class="o">:|</span> <span class="n">P</span><span class="p">;</span> <span class="n">S</span> <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span> <span class="n">T</span> <span class="p">}</span>
</code></pre></div></div>

<p>The identifiers bound by the binding guard are ghost variables
and cannot be assigned to non-ghost variables. They are only
used in specification contexts.</p>

<p>Here is another example:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">P</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">M1</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="kr">ghost</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
    <span class="kr">requires</span> <span class="kr">exists</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="kr">ensures</span> <span class="n">P</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">:|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">y</span> <span class="o">:=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="sec-if-statement">8.10. If Statement (<a href="#g-if-statement">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve-warn Statements.14.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">if</span> <span class="o">*</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">if</span> <span class="n">i</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">j</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">:|</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">if</span> 
    <span class="kr">case</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kr">case</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kr">case</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The simplest form of an <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> statement uses a guard that is a boolean
expression. For example,</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="o">-</span><span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Unlike <code class="language-dafny highlighter-rouge"><span class="kr">match</span></code> statements, <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> statements do not have to be exhaustive:
omitting the <code class="language-dafny highlighter-rouge"><span class="kr">else</span></code> block is the same as including an empty <code class="language-dafny highlighter-rouge"><span class="kr">else</span></code>
block.  To ensure that an <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> statement is exhaustive, use the
<code class="language-dafny highlighter-rouge"><span class="kr">if</span><span class="o">-</span><span class="kr">case</span></code> statement documented below.</p>

<p>If the guard is an asterisk then a non-deterministic choice is made:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="kr">if</span> <span class="o">*</span> <span class="p">{</span>
    <span class="kr">print</span> <span class="s2">"True"</span><span class="p">;</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">print</span> <span class="s2">"False"</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>The then alternative of the if-statement must be a block statement;
the else alternative may be either a block statement or another if statement.
The condition of the if statement need not (but may) be enclosed in parentheses.</p>

<p>An if statement with a binding guard is non-deterministic;
it will not be compiled if <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">enforce</span><span class="o">-</span><span class="n">determinism</span></code> is enabled
(even if it can be proved that there is a unique value).
An if statement with <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> for a guard is non-deterministic and ghost.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">if</span><span class="o">-</span><span class="kr">case</span></code> statement using the <code class="language-dafny highlighter-rouge"><span class="n">AlternativeBlock</span></code> form is similar to the
<code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="o">...</span> <span class="n">fi</span></code> construct used in the book A Discipline of Programming by
Edsger W. Dijkstra. It is used for a multi-branch <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code>.</p>

<p>For example:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">max</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="kr">if</span> <span class="p">{</span>
    <span class="kr">case</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">=&gt;</span> <span class="n">max</span> <span class="o">:=</span> <span class="n">y</span><span class="p">;</span>
    <span class="kr">case</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">max</span> <span class="o">:=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this form, the expressions following the <code class="language-dafny highlighter-rouge"><span class="kr">case</span></code> keyword are called
<em>guards</em>. The statement is evaluated by evaluating the guards in an
undetermined order until one is found that is <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> and the statements
to the right of <code class="language-dafny highlighter-rouge"><span class="o">=&gt;</span></code> for that guard are executed. The statement requires
at least one of the guards to evaluate to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> (that is, <code class="language-dafny highlighter-rouge"><span class="kr">if</span><span class="o">-</span><span class="kr">case</span></code>
statements must be exhaustive: the guards must cover all cases).</p>

<p>In the if-with-cases, a sequence of statements may follow the <code class="language-dafny highlighter-rouge"><span class="o">=&gt;</span></code>; it
may but need not be a block statement (a brace-enclosed sequence of statements).</p>

<p>The form that used <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> (a refinement feature) as the guard is deprecated.</p>

<h3 id="sec-match-statement">8.11. Match Statement (<a href="#g-match-statement">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>
<span class="kr">match</span> <span class="n">list</span> <span class="p">{</span>
  <span class="kr">case</span> <span class="n">Nil</span> <span class="o">=&gt;</span> <span class="p">{}</span>
  <span class="kr">case</span> <span class="n">Cons</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="n">tail</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">print</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">match</span> <span class="n">x</span>
<span class="kr">case</span> <span class="mi">1</span> <span class="o">=&gt;</span>
  <span class="kr">print</span> <span class="n">x</span><span class="p">;</span>
<span class="kr">case</span> <span class="mi">2</span> <span class="o">=&gt;</span>
  <span class="kr">var</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
  <span class="kr">print</span> <span class="n">y</span><span class="p">;</span>
<span class="kr">case</span> <span class="n">_</span> <span class="o">=&gt;</span>
  <span class="kr">print</span> <span class="s2">"Other"</span><span class="p">;</span>
  <span class="c1">// Any statement after is captured in this case.</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">match</span></code> statement is used to do case analysis on a value of an expression.
The expression may be a value of a basic type (e.g. <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>), a newtype, or
an inductive or coinductive datatype (which includes the built-in tuple types). 
The expression after the <code class="language-dafny highlighter-rouge"><span class="kr">match</span></code> keyword is called the <em>selector</em>. 
The selector is evaluated and then matched against
each clause in order until a matching clause is found.</p>

<p>The process of matching the selector expression against the case patterns is
the same as for match expressions and is described in
<a href="#sec-case-pattern">Section 9.31.2</a>.</p>

<p>The selector need not be enclosed in parentheses; the sequence of cases may but need not be enclosed in braces.
The cases need not be disjoint.
The cases must be exhaustive, but you can use a wild variable (<code class="language-dafny highlighter-rouge"><span class="n">_</span></code>) or a simple identifier to indicate match anything.
Please refer to the <a href="#sec-case-pattern">section about case patterns</a> to learn more about shadowing, constants, etc.</p>

<p>The code below shows an example of a match statement.</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Tree</span> <span class="o">=</span> <span class="n">Empty</span> <span class="o">|</span> <span class="n">Node</span><span class="p">(</span><span class="n">left</span><span class="o">:</span> <span class="n">Tree</span><span class="p">,</span> <span class="n">data</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">right</span><span class="o">:</span> <span class="n">Tree</span><span class="p">)</span>

<span class="c1">// Return the sum of the data in a tree.</span>
<span class="kr">method</span> <span class="n">Sum</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="n">Tree</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">match</span> <span class="n">x</span> <span class="p">{</span>
    <span class="kr">case</span> <span class="n">Empty</span> <span class="o">=&gt;</span> <span class="n">r</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kr">case</span> <span class="n">Node</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="kr">var</span> <span class="n">v1</span> <span class="o">:=</span> <span class="n">Sum</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
      <span class="kr">var</span> <span class="n">v2</span> <span class="o">:=</span> <span class="n">Sum</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span>
      <span class="n">r</span> <span class="o">:=</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that the <code class="language-dafny highlighter-rouge"><span class="n">Sum</span></code> method is recursive yet has no <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> annotation.
In this case it is not needed because Dafny is able to deduce that
<code class="language-dafny highlighter-rouge"><span class="n">t1</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">t2</span></code> are <em>smaller</em> (structurally) than <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>. If <code class="language-dafny highlighter-rouge"><span class="n">Tree</span></code> had been
coinductive this would not have been possible since <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> might have been
infinite.</p>

<h3 id="sec-while-statement">8.12. While Statement (<a href="#g-while-statement">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kr">while</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span>
    <span class="kr">invariant</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span>
    <span class="kr">decreases</span> <span class="n">i</span>
  <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">while</span> <span class="o">*</span> <span class="p">{}</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="o">*</span><span class="p">;</span>
  <span class="kr">while</span> 
     <span class="kr">decreases</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="o">-</span><span class="n">i</span> <span class="kr">else</span> <span class="n">i</span>
  <span class="p">{</span>
     <span class="kr">case</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
     <span class="kr">case</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Loops</p>
<ul>
  <li>may be a conventional loop with a condition and a block statement for a body</li>
  <li>need not have parentheses around the condition</li>
  <li>may have a <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> for the condition (the loop is then non-deterministic)</li>
  <li>binding guards are not allowed</li>
  <li>may have a case-based structure</li>
  <li>may have no body  a bodyless loop is not compilable, but can be reaosnaed about</li>
</ul>

<p>Importantly, loops need <em>loop specifications</em> in order for Dafny to prove that
they obey expected behavior. In some cases Dafny can infer the loop specifications by analyzing the code,
so the loop specifications need not always be explicit.
These specifications are described in <a href="#sec-loop-specification">Section 7.6</a> and <a href="#sec-loop-specifications">Section 8.15</a>.</p>

<p>The general loop statement in Dafny is the familiar <code class="language-dafny highlighter-rouge"><span class="kr">while</span></code> statement.
It has two general forms.</p>

<p>The first form is similar to a while loop in a C-like language. For
example:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(){</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this form, the condition following the <code class="language-dafny highlighter-rouge"><span class="kr">while</span></code> is one of these:</p>

<ul>
  <li>A boolean expression. If true it means execute one more
iteration of the loop. If false then terminate the loop.</li>
  <li>An asterisk (<code class="language-dafny highlighter-rouge"><span class="o">*</span></code>), meaning non-deterministically yield either
<code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> or <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> as the value of the condition</li>
</ul>

<p>The <em>body</em> of the loop is usually a block statement, but it can also
be missing altogether.
A loop with a missing body may still pass verification, but any attempt
to compile the containing program will result in an error message.
When verifying a loop with a missing body, the verifier will skip attempts
to prove loop invariants and decreases assertions that would normally be
asserted at the end of the loop body.
There is more discussion about bodyless loops in <a href="#sec-bodyless-constructs">Section 8.15.4</a>.</p>

<p>The second form uses a case-based block. It is similar to the
<code class="language-dafny highlighter-rouge"><span class="n">do</span> <span class="o">...</span> <span class="n">od</span></code> construct used in the book A Discipline of Programming by
Edsger W. Dijkstra. For example:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">){</span>
  <span class="kr">var</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">n</span><span class="p">;</span>
  <span class="kr">while</span>
    <span class="kr">decreases</span> <span class="kr">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="kr">then</span> <span class="n">r</span> <span class="kr">else</span> <span class="o">-</span><span class="n">r</span>
  <span class="p">{</span>
    <span class="kr">case</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">=&gt;</span>
      <span class="n">r</span> <span class="o">:=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kr">case</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">=&gt;</span>
      <span class="n">r</span> <span class="o">:=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>For this form, the guards are evaluated in some undetermined order
until one is found that is true, in which case the corresponding statements
are executed and the while statement is repeated.
If none of the guards evaluates to true, then the
loop execution is terminated.</p>

<p>The form that used <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> (a refinement feature) as the guard is deprecated.</p>

<h3 id="sec-for-statement">8.13. For Loops (<a href="#g-for-statement">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve-warn Statements.15.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="kr">decreases</span> <span class="o">*</span> <span class="p">{</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">10</span> <span class="p">{}</span>
  <span class="kr">for</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">10</span> <span class="p">{}</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="o">*</span> <span class="kr">invariant</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="kr">decreases</span> <span class="o">*</span> <span class="p">{}</span>
  <span class="kr">for</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">10</span> <span class="kr">downto</span> <span class="mi">0</span> <span class="p">{}</span>
  <span class="kr">for</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">10</span> <span class="kr">downto</span> <span class="mi">0</span> 
<span class="p">}</span>
</code></pre></div></div>
<p>The <code class="language-dafny highlighter-rouge"><span class="kr">for</span></code> statement provides a convenient way to write some common loops.</p>

<p>The statement introduces a local variable with optional type, which is called
the <em>loop index</em>. The loop index is in scope in the specification and the body,
but not after the <code class="language-dafny highlighter-rouge"><span class="kr">for</span></code> loop. Assignments to the loop index are not allowed.
The type of the loop index can typically be inferred; if so, it need not be given
explicitly. If the identifier is not used, it can be written as <code class="language-dafny highlighter-rouge"><span class="n">_</span></code>, as illustrated
in this repeat-20-times loop:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">for</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">20</span> <span class="p">{</span>
  <span class="n">Body</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There are four basic variations of the <code class="language-dafny highlighter-rouge"><span class="kr">for</span></code> loop:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">for</span> <span class="n">i</span><span class="o">:</span> <span class="n">T</span> <span class="o">:=</span> <span class="n">lo</span> <span class="kr">to</span> <span class="n">hi</span>
  <span class="n">LoopSpec</span>
<span class="p">{</span> <span class="n">Body</span> <span class="p">}</span>

<span class="kr">for</span> <span class="n">i</span><span class="o">:</span> <span class="n">T</span> <span class="o">:=</span> <span class="n">hi</span> <span class="kr">downto</span> <span class="n">lo</span>
  <span class="n">LoopSpec</span>
<span class="p">{</span> <span class="n">Body</span> <span class="p">}</span>

<span class="kr">for</span> <span class="n">i</span><span class="o">:</span> <span class="n">T</span> <span class="o">:=</span> <span class="n">lo</span> <span class="kr">to</span> <span class="o">*</span>
  <span class="n">LoopSpec</span>
<span class="p">{</span> <span class="n">Body</span> <span class="p">}</span>

<span class="kr">for</span> <span class="n">i</span><span class="o">:</span> <span class="n">T</span> <span class="o">:=</span> <span class="n">hi</span> <span class="kr">downto</span> <span class="o">*</span>
  <span class="n">LoopSpec</span>
<span class="p">{</span> <span class="n">Body</span> <span class="p">}</span>
</code></pre></div></div>
<p>Semantically, they are defined as the following respective <code class="language-dafny highlighter-rouge"><span class="kr">while</span></code> loops:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{</span>
  <span class="kr">var</span> <span class="err">_</span><span class="n">lo</span><span class="p">,</span> <span class="err">_</span><span class="n">hi</span> <span class="o">:=</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="err">_</span><span class="n">lo</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="kr">forall</span> <span class="err">_</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="err">_</span><span class="n">lo</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">hi</span> <span class="o">==&gt;</span> <span class="err">_</span><span class="n">i</span> <span class="ow">is</span> <span class="n">T</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="err">_</span><span class="n">lo</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="err">_</span><span class="n">hi</span>
    <span class="kr">invariant</span> <span class="err">_</span><span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">hi</span>
    <span class="n">LoopSpec</span>
    <span class="kr">decreases</span> <span class="err">_</span><span class="n">hi</span> <span class="o">-</span> <span class="n">i</span>
  <span class="p">{</span>
    <span class="n">Body</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="kr">var</span> <span class="err">_</span><span class="n">lo</span><span class="p">,</span> <span class="err">_</span><span class="n">hi</span> <span class="o">:=</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="err">_</span><span class="n">lo</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">hi</span> <span class="o">&amp;&amp;</span> <span class="kr">forall</span> <span class="err">_</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="err">_</span><span class="n">lo</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">hi</span> <span class="o">==&gt;</span> <span class="err">_</span><span class="n">i</span> <span class="ow">is</span> <span class="n">T</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="err">_</span><span class="n">hi</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">lo</span>
    <span class="kr">invariant</span> <span class="err">_</span><span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">hi</span>
    <span class="n">LoopSpec</span>
    <span class="kr">decreases</span> <span class="n">i</span> <span class="o">-</span> <span class="err">_</span><span class="n">lo</span>
  <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">Body</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="kr">var</span> <span class="err">_</span><span class="n">lo</span> <span class="o">:=</span> <span class="n">lo</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="kr">forall</span> <span class="err">_</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="err">_</span><span class="n">lo</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">i</span> <span class="o">==&gt;</span> <span class="err">_</span><span class="n">i</span> <span class="ow">is</span> <span class="n">T</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="err">_</span><span class="n">lo</span><span class="p">;</span>
  <span class="kr">while</span> <span class="kc">true</span>
    <span class="kr">invariant</span> <span class="err">_</span><span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">i</span>
    <span class="n">LoopSpec</span>
  <span class="p">{</span>
    <span class="n">Body</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="kr">var</span> <span class="err">_</span><span class="n">hi</span> <span class="o">:=</span> <span class="n">hi</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="kr">forall</span> <span class="err">_</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="err">_</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">hi</span> <span class="o">==&gt;</span> <span class="err">_</span><span class="n">i</span> <span class="ow">is</span> <span class="n">T</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="err">_</span><span class="n">hi</span><span class="p">;</span>
  <span class="kr">while</span> <span class="kc">true</span>
    <span class="kr">invariant</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="err">_</span><span class="n">hi</span>
    <span class="n">LoopSpec</span>
  <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">Body</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The expressions <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> are evaluated just once, before the loop
iterations start.</p>

<p>Also, in all variations the values of <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> in the body are the values
from <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> to, <em>but not including</em>, <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code>. This makes it convenient to
write common loops, including these:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="p">{</span>
  <span class="n">Process</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="kr">downto</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="n">Process</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Nevertheless, <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> must be a legal value for the type of the index variable,
since that is how the index variable is used in the invariant.</p>

<p>If the end-expression is not <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, then no explicit <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> is
allowed, since such a loop is already known to terminate.
If the end-expression is <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, then the absence of an explicit <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code>
clause makes it default to <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="o">*</span></code>. So, if the end-expression is <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> and no
explicit <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause is given, the loop is allowed only in methods
that are declared with <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="o">*</span></code>.</p>

<p>The directions <code class="language-dafny highlighter-rouge"><span class="kr">to</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">downto</span></code> are contextual keywords. That is, these two
words are part of the syntax of the <code class="language-dafny highlighter-rouge"><span class="kr">for</span></code> loop, but they are not reserved
keywords elsewhere.</p>

<p>Just like for while loops, the body of a for-loop may be omitted during
verification. This suppresses attempts to check assertions (like invariants)
that would occur at the end of the loop. Eventually, however a body must
be provided; the compiler will not compile a method containing a body-less
for-loop. There is more discussion about bodyless loops in <a href="#sec-bodyless-constructs">Section 8.15.4</a>.</p>

<h3 id="sec-break-continue-statement">8.14. Break and Continue Statements (<a href="#g-break-continue-statement">grammar</a>)</h3>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span> <span class="p">{</span> <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span> <span class="p">}</span>
<span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">label</span> <span class="n">x</span><span class="o">:</span>
  <span class="kr">while</span> <span class="kc">true</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span> <span class="kr">break</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="kr">label</span> <span class="n">y</span><span class="o">:</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">z</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kr">if</span> <span class="o">*</span> <span class="p">{</span> <span class="kr">break</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">z</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Break and continue statements provide a means to transfer control
in a way different than the usual nested control structures.
There are two forms of each of these statements: with and without a label.</p>

<p>If a label is used, the break or continue statement must be enclosed in a statement
with that label. The enclosing statement is called the <em>target</em> of the break
or continue.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code> statement transfers control to the point immediately
following the target statement. For example, such a break statement can be
used to exit a sequence of statements in a block statement before
reaching the end of the block.</p>

<p>For example,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">label</span> <span class="n">L</span><span class="o">:</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">ReadNext</span><span class="p">();</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="kr">break</span> <span class="n">L</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">DoSomething</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>is equivalent to
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{</span>
  <span class="kr">var</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">ReadNext</span><span class="p">();</span>
  <span class="kr">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If no label is specified and the statement lists <code class="language-dafny highlighter-rouge"><span class="n">n</span></code>
occurrences of <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code>, then the statement must be enclosed in
at least <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> levels of loop statements. Control continues after exiting <code class="language-dafny highlighter-rouge"><span class="n">n</span></code>
enclosing loops. For example,</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">10</span> <span class="p">{</span>
    <span class="kr">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">10</span> <span class="p">{</span>
      <span class="kr">label</span> <span class="n">X</span><span class="o">:</span> <span class="p">{</span>
        <span class="kr">for</span> <span class="n">k</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">10</span> <span class="p">{</span>
          <span class="kr">if</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">15</span> <span class="p">{</span>
            <span class="kr">break</span> <span class="kr">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// control continues here after the "break break", exiting two loops</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that a non-labeled <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code> pays attention only to loops, not to labeled
statements. For example, the labeled block <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> in the previous example
does not play a role in determining the target statement of the <code class="language-dafny highlighter-rouge"><span class="kr">break</span> <span class="kr">break</span><span class="p">;</span></code>.</p>

<p>For a <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> statement, the target statement must be a loop statement.
The continue statement transfers control to the point immediately
before the closing curly-brace of the loop body.</p>

<p>For example,
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">17</span> <span class="p">{</span>
      <span class="n">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">){}</span>
</code></pre></div></div>
<p>is equivalent to
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">17</span> <span class="p">{</span>
      <span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">){}</span>
</code></pre></div></div>
<p>The same effect can also be obtained by wrapping the loop body in a labeled
block statement and then using <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code> with a label, but that usually makes
for a more cluttered program:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="kr">label</span> <span class="n">LoopBody</span><span class="o">:</span> <span class="p">{</span>
      <span class="kr">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">17</span> <span class="p">{</span>
        <span class="kr">break</span> <span class="n">LoopBody</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">){}</span>
</code></pre></div></div>

<p>Stated differently, <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> has the effect of ending the current loop iteration,
after which control continues with any remaining iterations. This is most natural
for <code class="language-dafny highlighter-rouge"><span class="kr">for</span></code> loops. For a <code class="language-dafny highlighter-rouge"><span class="kr">while</span></code> loop, be careful to make progress toward termination
before a <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> statement. For example, the following program snippet shows
an easy mistake to make (the verifier will complain that the loop may not terminate):</p>

<!-- %check-verify Statements.1.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">17</span> <span class="p">{</span>
      <span class="n">continue</span><span class="p">;</span> <span class="c1">// error: this would cause an infinite loop</span>
    <span class="p">}</span>
    <span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">){}</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> statement can give a label, provided the label is a label of a loop.
For example,</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">label</span> <span class="n">Outer</span><span class="o">:</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="kr">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">100</span> <span class="p">{</span>
      <span class="kr">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">19</span> <span class="p">{</span>
        <span class="n">continue</span> <span class="n">Outer</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">WorkIt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">PostProcess</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">// the "continue Outer" statement above transfers control to here</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">WorkIt</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">,</span> <span class="n">j</span><span class="o">:</span><span class="kt">int</span><span class="p">){}</span>
<span class="kr">method</span> <span class="n">PostProcess</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">){}</span>
</code></pre></div></div>

<p>If a non-labeled continue statement lists <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> occurrences of <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code> before the
<code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> keyword, then the statement must be enclosed in at least <code class="language-dafny highlighter-rouge"><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span></code> levels
of loop statements. The effect is to <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code> out of the <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> most closely enclosing
loops and then <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> the iterations of the next loop. That is, <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> occurrences
of <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code> followed by one more <code class="language-dafny highlighter-rouge"><span class="kr">break</span><span class="p">;</span></code> will break out of <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> levels of loops
and then do a <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code>, whereas <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> occurrences of <code class="language-dafny highlighter-rouge"><span class="kr">break</span></code> followed by <code class="language-dafny highlighter-rouge"><span class="n">continue</span><span class="p">;</span></code>
will break out of <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> levels of loops and then do a <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code>.</p>

<p>For example, the <code class="language-dafny highlighter-rouge"><span class="n">WorkIt</span></code> example above can equivalently be written without labels
as
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="kr">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="mi">100</span> <span class="p">{</span>
      <span class="kr">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">19</span> <span class="p">{</span>
        <span class="kr">break</span> <span class="n">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">WorkIt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">PostProcess</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">// the "break continue" statement above transfers control to here</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">WorkIt</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">,</span> <span class="n">j</span><span class="o">:</span><span class="kt">int</span><span class="p">){}</span>
<span class="kr">method</span> <span class="n">PostProcess</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">){}</span>
</code></pre></div></div>

<p>Note that a loop invariant is checked on entry to a loop and at the closing curly-brace
of the loop body. It is not checked at break statements. For continue statements, 
the loop invariant is checked as usual at the closing curly-brace
that the continue statement jumps to.
This checking ensures that the loop invariant holds at the very top of
every iteration. Commonly, the only exit out of a loop happens when the loop guard evaluates
to <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>. Since no state is changed between the top of an iteration (where the loop
invariant is known to hold) and the evaluation of the loop guard, one can also rely on
the loop invariant to hold immediately following the loop. But the loop invariant may
not hold immediately following a loop if a loop iteration changes the program state and
then exits the loop with a break statement.</p>

<p>For example, the following program verifies:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span>
    <span class="kr">invariant</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span>
  <span class="p">{</span>
    <span class="kr">if</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">200</span><span class="p">;</span>
      <span class="kr">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">||</span> <span class="mi">200</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">210</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">predicate</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">)</span>
</code></pre></div></div>
<p>To explain the example, the loop invariant <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span></code> is known to hold at the very top
of each iteration,
that is, just before the loop guard <code class="language-dafny highlighter-rouge"><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span></code> is evaluated. If the loop guard evaluates
to <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>, then the negated guard condition (<code class="language-dafny highlighter-rouge"><span class="mi">10</span> <span class="o">&lt;=</span> <span class="n">i</span></code>) and the invariant hold, so
<code class="language-dafny highlighter-rouge"><span class="n">i</span> <span class="o">==</span> <span class="mi">10</span></code> will hold immediately after the loop. If the loop guard evaluates to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>
(that is, <code class="language-dafny highlighter-rouge"><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span></code> holds), then the loop body is entered. If the test <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></code> then evaluates
to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>, the loop adds <code class="language-dafny highlighter-rouge"><span class="mi">200</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> and breaks out of the loop, so on such a
path, <code class="language-dafny highlighter-rouge"><span class="mi">200</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">210</span></code> is known to hold immediately after the loop. This is summarized
in the assert statement in the example.
So, remember, a loop invariant holds at the very top of every iteration, not necessarily
immediately after the loop.</p>

<h3 id="sec-loop-specifications">8.15. Loop Specifications</h3>
<p>For some simple loops, such as those mentioned previously, Dafny can figure
out what the loop is doing without more help. However, in general the user
must provide more information in order to help Dafny prove the effect of
the loop. This information is provided by a <em>loop specification</em>. A
loop specification provides information about invariants, termination, and
what the loop modifies.
For additional tutorial information see [@KoenigLeino:MOD2011] or the
<a href="../OnlineTutorial/guide">online Dafny tutorial</a>.</p>

<h4 id="sec-loop-invariants">8.15.1. Loop invariants</h4>

<p>Loops present a problem for specification-based reasoning. There is no way to
know in advance how many times the code will go around the loop and
a tool cannot reason about every one of a possibly unbounded sequence of unrollings.
In order to consider all paths through a program, specification-based
program verification tools require loop invariants, which are another kind of
annotation.</p>

<p>A loop invariant is an expression that holds just prior to the loop test,
that is, upon entering a loop and
after every execution of the loop body. It captures something that is
invariant, i.e. does not change, about every step of the loop. Now,
obviously we are going to want to change variables, etc. each time around
the loop, or we wouldnt need the loop. Like pre- and postconditions, an
invariant is a property that is preserved for each execution of the loop,
expressed using the same boolean expressions we have seen. For example,</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span>
  <span class="kr">invariant</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span>
<span class="p">{</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you specify an invariant, Dafny proves two things: the invariant
holds upon entering the loop, and it is preserved by the loop. By
preserved, we mean that assuming that the invariant holds at the
beginning of the loop (just prior to the loop test), we must show that executing the loop body once
makes the invariant hold again. Dafny can only know upon analyzing the
loop body what the invariants say, in addition to the loop guard (the
loop condition). Just as Dafny will not discover properties of a method
on its own, it will not know that any but the most basic properties of a loop
are preserved unless it is told via an invariant.</p>

<h4 id="sec-loop-termination">8.15.2. Loop termination</h4>

<p>Dafny proves that code terminates, i.e. does not loop forever, by using
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> annotations. For many things, Dafny is able to guess the right
annotations, but sometimes it needs to be made explicit.
There are two places Dafny proves termination: loops and recursion.
Both of these situations require either an explicit annotation or a
correct guess by Dafny.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> annotation, as its name suggests, gives Dafny an expression
that decreases with every loop iteration or recursive call. There are two
conditions that Dafny needs to verify when using a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> expression:</p>

<ul>
  <li>that the expression actually gets smaller, and</li>
  <li>that it is bounded.</li>
</ul>

<p>That is, the expression must strictly decrease in a well-founded ordering
(cf. <a href="#sec-well-founded-orders">Section 12.7</a>).</p>

<p>Many times, an integral value (natural or plain integer) is the quantity
that decreases, but other values can be used as well. In the case of
integers, the bound is assumed to be zero.
For each loop iteration the <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> expression at the end of the loop
body must be strictly smaller than its value at the beginning of the loop
body (after the loop test). For integers, the well-founded relation between
<code class="language-dafny highlighter-rouge"><span class="n">x</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> is <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">X</span></code>.
Thus if the <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> value (<code class="language-dafny highlighter-rouge"><span class="n">X</span></code>) is negative at the
loop test, it must exit the loop, since there is no permitted value for
<code class="language-dafny highlighter-rouge"><span class="n">x</span></code> to have at the end of the loop body.</p>

<p>For example, the following is
a proper use of <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> on a loop:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">){</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">n</span><span class="p">;</span>
  <span class="kr">while</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span>
    <span class="kr">invariant</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span>
    <span class="kr">decreases</span> <span class="n">i</span>
  <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here Dafny has all the ingredients it needs to prove termination. The
variable <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> becomes smaller each loop iteration, and is bounded below by
zero. When <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> becomes 0, the lower bound of the well-founded order, control
flow exits the loop.</p>

<p>This is fine, except the loop is backwards compared to most loops, which
tend to count up instead of down. In this case, what decreases is not the
counter itself, but rather the distance between the counter and the upper
bound. A simple trick for dealing with this situation is given below:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">m</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">n</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> 
  <span class="kr">requires</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">n</span> 
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">m</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span>
    <span class="kr">invariant</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span>
    <span class="kr">decreases</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span>
  <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is actually Dafnys guess for this situation, as it sees <code class="language-dafny highlighter-rouge"><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span></code> and
assumes that <code class="language-dafny highlighter-rouge"><span class="n">n</span> <span class="o">-</span> <span class="n">i</span></code> is the quantity that decreases. The upper bound of the
loop invariant implies that <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="err"></span> <span class="n">i</span></code>, and gives Dafny a lower bound on
the quantity. This also works when the bound <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> is not constant, such as
in the binary search algorithm, where two quantities approach each other,
and neither is fixed.</p>

<p>If the <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause of a loop specifies <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, then no
termination check will be performed. Use of this feature is sound only with
respect to partial correctness.</p>

<h4 id="sec-loop-framing">8.15.3. Loop framing</h4>

<p>The specification of a loop also includes <em>framing</em>, which says what the
loop modifies. The loop frame includes both local variables and locations
in the heap.</p>

<p>For local variables, the Dafny verifier performs a syntactic
scan of the loop body to find every local variable or out-parameter that occurs as a left-hand
side of an assignment. These variables are called
<em>syntactic assignment targets of the loop</em>, or <em>syntactic loop targets</em> for short.
Any local variable or out-parameter that is not a syntactic assignment target is known by the
verifier to remain unchanged by the loop.</p>

<p>The heap may or may not be a syntactic loop target. It is when the loop body
syntactically contains a statement that can modify a heap location. This
includes calls to compiled methods, even if such a method has an empty
<code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause, since a compiled method is always allowed to allocate
new objects and change their values in the heap.</p>

<p>If the heap is not a syntactic loop target, then the verifier knows the heap
remains unchanged by the loop. If the heap <em>is</em> a syntactic loop target,
then the loops effective <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause determines what is allowed to be
modified by iterations of the loop body.</p>

<p>A loop can use <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clauses to declare the effective <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause
of the loop. If a loop does not explicitly declare any <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause, then
the effective <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause of the loop is the effective <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause
of the most tightly enclosing loop or, if there is no enclosing loop, the
<code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause of the enclosing method.</p>

<p>In most cases, there is no need to give an explicit <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause for a
loop. The one case where it is sometimes needed is if a loop modifies less
than is allowed by the enclosing method. Here are two simple methods that
illustrate this case:</p>

<!-- %check-verify Statements.2.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">Cell</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">data</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">M0</span><span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="n">Cell</span><span class="p">,</span> <span class="n">d</span><span class="o">:</span> <span class="n">Cell</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">d</span>
  <span class="kr">modifies</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
  <span class="kr">ensures</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">100</span>
<span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="o">:=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span>
    <span class="kr">invariant</span> <span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">i</span>
    <span class="c1">// Needs "invariant c.data == 100" or "modifies d" to verify</span>
  <span class="p">{</span>
    <span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="o">:=</span> <span class="n">d</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">M1</span><span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="n">Cell</span><span class="p">)</span>
  <span class="kr">modifies</span> <span class="n">c</span>
  <span class="kr">ensures</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">100</span>
<span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">:=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span>
    <span class="c1">// Needs "invariant c.data == 100" or "modifies {}" to verify</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">tmp</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Cell</span><span class="p">;</span>
    <span class="n">tmp</span><span class="o">.</span><span class="n">data</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-dafny highlighter-rouge"><span class="n">M0</span></code>, the effective <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause of the loop is <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span></code>. Therefore,
the methods postcondition <code class="language-dafny highlighter-rouge"><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">100</span></code> is not provable. To remedy the situation,
the loop needs to be declared either with <code class="language-dafny highlighter-rouge"><span class="kr">invariant</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">100</span></code> or with
<code class="language-dafny highlighter-rouge"><span class="kr">modifies</span> <span class="n">d</span></code>.</p>

<p>Similarly, the effective <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause of the loop in <code class="language-dafny highlighter-rouge"><span class="n">M1</span></code> is <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span> <span class="n">c</span></code>. Therefore,
the methods postcondition <code class="language-dafny highlighter-rouge"><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">100</span></code> is not provable. To remedy the situation,
the loop needs to be declared either with <code class="language-dafny highlighter-rouge"><span class="kr">invariant</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">100</span></code> or with
<code class="language-dafny highlighter-rouge"><span class="kr">modifies</span> <span class="p">{}</span></code>.</p>

<p>When a loop has an explicit <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause, there is, at the top of
every iteration, a proof obligation that</p>

<ul>
  <li>the expressions given in the <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause are <a href="#sec-assertion-batches">well-formed</a>, and</li>
  <li>everything indicated in the loop <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause is allowed to be modified by the
(effective <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause of the) enclosing loop or method.</li>
</ul>

<h4 id="sec-bodyless-constructs">8.15.4. Body-less methods, functions, loops, and aggregate statements</h4>

<p>Methods (including lemmas), functions, loops, and <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statements are ordinarily
declared with a body, that is, a curly-braces pair that contains (for methods, loops, and <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code>)
a list of zero-or-more statements or (for a function) an expression. In each case, Dafny syntactically
allows these constructs to be given without a body (no braces at all). This is to allow programmers to
temporarily postpone the development of the implementation of the method, function, loop, or
aggregate statement.</p>

<p>If a method has no body, there is no difference for callers of the method. Callers still reason
about the call in terms of the methods specification. But without a body, the verifier has
no method implementation to check against the specification, so the verifier is silently happy.
The compiler, on the other hand, will complain if it encounters a body-less method, because the
compiler is supposed to generate code for the method, but it isnt clever enough to do that by
itself without a given method body. If the method implementation is provided by code written
outside of Dafny, the method can be marked with an <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> annotation, in which case the
compiler will no longer complain about the absence of a method body; the verifier will not 
object either, even though there is now no proof that the Dafny specifications are satisfied
by the external implementation.</p>

<p>A lemma is a special kind of (ghost) method. Callers are therefore unaffected by the absence of a body,
and the verifier is silently happy with not having a proof to check against the lemma specification.
Despite a lemma being ghost, it is still the compiler that checks for, and complains about,
body-less lemmas. A body-less lemma is an unproven lemma, which is often known as an <em>axiom</em>.
If you intend to use a lemma as an axiom, omit its body and add the attribute <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code>, which
causes the compiler to suppress its complaint about the lack of a body.</p>

<p>Similarly, calls to a body-less function use only the specification of the function. The
verifier is silently happy, but the compiler complains (whether or not the function is ghost).
As for methods and lemmas, the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> and <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code> attributes can be used to suppress the
compilers complaint.</p>

<p>By supplying a body for a method or function, the verifier will in effect show the feasibility of
the specification of the method or function. By supplying an <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> or <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code> attribute,
you are taking that responsibility into your own hands. Common mistakes include forgetting to
provide an appropriate <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clause in the specification, or forgetting that
the results of functions in Dafny (unlike in most other languages) must be deterministic.</p>

<p>Just like methods and functions have two sides, callers and implementations, loops also have
two sides. One side (analogous to callers) is the context that uses the loop. That context treats
the loop in the same way, using its specifications, regardless of whether or not the loop has a body. The other side
is the loop body, that is, the implementation of each loop iteration. The verifier checks
that the loop body maintains the loop invariant and that the iterations will eventually terminate,
but if there is no loop body, the verifier is silently happy. This allows you to temporarily
postpone the authoring of the loop body until after youve made sure that the loop specification
is what you need in the context of the loop.</p>

<p>There is one thing that works differently for body-less loops than for loops with bodies.
It is the computation of syntactic loop targets, which become part of the loop frame
(see <a href="#sec-loop-framing">Section 8.15.3</a>). For a body-less loop, the local variables
computed as part of the loop frame are the mutable variables that occur free in the
loop specification. The heap is considered a part of the loop frame if it is used
for mutable fields in the loop specification or if the loop has an explicit <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause.
The IDE will display the computed loop frame in hover text.</p>

<p>For example, consider</p>

<!-- %check-verify Statements.3.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">Cell</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">data</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">const</span> <span class="n">K</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">BodylessLoop</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">c</span><span class="o">:</span> <span class="n">Cell</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">c</span><span class="o">.</span><span class="n">K</span> <span class="o">==</span> <span class="mi">8</span>
  <span class="kr">modifies</span> <span class="n">c</span>
<span class="p">{</span>
  <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">:=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="n">n</span>
    <span class="kr">invariant</span> <span class="n">c</span><span class="o">.</span><span class="n">K</span> <span class="o">&lt;</span> <span class="mi">10</span>
    <span class="kr">invariant</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">n</span>
    <span class="kr">invariant</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">10</span>
  <span class="kr">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">n</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">b</span> <span class="o">==</span> <span class="n">n</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The loop specification mentions local variable <code class="language-dafny highlighter-rouge"><span class="n">a</span></code>, and thus <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is considered part of
the loop frame. Since what the loop invariant says about <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is not strong enough to
prove the assertion <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">==</span> <span class="n">n</span></code> that follows the loop, the verifier complains about that
assertion.</p>

<p>Local variable <code class="language-dafny highlighter-rouge"><span class="n">b</span></code> is not mentioned in the loop specification, and thus <code class="language-dafny highlighter-rouge"><span class="n">b</span></code> is not
included in the loop frame. Since in-parameter <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> is immutable, it is not included
in the loop frame, either, despite being mentioned in the loop specification. For
these reasons, the assertion <code class="language-dafny highlighter-rouge"><span class="n">b</span> <span class="o">==</span> <span class="n">n</span></code> is provable after the loop.</p>

<p>Because the loop specification mentions the mutable field <code class="language-dafny highlighter-rouge"><span class="n">data</span></code>, the heap becomes
part of the loop frame. Since the loop invariant is not strong enough to prove the
assertion <code class="language-dafny highlighter-rouge"><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="mi">5</span></code> that follows the loop, the verifier complains about that
assertion. On the other hand, had <code class="language-dafny highlighter-rouge"><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">10</span></code> not been mentioned in the loop
specification, the assertion would be verified, since field <code class="language-dafny highlighter-rouge"><span class="n">K</span></code> is then the only
field mentioned in the loop specification and <code class="language-dafny highlighter-rouge"><span class="n">K</span></code> is immutable.</p>

<p>Finally, the aggregate statement (<code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code>) can also be given without a body. Such
a statement claims that the given <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause holds true for all values of
the bound variables that satisfy the given range constraint. If the statement has
no body, the program is in effect omitting the proof, much like a body-less lemma
is omitting the proof of the claim made by the lemma specification. As with the
other body-less constructs above, the verifier is silently happy with a body-less
<code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement, but the compiler will complain.</p>

<h3 id="sec-print-statement">8.16. Print Statement (<a href="#g-print-statement">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">print</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="kt">array</span><span class="p">;</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statement is used to print the values of a comma-separated
list of expressions to the console (standard-out). The generated code uses
target-language-specific idioms to perform this printing.
The expressions may of course include strings that are used
for captions. There is no implicit new line added, so to add a new
line you must include <code class="language-dafny highlighter-rouge"><span class="s2">"\n"</span></code> as part of one of the expressions.
Dafny automatically creates implementations of methods that convert values to strings
for all Dafny data types. For example,</p>

<!-- %check-run Statements.4.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Tree</span> <span class="o">=</span> <span class="n">Empty</span> <span class="o">|</span> <span class="n">Node</span><span class="p">(</span><span class="n">left</span><span class="o">:</span> <span class="n">Tree</span><span class="p">,</span> <span class="n">data</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">right</span><span class="o">:</span> <span class="n">Tree</span><span class="p">)</span>
<span class="kr">method</span> <span class="n">Main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Tree</span> <span class="o">:=</span> <span class="n">Node</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">Empty</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Empty</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Empty</span><span class="p">);</span>
  <span class="kr">print</span> <span class="s2">"x="</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s2">"\n"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>produces this output:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code>x=Tree.Node(Tree.Node(Tree.Empty, 1, Tree.Empty), 2, Tree.Empty)
</code></pre></div></div>

<p>Note that Dafny does not have method overriding and there is no mechanism to
override the built-in value-&gt;string conversion.  Nor is there a way to
explicitly invoke this conversion.
One can always write an explicit function to convert a data value to a string
and then call it explicitly in a <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statement or elsewhere.</p>

<p>By default, Dafny does not keep track of print effects, but this can be changed
using the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">track</span><span class="o">-</span><span class="kr">print</span><span class="o">-</span><span class="n">effects</span></code> command line flag. <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statements are allowed
only in non-ghost contexts and not in expressions, with one exception.
The exception is that a function-by-method may contain <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statements,
whose effect may be observed as part of the run-time evaluation of such functions
(unless <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">track</span><span class="o">-</span><span class="kr">print</span><span class="o">-</span><span class="n">effects</span></code> is enabled).</p>

<p>The verifier checks that each expression is well-defined, but otherwise 
ignores the <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statement.</p>

<p><a id="print-encoding"></a></p>

<p><strong>Note:</strong> <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> writes to standard output.  To improve compatibility with
native code and external libraries, the process of encoding Dafny strings passed
to <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> into standard-output byte strings is left to the runtime of the
language that the Dafny code is compiled to (some language runtimes use UTF-8 in
all cases; others obey the current locale or console encoding).</p>

<p>In most cases, the standard-output encoding can be set before running the
compiled program using language-specific flags or environment variables
(e.g. <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">Dfile</span><span class="o">.</span><span class="n">encoding</span><span class="o">=</span></code> for Java).  This is in fact how <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> operates:
it uses language-specific flags and variables to enforce UTF-8 output regardless
of the target language (but note that the C++ and Go backends currently have
limited support for UTF-16 surrogates).</p>

<h3 id="sec-assert-statement">8.17. Assert statement (<a href="#g-assert-statement">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">assert</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">assert</span> <span class="n">IsPositive</span><span class="o">:</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">assert</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">by</span> <span class="p">{</span>
 <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-dafny highlighter-rouge"><span class="n">Assert</span></code> statements are used to express logical propositions that are
expected to be true. Dafny will attempt to prove that the assertion
is true and give an error if the assertion cannot be proven.
Once the assertion is proved,
its truth may aid in proving subsequent deductions.
Thus if Dafny is having a difficult time verifying a method,
the user may help by inserting assertions that Dafny can prove,
and whose truth may aid in the larger verification effort,
much as lemmas might be used in mathematical proofs.</p>

<p><code class="language-dafny highlighter-rouge"><span class="n">Assert</span></code> statements are ignored by the compiler.</p>

<p>In the <code class="language-dafny highlighter-rouge"><span class="kr">by</span></code> form of the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statement, there is an additional block of statements that provide the Dafny verifier with additional proof steps.
Those statements are often a sequence of <a href="#sec-lemmas">lemmas</a>, <a href="#sec-calc-statement"><code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code></a> statements, <a href="#sec-reveal-statements"><code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code></a> statements or other <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statements,
combined with ghost control flow, ghost variable declarations and ghost update statements of variables declared in the <code class="language-dafny highlighter-rouge"><span class="kr">by</span></code> block.
The intent is that those statements be evaluated in support of proving the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statement.
For that purpose, they could be simply inserted before the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statement.
But by using the <code class="language-dafny highlighter-rouge"><span class="kr">by</span></code> block, the statements in the block are discarded after the assertion is proved.
As a result, the statements in the block do not clutter or confuse the solver in performing subsequent
proofs of assertions later in the program. Furthermore, by isolating the statements in the <code class="language-dafny highlighter-rouge"><span class="kr">by</span></code> block,
their purpose  to assist in proving the given assertion  is manifest in the structure of the code.</p>

<p>Examples of this form of assert are given in the section of the <a href="#sec-reveal-statement"><code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code></a> statement and in <a href="http://leino.science/papers/krml276.html"><em>Different Styles of Proof</em></a></p>

<p>An assert statement may have a label, whose use is explained in <a href="#sec-reveal-assertions">Section 8.20.1</a>.</p>

<p>The attributes recognized for assert statements are discussed in <a href="#sec-verification-attributes-on-assertions">Section 11.4</a>.</p>

<p>Using <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> as the argument of the statement is deprecated.</p>

<p>An assert statement can have <a href="#sec-error-attribute">custom error and success messages</a>.</p>

<h3 id="sec-assume-statement">8.18. Assume Statement (<a href="#g-assume-statement">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">assume</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">assume</span> <span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">==&gt;</span> <span class="o">-</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> statement lets the user specify a logical proposition
that Dafny may assume to be true without proof. If in fact the
proposition is not true this may lead to invalid conclusions.</p>

<p>An <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> statement would ordinarily be used as part of a larger
verification effort where verification of some other part of
the program required the proposition. By using the <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> statement
the other verification can proceed. Then when that is completed the
user would come back and replace the <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> with <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code>.</p>

<p>To help the user not forget about that last step, a warning is emitted for any assume statement.
Adding the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code> attribute to the assume will suppress the warning,
indicating the user takes responsibility for being absolutely sure 
that the proposition is indeed true.</p>

<p>Using <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> as the argument of the statement is deprecated.</p>

<h3 id="sec-expect-statement">8.19. Expect Statement (<a href="#g-expect-statement">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">expect</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">expect</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"i is positive"</span><span class="p">;</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statement states a boolean expression that is
(a) assumed to be true by the verifier
and (b) checked to be true
at run-time. That is, the compiler inserts into the run-time executable a
check that the given expression is true; if the expression is false, then
the execution of the program halts immediately. If a second argument is
given, it may be a value of any type.
That value is converted to a string (just like the <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statement)
and the string is included
in the message emitted by the program
when it halts; otherwise a default message is emitted.</p>

<p>Because the expect expression and optional second argument are compiled, they cannot be ghost expressions.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statement behaves like
<code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> for the verifier, but also inserts a run-time check that the
assumption is indeed correct (for the test cases used at run-time).</p>

<p>Here are a few use-cases for the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statement.</p>

<p>A) To check the specifications of external methods.</p>

<p>Consider an external method <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code> that takes a <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> as input
and returns a <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> value that is less than the input.
Such a method could be specified as
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span> <span class="n">Random</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span>
</code></pre></div></div>
<p>But because there is no body for <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code> (only the external non-dafny implementation),
it cannot be verified that <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code> actually satisfies this specification.</p>

<p>To mitigate this situation somewhat, we can define a wrapper function, <code class="language-dafny highlighter-rouge"><span class="n">Random'</span></code>,
that calls <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code> but in which we can put some run-time checks:
<!-- %check-resolve %options --allow-external-contracts --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span> <span class="n">Random</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>

<span class="kr">method</span> <span class="n">Random'</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span>
<span class="p">{</span>
  <span class="n">r</span> <span class="o">:=</span> <span class="n">Random</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="kr">expect</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Here we can verify that <code class="language-dafny highlighter-rouge"><span class="n">Random'</span></code> satisfies its own specification,
relying on the unverified specification of <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code>.
But we are also checking at run-time that any input-output pairs for <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code>
encountered during execution
do satisfy the specification,
as they are checked by the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statement.</p>

<p>Note, in this example, two problems still remain.
One problem is that the out-parameter of the extern <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code> has type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code>,
but there is no check that the value returned really is non-negative.
It would be better to declare the out-parameter of <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code> to be <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> and
to include <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span></code> in the condition checked by the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statement in <code class="language-dafny highlighter-rouge"><span class="n">Random'</span></code>.
The other problem is that <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code> surely will need <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> to be strictly positive.
This can be fixed by adding <code class="language-dafny highlighter-rouge"><span class="kr">requires</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">Random'</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Random</span></code>.</p>

<p>B) Run-time testing</p>

<p>Verification and run-time testing are complementary
and both have their role in assuring that software does what is intended.
Dafny can produce executables
and these can be instrumented with unit tests.
Annotating a method with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span></code> attribute
indicates to the compiler
that it should produce target code
that is correspondingly annotated to mark the method
as a unit test (e.g., an XUnit test) in the target language.
Alternatively, the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">test</span></code> command will produce a main method
that invokes all methods with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span></code> attribute, and hence does not
depend on any testing framework in the target language.
Within such methods one might use <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statements (as well as <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statements)
to insert checks that the target program is behaving as expected.</p>

<p>C) Debugging</p>

<p>While developing a new program, one work style uses proof attempts and runtime tests in combination.
If an assert statement does not prove, one might run the program with a corresponding expect statement
to see if there are some conditions when the assert is not actually true. So one might have
paired assert/expect statements:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">assert</span> <span class="err">_</span><span class="n">P_</span><span class="p">;</span>
<span class="kr">expect</span> <span class="err">_</span><span class="n">P_</span><span class="p">;</span>
</code></pre></div></div>
<p>Once the program is debugged, both statements can be removed.
Note that it is important that the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> come before the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code>, because
by the verifier, the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> is interpreted as an <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code>, which would automatically make
a subsequent <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> succeed.</p>

<p>D) Compiler tests</p>

<p>The same approach might be taken to assure that compiled code is behaving at run-time consistently with the statically verified code,
one can again use paired assert/expect statements with the same expression:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">assert</span> <span class="err">_</span><span class="n">P_</span><span class="p">;</span>
<span class="kr">expect</span> <span class="err">_</span><span class="n">P_</span><span class="p">;</span>
</code></pre></div></div>
<p>The verifier will check that <em>P</em> is always true at the given point in a program
(at the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statement).</p>

<p>At run-time, the compiler will insert checks that the same predicate,
in the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statement, is true.
Any difference identifies a compiler bug.
Again the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> must be after the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code>:
if the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> is first,
then the verifier will interpret the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> like an <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code>,
in which case the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> will be proved trivially
and potential unsoundness will be hidden.</p>

<p>Using <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> as the argument of the statement is deprecated.</p>

<h3 id="sec-reveal-statement">8.20. Reveal Statement (<a href="#g-reveal-statement">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">reveal</span> <span class="n">f</span><span class="p">(),</span> <span class="n">L</span><span class="p">;</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> statement makes available to the solver information that is otherwise not visible, as described in the following subsections.</p>

<h4 id="sec-reveal-assertions">8.20.1. Revealing assertions</h4>

<p>If an assert statement has an expression label, then a proof of that assertion is attempted, but the assertion itself
is not used subsequently.  For example, consider
<!-- %check-verify Statements.5.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">x</span><span class="o">:</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Fails</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Fails also because the label 'x:' hides the first assertion</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The first assertion fails. Without the label <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">:</span></code>, the second would succeed because after a failing assertion, the 
assertion is assumed in the context of the rest of the program.  But with the label, the first assertion is hidden from
the rest of the program. That assertion can be <em>revealed</em> by adding a <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> statement:</p>

<!-- %check-verify Statements.6.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">x</span><span class="o">:</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Fails</span>
  <span class="kr">reveal</span> <span class="n">x</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Now succeeds</span>
<span class="p">}</span>
</code></pre></div></div>
<p>or
<!-- %check-verify Statements.7.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">x</span><span class="o">:</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Fails</span>
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">by</span> <span class="p">{</span> <span class="kr">reveal</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Now succeeds</span>
<span class="p">}</span>
</code></pre></div></div>
<p>At the point of the <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> statement, the labeled assertion is made visible and can be used in proving the second assertion.
In this example there is no point to labeling an assertion and then immediately revealing it. More useful are the cases where
the reveal is in an assert-by block or much later in the method body.</p>

<h4 id="8202-revealing-preconditions">8.20.2. Revealing preconditions</h4>

<p>In the same way as assertions, preconditions can be labeled.
Within the body of a method, a precondition is an assumption; if the precondition is labeled then that assumption is not visible in the body of the method.
A <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> statement naming the label of the precondition then makes the assumption visible.</p>

<p>Here is a toy example:
<!-- %check-verify Statements.8.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">z</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">L</span><span class="o">:</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">y</span>
  <span class="kr">ensures</span> <span class="n">z</span> <span class="o">==</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
  <span class="kr">ensures</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">z</span>
<span class="p">{</span>
  <span class="n">z</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The above method will not verify. In particular, the second postcondition cannot be proved.
However, if we add a <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span> <span class="n">L</span><span class="p">;</span></code> statement in the body of the method, then the precondition is visible 
and both postconditions can be proved.</p>

<p>One could also use this style:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">z</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">L</span><span class="o">:</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">y</span>
  <span class="kr">ensures</span> <span class="n">z</span> <span class="o">==</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
  <span class="kr">ensures</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">z</span>
<span class="p">{</span>
  <span class="n">z</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">z</span> <span class="kr">by</span> <span class="p">{</span> <span class="kr">reveal</span> <span class="n">L</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The reason to possibly hide a precondition is the same as the reason to hide assertions: 
sometimes less information is better for the solver as it helps the solver focus attention on 
relevant information.</p>

<p>Section 7 of <a href="http://leino.science/papers/krml276.html">http://leino.science/papers/krml276.html</a> provides 
an extended illustration of this technique to make all the dependencies of an <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> explicit.</p>

<h4 id="hide-statement">8.20.3. Hiding and revealing function bodies</h4>

<p>By default, function bodies are revealed and available for constructing proofs of assertions that use those functions.
However, if a function body is not necessary for a proof, the runtime of the proof can be improved by hiding that body.
To do this, use the hide statement. Heres an example:</p>

<!-- %check-verify %options --isolate-assertions --type-system-refresh -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// We are using the options --isolate-assertions and --type-system-refresh</span>
<span class="kr">method</span> <span class="n">Outer</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">ComplicatedBody</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">hide</span> <span class="n">ComplicatedBody</span><span class="p">;</span> <span class="c1">// This hides the body of ComplicatedBody for the remainder of the method.</span>
  
  <span class="c1">// The body of ComplicatedBody is not needed to prove the requires of Inner</span>
  <span class="kr">var</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  
  <span class="c1">// We reveal ComplicatedBody inside the following expression, to prove that we are not dividing by zero</span>
  <span class="kr">var</span> <span class="n">z</span> <span class="o">:=</span> <span class="p">(</span><span class="kr">reveal</span> <span class="n">ComplicatedBody</span><span class="p">;</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Inner</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">ComplicatedBody</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="kr">predicate</span> <span class="n">ComplicatedBody</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span> <span class="c1">// pretend true is complicated </span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here is a larger example that shows the rules for hide and reveal statements when used on functions:</p>

<!-- %check-verify Statements.8b.expect %options --isolate-assertions --type-system-refresh -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// We are using the options --isolate-assertions and --type-system-refresh</span>
<span class="kr">predicate</span> <span class="n">P</span><span class="p">()</span> <span class="p">{</span> <span class="kc">true</span> <span class="p">}</span>
<span class="kr">predicate</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">requires</span> <span class="n">x</span>

<span class="kr">method</span> <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">q1</span> <span class="o">:=</span> <span class="n">Q</span><span class="p">(</span><span class="n">hide</span> <span class="n">P</span><span class="p">;</span> <span class="n">P</span><span class="p">());</span> <span class="c1">// error, precondition not satisfied</span>
  <span class="kr">var</span> <span class="n">q2</span> <span class="o">:=</span> <span class="n">Q</span><span class="p">(</span><span class="n">hide</span> <span class="n">P</span><span class="p">;</span> <span class="kr">reveal</span> <span class="n">P</span><span class="p">;</span> <span class="n">P</span><span class="p">());</span> <span class="c1">// no error</span>
  
  <span class="n">hide</span> <span class="o">*</span><span class="p">;</span>
  
  <span class="kr">var</span> <span class="n">q3</span> <span class="o">:=</span> <span class="n">Q</span><span class="p">(</span><span class="n">P</span><span class="p">());</span> <span class="c1">// error, precondition not satisfied</span>
  <span class="kr">var</span> <span class="n">q4</span> <span class="o">:=</span> <span class="n">Q</span><span class="p">(</span><span class="kr">reveal</span> <span class="n">P</span><span class="p">;</span> <span class="n">P</span><span class="p">());</span> <span class="c1">// no error</span>
  
  <span class="kr">if</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">reveal</span> <span class="n">P</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">P</span><span class="p">();</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">P</span><span class="p">();</span> <span class="c1">// error</span>
  <span class="p">}</span>
  <span class="kr">reveal</span> <span class="n">P</span><span class="p">;</span>
  <span class="kr">if</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">P</span><span class="p">();</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="n">hide</span> <span class="o">*</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">P</span><span class="p">();</span> <span class="c1">// error</span>
  <span class="p">}</span>
  
  <span class="n">hide</span> <span class="o">*</span><span class="p">;</span>
  <span class="kr">if</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">reveal</span> <span class="n">P</span><span class="p">;</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">reveal</span> <span class="n">P</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="n">P</span><span class="p">();</span> <span class="c1">// error, since the previous two reveal statements are out of scope</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="8204-revealing-constants">8.20.4. Revealing constants</h4>

<p>A <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> declaration can be <code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code>. If so the value of the constant is not known in reasoning about its uses, just its type and the
fact that the value does not change. The constants identifier can be listed in a reveal statement. In that case, like other revealed items,
the value of the constant will be known to the reasoning engine until the end of the block containing the reveal statement.</p>

<p>A label or locally declared name in a method body will shadow an opaque constant with the same name outside the method body,
making it unable to be revealed without using a qualified name.</p>

<h3 id="sec-forall-statement">8.21. Forall Statement (<a href="#g-forall-statement">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="p">{</span>
  <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// P a lemma</span>
<span class="p">}</span>
<span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span>
  <span class="kr">ensures</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement executes the body
simultaneously for all quantified values in the specified quantifier domain.
You can find more details about <a href="#sec-quantifier-domains">quantifier domains here</a>.</p>

<p>There are several variant uses of the <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code>
statement and there are a number of restrictions.
A <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement can be classified as one of the following:</p>

<ul>
  <li><em>Assign</em> - the <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement is used for simultaneous assignment.
The target must be an array element or an object field.</li>
  <li><em>Call</em> - The body consists of a single call to a ghost method without side effects</li>
  <li><em>Proof</em> - The <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> has <code class="language-dafny highlighter-rouge"><span class="n">ensure</span></code> expressions which are effectively
quantified or proved by the body (if present).</li>
</ul>

<p>An <em>assign</em> <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement performs simultaneous assignment.
The left-hand sides must denote different l-values, unless the
corresponding right-hand sides also coincide.</p>

<p>The following is an excerpt of an example given by Leino in
<a href="http://research.microsoft.com/en-us/um/people/leino/papers/krml233.pdf"><em>Developing Verified Programs with Dafny</em></a>.
When the buffer holding the queue needs to be resized,
the <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement is used to simultaneously copy the old contents
into the new buffer.</p>

<!-- %check-verify %options --relax-definite-assignment -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">SimpleQueue</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">Contents</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;</span>
  <span class="kr">var</span> <span class="n">a</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&gt;</span>  <span class="c1">// Buffer holding contents of queue.</span>
  <span class="kr">var</span> <span class="n">m</span><span class="o">:</span> <span class="kt">int</span>          <span class="c1">// Index head of queue.</span>
  <span class="kr">var</span> <span class="n">n</span><span class="o">:</span> <span class="kt">int</span>          <span class="c1">// Index just past end of queue</span>
   
  <span class="kr">method</span> <span class="n">Enqueue</span><span class="p">(</span><span class="n">d</span><span class="o">:</span> <span class="n">Data</span><span class="p">)</span>
    <span class="kr">requires</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="kr">requires</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span>
    <span class="kr">modifies</span> <span class="kr">this</span><span class="p">,</span> <span class="kr">this</span><span class="o">.</span><span class="n">a</span>
    <span class="kr">ensures</span> <span class="n">Contents</span> <span class="o">==</span> <span class="kr">old</span><span class="p">(</span><span class="n">Contents</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
  <span class="p">{</span>
    <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="p">{</span>
      <span class="kr">var</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">a</span><span class="p">;</span>
      <span class="kr">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">b</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Data</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span><span class="p">];</span> <span class="p">}</span>
      <span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="p">{</span>
      	<span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">a</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">Contents</span> <span class="o">:=</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Contents</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here is an example of a <em>call</em> <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement and the
callee. This is contained in the <code class="language-dafny highlighter-rouge"><span class="n">CloudMake</span><span class="o">-</span><span class="n">ConsistentBuilds</span><span class="o">.</span><span class="n">dfy</span></code>
test in the Dafny repository.</p>

<!-- %no-check Too many undeclared symbols -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">forall</span> <span class="n">cmd'</span><span class="p">,</span> <span class="n">deps'</span><span class="p">,</span> <span class="n">e'</span> <span class="o">|</span>
       <span class="n">Hash</span><span class="p">(</span><span class="n">Loc</span><span class="p">(</span><span class="n">cmd'</span><span class="p">,</span> <span class="n">deps'</span><span class="p">,</span> <span class="n">e'</span><span class="p">))</span> <span class="o">==</span> <span class="n">Hash</span><span class="p">(</span><span class="n">Loc</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">deps</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">HashProperty</span><span class="p">(</span><span class="n">cmd'</span><span class="p">,</span> <span class="n">deps'</span><span class="p">,</span> <span class="n">e'</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">deps</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">lemma</span> <span class="n">HashProperty</span><span class="p">(</span><span class="n">cmd</span><span class="o">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">deps</span><span class="o">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">ext</span><span class="o">:</span> <span class="kt">string</span><span class="p">,</span>
    <span class="n">cmd'</span><span class="o">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">deps'</span><span class="o">:</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">ext'</span><span class="o">:</span> <span class="kt">string</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">Hash</span><span class="p">(</span><span class="n">Loc</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">deps</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span> <span class="o">==</span> <span class="n">Hash</span><span class="p">(</span><span class="n">Loc</span><span class="p">(</span><span class="n">cmd'</span><span class="p">,</span> <span class="n">deps'</span><span class="p">,</span> <span class="n">ext'</span><span class="p">))</span>
  <span class="kr">ensures</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">cmd'</span> <span class="o">&amp;&amp;</span> <span class="n">deps</span> <span class="o">==</span> <span class="n">deps'</span> <span class="o">&amp;&amp;</span> <span class="n">ext</span> <span class="o">==</span> <span class="n">ext'</span>
</code></pre></div></div>

<p>The following example of a <em>proof</em> <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement comes from the same file:</p>

<!-- %no-check Too many undeclared symbols -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">p</span> <span class="o">|</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">DomSt</span><span class="p">(</span><span class="n">stCombinedC</span><span class="o">.</span><span class="n">st</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">DomSt</span><span class="p">(</span><span class="n">stExecC</span><span class="o">.</span><span class="n">st</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">GetSt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">stCombinedC</span><span class="o">.</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="n">GetSt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">stExecC</span><span class="o">.</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">assert</span> <span class="n">DomSt</span><span class="p">(</span><span class="n">stCombinedC</span><span class="o">.</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">DomSt</span><span class="p">(</span><span class="n">stExecC</span><span class="o">.</span><span class="n">st</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">stCombinedC</span><span class="o">.</span><span class="n">st</span> <span class="o">==</span> <span class="n">Restrict</span><span class="p">(</span><span class="n">DomSt</span><span class="p">(</span><span class="n">stCombinedC</span><span class="o">.</span><span class="n">st</span><span class="p">),</span>
                                               <span class="n">stExecC</span><span class="o">.</span><span class="n">st</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>More generally, the statement
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">x</span> <span class="o">|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">Lemma</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div></div>
<p>is used to invoke <code class="language-dafny highlighter-rouge"><span class="n">Lemma</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> on all <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> for which <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> holds. If
<code class="language-dafny highlighter-rouge"><span class="n">Lemma</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> ensures <code class="language-dafny highlighter-rouge"><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>, then the forall statement establishes
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement is also used extensively in the de-sugared forms of
co-predicates and co-lemmas. See <a href="#sec-coinductive-datatypes">datatypes</a>.</p>

<h3 id="sec-modify-statement">8.22. Modify Statement (<a href="#g-modify-statement">grammar</a>)</h3>

<p>The effect of the <code class="language-dafny highlighter-rouge"><span class="kr">modify</span></code> statement
is to say that some undetermined
modifications have been made to any or all of the memory
locations specified by the given <a href="#sec-frame-expression">frame expressions</a>.
In the following example, a value is assigned to field <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>
followed by a <code class="language-dafny highlighter-rouge"><span class="kr">modify</span></code> statement that may modify any field
in the object. After that we can no longer prove that the field
<code class="language-dafny highlighter-rouge"><span class="n">x</span></code> still has the value we assigned to it. The now unknown values
still are values of their type (e.g. of the subset type or newtype).</p>

<!-- %check-verify Statements.10.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">MyClass</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">method</span> <span class="n">N</span><span class="p">()</span>
    <span class="kr">modifies</span> <span class="kr">this</span>
  <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="kr">modify</span> <span class="kr">this</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">18</span><span class="p">;</span>  <span class="c1">// error: cannot conclude this here</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> as the argument of the statement is deprecated.</p>

<p>The form of the <code class="language-dafny highlighter-rouge"><span class="kr">modify</span></code> statement which includes a block
statement is also deprecated.</p>

<p>The <a href="#sec-havoc-statement">havoc assignment</a> also sets a variable or field
to some arbitrary (but type-consistent) value. The difference is that
the havoc assignment acts on one LHS variable or memory location;
the modify statement acts on all the fields of an object.</p>

<h3 id="sec-calc-statement">8.23. Calc Statement (<a href="#g-calc-statement">grammar</a>)</h3>

<p>See also: <a href="http://research.microsoft.com/en-us/um/people/leino/papers/krml231.pdf">Verified Calculations</a>.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> statement supports <em>calculational proofs</em> using a language
feature called <em>program-oriented calculations</em> (poC). This feature was
introduced and explained in the [<em>Verified Calculations</em>] paper by Leino
and Polikarpova[@LEINO:Dafny:Calc]. Please see that paper for a more
complete explanation of the <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> statement. We here mention only the
highlights.</p>

<p>Calculational proofs are proofs by stepwise formula manipulation
as is taught in elementary algebra. The typical example is to prove
an equality by starting with a left-hand-side and through a series of
transformations morph it into the desired right-hand-side.</p>

<p>Non-syntactic rules further restrict hints to only ghost and side-effect
free statements, as well as imposing a constraint that only
chain-compatible operators can be used together in a calculation. The
notion of chain-compatibility is quite intuitive for the operators
supported by poC; for example, it is clear that &lt; and &gt; cannot be used within
the same calculation, as there would be no relation to conclude between
the first and the last line. See the [paper][Verified Calculations] for
a more formal treatment of chain-compatibility.</p>

<p>Note that we allow a single occurrence of the intransitive operator != to
appear in a chain of equalities (that is, != is chain-compatible with
equality but not with any other operator, including itself). Calculations
with fewer than two lines are allowed, but have no effect. If a step
operator is omitted, it defaults to the calculation-wide operator,
defined after the <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> keyword. If that operator is omitted, it defaults
to equality.</p>

<p>Here is an example using <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> statements to prove an elementary
algebraic identity. As it turns out, Dafny is able to prove this without
the <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> statements, but the example illustrates the syntax.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">lemma</span> <span class="n">docalc</span><span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
<span class="p">{</span>
  <span class="kr">calc</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
    <span class="o">==</span>
    <span class="c1">// distributive law: (a + b) * c == a * c + b * c</span>
    <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
    <span class="o">==</span>
    <span class="c1">// distributive law: a * (b + c) == a * b + a * c</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="o">==</span>
    <span class="kr">calc</span> <span class="p">{</span>
	    <span class="n">y</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
      <span class="o">==</span>
	    <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="o">==</span>
    <span class="kr">calc</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
      <span class="o">==</span>
      <span class="c1">// a = 1 * a</span>
      <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
      <span class="o">==</span>
      <span class="c1">// Distributive law</span>
      <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
      <span class="o">==</span>
      <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here we started with <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span></code> as the left-hand-side
expressions and gradually transformed it using distributive,
commutative and other laws into the desired right-hand-side.</p>

<p>The justification for the steps are given as comments or as
nested <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> statements that prove equality of some sub-parts
of the expression.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="o">==</span></code> operators show the relation between
the previous expression and the next. Because of the transitivity of
equality we can then conclude that the original left-hand-side is
equal to the final expression.</p>

<p>We can avoid having to supply the relational operator between
every pair of expressions by giving a default operator between
the <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> keyword and the opening brace as shown in this abbreviated
version of the above calc statement:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">lemma</span> <span class="n">docalc</span><span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
<span class="p">{</span>
  <span class="kr">calc</span> <span class="o">==</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And since equality is the default operator, we could have omitted
it after the <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> keyword.
The purpose of the block statements or the <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> statements between
the expressions is to provide hints to aid Dafny in proving that
step. As shown in the example, comments can also be used to aid
the human reader in cases where Dafny can prove the step automatically.</p>

<h3 id="sec-opaque-block">8.24. Opaque Block (<a href="#g-opaque-block">grammar</a>)</h3>
<p>As a Dafny sequence of statements grows in length, it can become harder to verify later statements in the block. With each statement, new information can become available, and with each modification of the heap, it becomes more expensive to access information from an older heap version. To reduce the verification complexity of long lists of statements, Dafny users can extract part of this block into a separate method or lemma. However, doing so introduces some boilerplate, which is where opaque blocks come in. They achieve a similar effect on verification performance as extracting code, but without the boilerplate.</p>

<p>An opaque block is similar to a block statement: it contains a sequence of zero or more statements, enclosed by curly braces. However, an opaque block is preceded by the keyword opaque, and may define ensures and modifies clauses before the curly braces. Anything that happens inside the block is invisible to the statements that come after it, unless it is specified by the ensures clause. Here is an example:</p>

<!-- %check-verify Statements.opaqueBlock.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">OpaqueBlockUser</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">4</span> 
<span class="p">{</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">opaque</span>
    <span class="kr">ensures</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span> 
  <span class="p">{</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// error</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>By default, the modifies clause of an opaque block is the same as that of the enclosing context. Opaque blocks may be nested.</p>

<!--PDF NEWPAGE-->
<h2 id="sec-expressions">9. Expressions</h2>

<p>Dafny expressions come in three flavors.</p>
<ul>
  <li>The bulk of expressions have no side-effects and can be used within
methods, functions, and specifications, and in either compiled or ghost code.</li>
  <li>Some expressions, called <a href="#sec-rhs-expression">right-hand-side expressions</a>,
do have side-effects and may only be used in specific syntactic locations,
such as the right-hand-side of update (assignment) statements; 
object allocation and method calls are two typical examples of <a href="#sec-rhs-expression">right-hand-side expressions</a>. Note that method calls are syntactically
indistinguishable from function calls; both are Expressions (<a href="#sec-primary-expression">PrimaryExpressions</a>
with an <a href="#sec-argument-list-suffix">ArgumentList suffix</a>). However, method calls are semantically permitted
only in right-hand-side expression locations.</li>
  <li>Some expressions are allowed only in specifications and other ghost code,
as listed <a href="#sec-list-of-specification-expressions">here</a>.</li>
</ul>

<p>The grammar of Dafny expressions follows a hierarchy that
reflects the precedence of Dafny operators. The following
table shows the Dafny operators and their precedence
in order of increasing binding power.</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th style="text-align: center">precedence</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="p">;</span></code></td>
      <td style="text-align: center">0</td>
      <td>That is <a href="#sec-top-level-expression">LemmaCall; Expression</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;==&gt;</span></code></td>
      <td style="text-align: center">1</td>
      <td><a href="#sec-equivalence-expression">equivalence (if and only if)</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">==&gt;</span></code></td>
      <td style="text-align: center">2</td>
      <td><a href="#sec-implies-expression">implication (implies)</a></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;==</span></code></td>
      <td style="text-align: center">2</td>
      <td><a href="#sec-implies-expression">reverse implication (follows from)</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&amp;&amp;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&amp;</span></code></td>
      <td style="text-align: center">3</td>
      <td><a href="#sec-logical-expression">conjunction (and)</a></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">||</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">|</span></code></td>
      <td style="text-align: center">3</td>
      <td><a href="#sec-logical-expression">disjunction (or)</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">==</span></code></td>
      <td style="text-align: center">4</td>
      <td>equality</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">==</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></code></td>
      <td style="text-align: center">4</td>
      <td><a href="#sec-co-equality">prefix equality (coinductive)</a></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!=</span></code></td>
      <td style="text-align: center">4</td>
      <td>disequality</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!=</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></code></td>
      <td style="text-align: center">4</td>
      <td><a href="#sec-co-equality">prefix disequality (coinductive)</a></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code></td>
      <td style="text-align: center">4</td>
      <td>less than</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code></td>
      <td style="text-align: center">4</td>
      <td>at most</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code></td>
      <td style="text-align: center">4</td>
      <td>at least</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code></td>
      <td style="text-align: center">4</td>
      <td>greater than</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="ow">in</span></code></td>
      <td style="text-align: center">4</td>
      <td>collection membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="ow">in</span></code></td>
      <td style="text-align: center">4</td>
      <td>collection non-membership</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!!</span></code></td>
      <td style="text-align: center">4</td>
      <td>disjointness</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&lt;&lt;</span></code></td>
      <td style="text-align: center">5</td>
      <td><a href="#sec-bit-shift-expression">left-shift</a></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&gt;&gt;</span></code></td>
      <td style="text-align: center">5</td>
      <td><a href="#sec-bit-shift-expression">right-shift</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">+</span></code></td>
      <td style="text-align: center">6</td>
      <td>addition (plus)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">-</span></code></td>
      <td style="text-align: center">6</td>
      <td>subtraction (minus)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">*</span></code></td>
      <td style="text-align: center">7</td>
      <td>multiplication (times)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">/</span></code></td>
      <td style="text-align: center">7</td>
      <td>division (divided by)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">%</span></code></td>
      <td style="text-align: center">7</td>
      <td>modulus (mod)</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">|</span></code></td>
      <td style="text-align: center">8</td>
      <td><a href="#sec-bitvector-expression">bit-wise or</a></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">&amp;</span></code></td>
      <td style="text-align: center">8</td>
      <td><a href="#sec-bitvector-expression">bit-wise and</a></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">^</span></code></td>
      <td style="text-align: center">8</td>
      <td><a href="#sec-bitvector-expression">bit-wise exclusive-or (not equal)</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="ow">as</span></code> operation</td>
      <td style="text-align: center">9</td>
      <td><a href="#sec-as-is-expression">type conversion</a></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="ow">is</span></code> operation</td>
      <td style="text-align: center">9</td>
      <td><a href="#sec-as-is-expression">type test</a></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">-</span></code></td>
      <td style="text-align: center">10</td>
      <td>arithmetic negation (unary minus)</td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="o">!</span></code></td>
      <td style="text-align: center">10</td>
      <td>logical negation, bit-wise complement</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>Primary Expressions</td>
      <td style="text-align: center">11</td>
      <td></td>
    </tr>
  </tbody>
</table>

<h3 id="sec-top-level-expression">9.1. Lemma-call expressions (<a href="#g-top-level-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">L</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span>
</code></pre></div></div>

<p>This expression has the form <code class="language-dafny highlighter-rouge"><span class="n">S</span><span class="p">;</span> <span class="n">E</span></code>.
The type of the expression is the type of <code class="language-dafny highlighter-rouge"><span class="n">E</span></code>.
<code class="language-dafny highlighter-rouge"><span class="n">S</span></code> must be a lemma call (though the grammar appears more lenient).
The lemma introduces a fact necessary to establish properties of <code class="language-dafny highlighter-rouge"><span class="n">E</span></code>.</p>

<p>Sometimes an expression will fail unless some relevant fact is known.
In the following example the <code class="language-dafny highlighter-rouge"><span class="n">F_Fails</span></code> function fails to verify
because the <code class="language-dafny highlighter-rouge"><span class="n">Fact</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></code> divisor may be zero. But preceding
the expression by a lemma that ensures that the denominator
is not zero allows function <code class="language-dafny highlighter-rouge"><span class="n">F_Succeeds</span></code> to succeed.
<!-- %check-verify Expressions.1.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">Fact</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">Fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kr">lemma</span> <span class="n">L</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">Fact</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kr">function</span> <span class="n">F_Fails</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">{</span>
  <span class="mi">50</span> <span class="o">/</span> <span class="n">Fact</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1">// error: possible division by zero</span>
<span class="p">}</span>

<span class="kr">function</span> <span class="n">F_Succeeds</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">{</span>
  <span class="n">L</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">// note, this is a lemma call in an expression</span>
  <span class="mi">50</span> <span class="o">/</span> <span class="n">Fact</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>One restriction is that a lemma call in this form is permitted only in situations in which the expression itself is not terminated by a semicolon.</p>

<p>A second restriction is that <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> is not always permitted to contain lambda expressions, such 
as in the expressions that are the body of a lambda expression itself, function, method and iterator specifications,
and if and while statements with guarded alternatives.</p>

<p>A third restriction is that <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> is not always permitted to contain a bit-wise or (<code class="language-dafny highlighter-rouge"><span class="o">|</span></code>) operator, 
because it would be ambiguous with the vertical bar used in comprehension expressions.</p>

<p>Note that the effect of the lemma call only extends to the succeeding expression <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> (which may be another <code class="language-dafny highlighter-rouge"><span class="p">;</span></code> expression).</p>

<h3 id="sec-equivalence-expression">9.2. Equivalence Expressions (<a href="#g-equivalence-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span>
<span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="n">B</span>
<span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="n">C</span> <span class="o">==&gt;</span> <span class="n">D</span> <span class="o">&lt;==&gt;</span> <span class="n">B</span> 
</code></pre></div></div>

<p>An Equivalence Expression that contains one or more <code class="language-dafny highlighter-rouge"><span class="o">&lt;==&gt;</span></code>s is
a boolean expression and all the operands
must also be boolean expressions. In that case each <code class="language-dafny highlighter-rouge"><span class="o">&lt;==&gt;</span></code>
operator tests for logical equality which is the same as
ordinary equality (but with a different precedence).</p>

<p>See <a href="#sec-equivalence-operator">Section 5.2.1.1</a> for an explanation of the
<code class="language-dafny highlighter-rouge"><span class="o">&lt;==&gt;</span></code> operator as compared with the <code class="language-dafny highlighter-rouge"><span class="o">==</span></code> operator.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="o">&lt;==&gt;</span></code> operator is commutative and associative: <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="n">B</span> <span class="o">&lt;==&gt;</span> <span class="n">C</span></code> and <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="n">C</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="n">B</span> <span class="o">&lt;==&gt;</span> <span class="n">C</span><span class="p">)</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">C</span> <span class="o">&lt;==&gt;</span> <span class="n">B</span> <span class="o">&lt;==&gt;</span> <span class="n">A</span></code>
are all equivalent and are all true iff an even number of operands are false.</p>

<h3 id="sec-implies-expression">9.3. Implies or Explies Expressions (<a href="#g-implies-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">==&gt;</span> <span class="n">B</span>
<span class="n">A</span> <span class="o">==&gt;</span> <span class="n">B</span> <span class="o">==&gt;</span> <span class="n">C</span> <span class="o">==&gt;</span> <span class="n">D</span>
<span class="n">B</span> <span class="o">&lt;==</span> <span class="n">A</span>
</code></pre></div></div>

<p>See <a href="#sec-implication-and-reverse-implication">Section 5.2.1.3</a> for an explanation
of the <code class="language-dafny highlighter-rouge"><span class="o">==&gt;</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">&lt;==</span></code> operators.</p>

<h3 id="sec-logical-expression">9.4. Logical Expressions (<a href="#g-logical-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span>
<span class="n">A</span> <span class="o">||</span> <span class="n">B</span>
<span class="o">&amp;&amp;</span> <span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span> <span class="o">&amp;&amp;</span> <span class="n">C</span>
</code></pre></div></div>

<p>Note that the Dafny grammar allows a conjunction or disjunction to be
<em>prefixed</em> with <code class="language-dafny highlighter-rouge"><span class="o">&amp;&amp;</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">||</span></code> respectively. This form simply allows a
parallel structure to be written:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">object?</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span><span class="kt">object?</span><span class="p">,</span> <span class="n">z</span><span class="o">:</span> <span class="kt">object?</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">b</span><span class="o">:</span> <span class="kt">bool</span> <span class="o">:=</span>
    <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span>
    <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">!=</span> <span class="kc">null</span>
    <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">!=</span> <span class="kc">null</span>
    <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is purely a syntactic convenience allowing easy edits such as reordering
lines or commenting out lines without having to check that the infix
operators are always where they should be.</p>

<p>Note also that <code class="language-dafny highlighter-rouge"><span class="o">&amp;&amp;</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">||</span></code> cannot be mixed without using parentheses:
<code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span> <span class="o">||</span> <span class="n">C</span></code> is not permitted. Write <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">||</span> <span class="n">C</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">||</span> <span class="n">C</span><span class="p">)</span></code> instead.</p>

<p>See <a href="#sec-conjunction-and-disjunction">Section 5.2.1.2</a> for an explanation
of the <code class="language-dafny highlighter-rouge"><span class="o">&amp;&amp;</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">||</span></code> operators.</p>

<h3 id="sec-relational-expression">9.5. Relational Expressions (<a href="#g-relational-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">!=</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span>
<span class="n">x</span> <span class="ow">in</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">!</span> <span class="ow">in</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">!!</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">==</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="n">y</span>
</code></pre></div></div>

<p>The relation expressions compare two or more terms.
As explained in <a href="#sec-basic-type">the section about basic types</a>, <code class="language-dafny highlighter-rouge"><span class="o">==</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">!=</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code>
are <em>chaining</em>.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="ow">in</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="ow">in</span></code> operators apply to collection types as explained in
<a href="#sec-collection-types">Section 5.5</a> and represent membership or non-membership
respectively.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="o">!!</span></code> represents disjointness for sets and multisets as explained in
<a href="#sec-sets">Section 5.5.1</a> and <a href="#sec-multisets">Section 5.5.2</a>.</p>

<p><code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">==</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="n">y</span></code> is the prefix equality operator that compares
coinductive values for equality to a nesting level of k, as
explained in <a href="#sec-co-equality">the section about co-equality</a>.</p>

<h3 id="sec-bit-shift-expression">9.6. Bit Shifts (<a href="#g-bit-shift-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
<span class="n">j</span> <span class="o">&gt;&gt;</span> <span class="n">i</span>
</code></pre></div></div>

<p>These operators are the left and right shift operators for bit-vector values.
They take a bit-vector value and an <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>, shifting the bits by the given
amount; the result has the same bit-vector type as the LHS.
For the expression to be well-defined, the RHS value must be in the range 0 to the number of
bits in the bit-vector type, inclusive.</p>

<p>The operations are left-associative: <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">j</span></code> is <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">j</span></code>.</p>

<h3 id="sec-addition-expression">9.7. Terms (<a href="#g-term">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span>
</code></pre></div></div>

<p><code class="language-dafny highlighter-rouge"><span class="n">Terms</span></code> combine <code class="language-dafny highlighter-rouge"><span class="n">Factors</span></code> by adding or subtracting.
Addition has these meanings for different types:</p>

<ul>
  <li>arithmetic addition for numeric types (<a href="#sec-numeric-types">Section 5.2.2</a>])</li>
  <li>union for sets and multisets (<a href="#sec-sets">Section 5.5.1</a> and <a href="#sec-multisets">Section 5.5.2</a>)</li>
  <li>concatenation for sequences (<a href="#sec-sequences">Section 5.5.3</a>)</li>
  <li>map merging for maps (<a href="#sec-maps">Section 5.5.4</a>)</li>
</ul>

<p>Subtraction is</p>

<ul>
  <li>arithmetic subtraction for numeric types</li>
  <li>set or multiset subtraction for sets and multisets</li>
  <li>domain subtraction for maps.</li>
</ul>

<p>All addition operations are associative. Arithmetic addition and union are commutative. Subtraction is neither; it groups to the left as expected:
<code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">-</span><span class="n">z</span></code> is <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span><span class="n">z</span></code>.</p>

<h3 id="sec-multiplication-expression">9.8. Factors (<a href="#g-factor">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">%</span> <span class="n">y</span>
</code></pre></div></div>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">Factor</span></code> combines expressions using multiplication,
division, or modulus. For numeric types these are explained in
<a href="#sec-numeric-types">Section 5.2.2</a>.
As explained there, <code class="language-dafny highlighter-rouge"><span class="o">/</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">%</span></code> on <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> values represent <em>Euclidean</em>
integer division and modulus and not the typical C-like programming
language operations.</p>

<p>Only <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> has a non-numeric application. It represents set or multiset
intersection as explained in <a href="#sec-sets">Section 5.5.1</a> and <a href="#sec-multisets">Section 5.5.2</a>.</p>

<p><code class="language-dafny highlighter-rouge"><span class="o">*</span></code> is commutative and associative; <code class="language-dafny highlighter-rouge"><span class="o">/</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">%</span></code> are neither but do group to the left.</p>

<h3 id="sec-bitvector-expression">9.9. Bit-vector Operations (<a href="#g-bit-vector-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span> <span class="o">|</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span>
<span class="n">x</span> <span class="o">^</span> <span class="n">y</span>
</code></pre></div></div>

<p>These operations take two bit-vector values of the same type, returning
a value of the same type. The operations perform bit-wise <em>or</em> (<code class="language-dafny highlighter-rouge"><span class="o">|</span></code>),
<em>and</em> (<code class="language-dafny highlighter-rouge"><span class="o">&amp;</span></code>), and <em>exclusive-or</em> (<code class="language-dafny highlighter-rouge"><span class="o">^</span></code>). To perform bit-wise equality, use
<code class="language-dafny highlighter-rouge"><span class="o">^</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">!</span></code> (unary complement) together. (<code class="language-dafny highlighter-rouge"><span class="o">==</span></code> is boolean equality of the whole bit-vector.)</p>

<p>These operations are associative and commutative but do not associate with each other.
Use parentheses: <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="o">|</span> <span class="n">c</span></code> is illegal; use <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">|</span> <span class="n">c</span><span class="p">)</span></code>
instead.</p>

<p>Bit-vector operations are not allowed in some contexts.
The <code class="language-dafny highlighter-rouge"><span class="o">|</span></code> symbol is used both for bit-wise or and as the delimiter in a
<a href="#sec-cardinality-expression">cardinality</a> expression: an ambiguity arises if
the expression E in <code class="language-dafny highlighter-rouge"><span class="o">|</span> <span class="n">E</span> <span class="o">|</span></code> contains a <code class="language-dafny highlighter-rouge"><span class="o">|</span></code>. This situation is easily
remedied: just enclose E in parentheses, as in <code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">|</span></code>.
The only type-correct way this can happen is if the expression is
a comprehension, as in <code class="language-dafny highlighter-rouge"><span class="o">|</span> <span class="kt">set</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="n">x</span> <span class="o">|</span> <span class="mh">0x101</span> <span class="o">|</span></code>.</p>

<h3 id="sec-as-is-expression">9.10. As (Conversion) and Is (type test) Expressions (<a href="#g-as-is-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">e</span> <span class="ow">as</span> <span class="n">MyClass</span>
<span class="n">i</span> <span class="ow">as</span> <span class="kt">bv8</span>
<span class="n">e</span> <span class="ow">is</span> <span class="n">MyClass</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="ow">as</span></code> expression converts the given LHS to the type stated on the RHS,
with the result being of the given type. The following combinations
of conversions are permitted:</p>

<ul>
  <li>Any type to itself</li>
  <li>Any int-based or real-based numeric type or bit-vector type to another int-based or real-based numeric type or bit-vector type</li>
  <li>Any base type to a subset or newtype with that base</li>
  <li>Any subset or newtype to its base type or a subset or newtype of the same base</li>
  <li>Any type to a subset or newtype that has the type as its base</li>
  <li>Any trait to a class or trait that extends (perhaps recursively) that trait</li>
  <li>Any class or trait to a trait extended by that class or trait</li>
</ul>

<p>Some of the conversions above are already implicitly allowed, without the
<code class="language-dafny highlighter-rouge"><span class="ow">as</span></code> operation, such as from a subset type to its base. In any case, it
must be able to be proved that the value of the given expression is a
legal value of the given type. For example, <code class="language-dafny highlighter-rouge"><span class="mi">5</span> <span class="ow">as</span> <span class="n">MyType</span></code> is permitted (by the verifier) only if <code class="language-dafny highlighter-rouge"><span class="mi">5</span></code> is a legitimate value of<code class="language-dafny highlighter-rouge"><span class="n">MyType</span></code> (which must be a numeric type).</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="ow">as</span></code> operation is like a grammatical suffix or postfix operation.
However, note that the unary operations bind more tightly than does <code class="language-dafny highlighter-rouge"><span class="ow">as</span></code>.
That is <code class="language-dafny highlighter-rouge"><span class="o">-</span> <span class="mi">5</span> <span class="ow">as</span> <span class="kt">nat</span></code> is <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">as</span> <span class="kt">nat</span></code> (which fails), whereas <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="ow">as</span> <span class="kt">nat</span></code>
is <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="ow">as</span> <span class="kt">nat</span><span class="p">)</span></code>. On the other hand, <code class="language-dafny highlighter-rouge"><span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span></code> is <code class="language-dafny highlighter-rouge"><span class="o">-</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span></code>.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="ow">is</span></code> expression is grammatically similar to the <code class="language-dafny highlighter-rouge"><span class="ow">as</span></code> expression, with the
same binding power. The <code class="language-dafny highlighter-rouge"><span class="ow">is</span></code> expression is a type test that
returns a <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code> value indicating whether the LHS expression is a legal
value of the RHS type. The expression can be used to check
whether a trait value is of a particular class type. That is, the expression
in effect checks the allocated type of a trait.</p>

<p>The RHS type of an <code class="language-dafny highlighter-rouge"><span class="ow">is</span></code> expression can always be a supertype of the type of the LHS
expression, in which case the result is trivally true. 
Other than that, the RHS must be based on a reference type and the
LHS expression must be assignable to the RHS type. Furthermore, in order to be
compilable, the RHS type must not be a subset type other than a non-null reference
type, and the type parameters of the RHS must be uniquely determined from the
type parameters of the LHS type. The last restriction is designed to make it
possible to perform type tests without inspecting type parameters at run time.
For example, consider the following types:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">trait</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">trait</span> <span class="n">B</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">class</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="n">B</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">class</span> <span class="n">D</span><span class="o">&lt;</span><span class="n">Y</span><span class="p">(</span><span class="o">==</span><span class="p">)</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="n">B</span><span class="o">&lt;</span><span class="kt">set</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&gt;</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">class</span> <span class="n">E</span> <span class="kr">extends</span> <span class="n">B</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span>
<span class="kr">class</span> <span class="n">F</span><span class="o">&lt;</span><span class="n">Z</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div>

<p>A LHS expression of type <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="o">&lt;</span><span class="kt">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span></code> can be used in a type test where the RHS is
<code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="o">&lt;</span><span class="kt">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">C</span><span class="o">&lt;</span><span class="kt">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span></code>, or <code class="language-dafny highlighter-rouge"><span class="n">D</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code>, and a LHS expression of type <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code>
can be used in a type test where the RHS is <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code>, or <code class="language-dafny highlighter-rouge"><span class="n">E</span></code>. Those
are always allowed in compiled (and ghost) contexts.
For an expression <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> of type <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>, the expression <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="ow">is</span> <span class="n">F</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code> is a ghost expression;
it can be used in ghost contexts, but not in compiled contexts.</p>

<p>For an expression <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> and type <code class="language-dafny highlighter-rouge"><span class="n">t</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="ow">is</span> <span class="n">t</span></code> is the condition determining whether
<code class="language-dafny highlighter-rouge"><span class="n">e</span> <span class="ow">as</span> <span class="n">t</span></code> is well-defined (but, as noted above, is not always a legal expression).</p>

<p><em>The repertoire of types allowed in <code class="language-dafny highlighter-rouge"><span class="ow">is</span></code> tests may be expanded in the future.</em></p>

<h3 id="sec-unary-expression">9.11. Unary Expressions (<a href="#g-unary-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="o">-</span><span class="n">x</span>
<span class="o">-</span> <span class="o">-</span> <span class="n">x</span>
<span class="o">!</span> <span class="n">x</span>
</code></pre></div></div>

<p>A unary expression applies</p>

<ul>
  <li>logical complement (<code class="language-dafny highlighter-rouge"><span class="o">!</span></code>  <a href="#sec-booleans">Section 5.2.1</a>),</li>
  <li>bit-wise complement (<code class="language-dafny highlighter-rouge"><span class="o">!</span></code>  <a href="#sec-bit-vector-types">Section 5.2.4</a>),</li>
  <li>numeric negation (<code class="language-dafny highlighter-rouge"><span class="o">-</span></code>  <a href="#sec-numeric-types">Section 5.2.2</a>), or</li>
  <li>bit-vector negation (<code class="language-dafny highlighter-rouge"><span class="o">-</span></code>  <a href="#sec-bit-vector-types">Section 5.2.4</a>)</li>
</ul>

<p>to its operand.</p>

<h3 id="sec-primary-expression">9.12. Primary Expressions (<a href="#g-primary-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kc">true</span>
<span class="mi">34</span>
<span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">d</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
<span class="kt">map</span><span class="p">[</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="kt">int</span><span class="p">,</span><span class="n">j</span><span class="o">:</span><span class="kt">int</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">i</span><span class="o">+</span><span class="n">j</span>
<span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="mi">4</span> <span class="kr">else</span> <span class="mi">5</span>
</code></pre></div></div>

<p>After descending through all the binary and unary operators we arrive at
the primary expressions, which are explained in subsequent sections. 
A number of these can be followed by 0 or more suffixes
to select a component of the value.</p>

<h3 id="sec-lambda-expression">9.13. Lambda expressions (<a href="#g-lambda-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="n">x</span>
<span class="n">_</span> <span class="o">=&gt;</span> <span class="kc">true</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>
<span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span><span class="kt">bool</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="o">-</span><span class="n">x</span>
<span class="n">x</span> <span class="kr">requires</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>See <a href="#sec-lambda-specification">Section 7.4</a> for a description of specifications for lambda expressions.</p>

<p>In addition to named functions, Dafny supports expressions that define
functions.  These are called <em>lambda (expression)s</em> (some languages
know them as <em>anonymous functions</em>).  A lambda expression has the
form:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">(</span> <span class="err">_</span><span class="n">params_</span> <span class="p">)</span> <span class="err">_</span><span class="n">specification_</span> <span class="o">=&gt;</span> <span class="err">_</span><span class="n">body_</span>
</code></pre></div></div>
<p>where <em>params</em> is a comma-delimited list of parameter
declarations, each of which has the form <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">:</span> <span class="n">T</span></code>.  The type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>
of a parameter can be omitted when it can be inferred.  If the
identifier <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is not needed, it can be replaced by <code class="language-dafny highlighter-rouge"><span class="n">_</span></code>.  If
<em>params</em> consists of a single parameter <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> (or <code class="language-dafny highlighter-rouge"><span class="n">_</span></code>) without an
explicit type, then the parentheses can be dropped; for example, the
function that returns the successor of a given integer can be written
as the following lambda expression:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The <em>specification</em> is a list of clauses <code class="language-dafny highlighter-rouge"><span class="kr">requires</span> <span class="n">E</span></code> or
<code class="language-dafny highlighter-rouge"><span class="kr">reads</span> <span class="n">W</span></code>, where <code class="language-dafny highlighter-rouge"><span class="n">E</span></code> is a boolean expression and <code class="language-dafny highlighter-rouge"><span class="n">W</span></code> is a frame
expression.</p>

<p><em>body</em> is an expression that defines the functions return
value.  The body must be <a href="#sec-assertion-batches">well-formed</a> for all possible values of the
parameters that satisfy the precondition (just like the bodies of
named functions and methods).  In some cases, this means it is
necessary to write explicit <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> clauses.  For
example, the lambda expression
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span> <span class="kr">requires</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">x</span>
</code></pre></div></div>
<p>would not be <a href="#sec-assertion-batches">well-formed</a> if the <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause were omitted,
because of the possibility of division-by-zero.</p>

<p>In settings where functions cannot be partial and there are no
restrictions on reading the heap, the <em>eta expansion</em> of a function
<code class="language-dafny highlighter-rouge"><span class="n">F</span><span class="o">:</span> <span class="n">T</span> <span class="o">-&gt;</span> <span class="n">U</span></code> (that is, the wrapping of <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> inside a lambda expression
in such a way that the lambda expression is equivalent to <code class="language-dafny highlighter-rouge"><span class="n">F</span></code>) would
be written <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>.  In Dafny, eta expansion must also account for
the precondition and reads set of the function, so the eta expansion
of <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> looks like:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span> <span class="kr">requires</span> <span class="n">F</span><span class="o">.</span><span class="kr">requires</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">reads</span> <span class="n">F</span><span class="o">.</span><span class="kr">reads</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="sec-lhs-expression">9.14. Left-Hand-Side Expressions (<a href="#g-lhs-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">x</span>
<span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
<span class="n">LibraryModule</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
<span class="kr">old</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
</code></pre></div></div>

<p>A left-hand-side expression is only used on the left hand
side of an <a href="#sec-update-and-call-statement">Update statement</a>
or an <a href="#sec-update-with-failure-statement">Update with Failure Statement</a>.</p>

<p>An LHS can be</p>

<ul>
  <li>a simple identifier: <code class="language-dafny highlighter-rouge"><span class="n">k</span></code></li>
  <li>an expression with a dot suffix: <code class="language-dafny highlighter-rouge"><span class="kr">this</span><span class="o">.</span><span class="n">x</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">y</span></code></li>
  <li>an expression with an array selection: <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="n">a8</span><span class="p">)[</span><span class="mi">6</span><span class="p">]</span></code></li>
</ul>

<h3 id="sec-rhs-expression">9.15. Right-Hand-Side Expressions (<a href="#g-rhs-expression">grammar</a>)</h3>

<p>Examples: 
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="kr">new</span> <span class="n">MyClass</span>
<span class="kr">new</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="n">z</span>
<span class="o">*</span>
</code></pre></div></div>

<p>A Right-Hand-Side expression is an expression-like construct that may have 
side-effects. Consequently such expressions
 can only be used within certain statements
within methods, and not as general expressions or within functions or specifications.</p>

<p>An RHS is either an array allocation, an object allocation,
a havoc right-hand-side, a method call, or a simple expression, optionally followed
by one or more attributes.</p>

<p>Right-hand-side expressions (that are not just regular expressions) appear in the following constructs:</p>

<ul>
  <li><a href="#sec-return-statement">return statements</a>,</li>
  <li><a href="#sec-yield-statement">yield statements</a>,</li>
  <li><a href="#sec-update-and-call-statement">update statements</a>,</li>
  <li><a href="#sec-update-with-failure-statement">update-with-failure statements</a>, or</li>
  <li><a href="#sec-variable-declaration-statement">variable declaration statements</a>.</li>
</ul>

<p>These are the only contexts in which arrays or objects may be
allocated or in which havoc may be stipulated.</p>

<h3 id="sec-array-allocation">9.16. Array Allocation (<a href="#g-array-allocation-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="kr">new</span> <span class="kt">int</span><span class="p">[][</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">](</span><span class="n">i</span> <span class="o">=&gt;</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="p">)</span>
</code></pre></div></div>

<p>This right-hand-side expression allocates a new single or multi-dimensional array (cf. <a href="#sec-array-type">Section 5.10</a>).
The initialization portion is optional. One form is an
explicit list of values, in which case the dimension is optional:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="kr">var</span> <span class="n">b</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">];</span>
<span class="kr">var</span> <span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[][</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">];</span>
<span class="kr">var</span> <span class="n">d</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">];</span> <span class="c1">// error</span>
</code></pre></div></div>
<p>The comprehension form requires a dimension and uses a function of
type <code class="language-dafny highlighter-rouge"><span class="kt">nat</span> <span class="o">-&gt;</span> <span class="n">T</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is the array element type:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">](</span><span class="n">i</span> <span class="o">=&gt;</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
</code></pre></div></div>

<p>To allocate a multi-dimensional array, simply give the sizes of
each dimension. For example,
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">m</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">real</span><span class="p">[</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">];</span>
</code></pre></div></div>
<p>allocates a 640-by-480 two-dimensional array of <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code>s. The initialization
portion cannot give a display of elements like in the one-dimensional
case, but it can use an initialization function. A function used to initialize
a n-dimensional array requires a function from n <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code>s to a <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>, where <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>
is the element type of the array. Here is an example:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">diag</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">]((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Array allocation is permitted in ghost contexts. If any expression
used to specify a dimension or initialization value is ghost, then the
<code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> allocation can only be used in ghost contexts. Because the
elements of an array are non-ghost, an array allocated in a ghost
context in effect cannot be changed after initialization.</p>

<h3 id="sec-object-allocation">9.17. Object Allocation (<a href="#g-object-allocation-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">new</span> <span class="n">MyClass</span>
<span class="kr">new</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">Init</span>
<span class="kr">new</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p>This right-hand-side expression 
allocates a new object of a class type as explained
in section <a href="#sec-class-types">Class Types</a>.</p>

<h3 id="sec-havoc-expression">9.18. Havoc Right-Hand-Side (<a href="#g-havoc-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="o">*</span>
</code></pre></div></div>
<p>A havoc right-hand-side is just a <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> character.
It produces an arbitrary value of its associated
type. The assign-such-that
operator (<code class="language-dafny highlighter-rouge"><span class="o">:|</span></code>) can be used to obtain a more constrained arbitrary value. 
See <a href="#sec-update-and-call-statement">Section 8.5</a>.</p>

<h3 id="sec-atomic-expression">9.19. Constant Or Atomic Expressions (<a href="#g-atomic-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">this</span>
<span class="kc">null</span>
<span class="mi">5</span>
<span class="mf">5.5</span>
<span class="kc">true</span>
<span class="sc">'a'</span>
<span class="s2">"dafny"</span>
<span class="p">(</span> <span class="n">e</span> <span class="p">)</span>
<span class="o">|</span> <span class="n">s</span> <span class="o">|</span>
<span class="kr">old</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="kr">allocated</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="kr">unchanged</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="kr">fresh</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="n">assigned</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>These expressions are never l-values. They include</p>

<ul>
  <li><a href="#sec-literal-expression">literal expressions</a></li>
  <li><a href="#sec-parenthesized-expression">parenthesized expressions</a></li>
  <li><a href="#sec-this-expression"><code class="language-dafny highlighter-rouge"><span class="kr">this</span></code> expressions</a></li>
  <li><a href="#sec-fresh-expression">fresh expressions</a></li>
  <li><a href="#sec-allocated-expression">allocated expressions</a></li>
  <li><a href="#sec-unchanged-expression">unchanged expressions</a></li>
  <li><a href="#sec-old-expression">old expressions</a></li>
  <li><a href="#sec-cardinality-expression">cardinality expressions</a></li>
  <li><a href="#sec-assigned-expression">assigned expressions</a></li>
</ul>

<h3 id="sec-literal-expression">9.20. Literal Expressions (<a href="#g-literal-expression">grammar</a>}</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="mi">5</span>
<span class="mf">5.5</span>
<span class="kc">true</span>
<span class="sc">'a'</span>
<span class="s2">"dafny"</span>
</code></pre></div></div>

<p>A literal expression is a null object reference or a boolean,
integer, real, character or string literal.</p>

<h3 id="sec-this-expression">9.21. <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code> Expression (<a href="#g-this-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">this</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">this</span></code> token denotes the current object in the context of 
a constructor, instance method, or instance function.</p>

<h3 id="sec-old-expression">9.22. Old and Old@ Expressions (<a href="#g-old-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">old</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="kr">old</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</code></pre></div></div>

<p>An <em>old expression</em> is used in postconditions or in the body of a method
or in the body or specification of any two-state function or two-state lemma;
an <em>old</em> expression with a label is used only in the body of a method at a point
where the label dominates its use in the expression.</p>

<p><code class="language-dafny highlighter-rouge"><span class="kr">old</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code> evaluates
the argument using the value of the heap on entry to the method;
<code class="language-dafny highlighter-rouge"><span class="kr">old</span><span class="err">@</span><span class="n">ident</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code> evaluates the argument using the value of the heap at the
given statement label.</p>

<p>Note that <strong>old</strong> and <strong>old@</strong> only affect heap dereferences,
like <code class="language-dafny highlighter-rouge"><span class="n">o</span><span class="o">.</span><span class="n">f</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></code>.
In particular, neither form has any effect on the value returned for local
variables or out-parameters (as they are not on the heap).<sup id="fnref:Old" role="doc-noteref"><a href="#fn:Old" class="footnote" rel="footnote">10</a></sup>
If the value of an entire expression at a
particular point in the method body is needed later on in the method body,
the clearest means is to declare a ghost variable, initializing it to the
expression in question.
If the argument of <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> is a local variable or out-parameter. Dafny issues a warning.</p>

<p>The argument of an <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> expression may not contain nested <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code>,
<a href="#sec-fresh-expression"><code class="language-dafny highlighter-rouge"><span class="kr">fresh</span></code></a>,
or <a href="#sec-unchanged-expression"><code class="language-dafny highlighter-rouge"><span class="kr">unchanged</span></code></a> expressions,
nor <a href="#sec-two-state">two-state functions</a> or <a href="#sec-two-state-lemma">two-state lemmas</a>.</p>

<p>Here are some explanatory examples. All <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statements verify to be true.
<!-- %check-verify-warn Expressions.2.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span> <span class="p">{</span>

  <span class="kr">var</span> <span class="n">value</span><span class="o">:</span> <span class="kt">int</span>

  <span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
    <span class="kr">requires</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">6</span>
    <span class="kr">requires</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">42</span>
    <span class="kr">modifies</span> <span class="kr">this</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">17</span><span class="p">;</span>
    <span class="n">value</span> <span class="o">:=</span> <span class="mi">43</span><span class="p">;</span>
    <span class="kr">label</span> <span class="n">L</span><span class="o">:</span>
    <span class="n">j</span> <span class="o">:=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="n">value</span> <span class="o">:=</span> <span class="mi">44</span><span class="p">;</span>
    <span class="kr">label</span> <span class="n">M</span><span class="o">:</span>
    <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// i is local, but can't be changed anyway</span>
    <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">18</span><span class="p">;</span> <span class="c1">// j is local and not affected by old</span>
    <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">18</span><span class="p">;</span> <span class="c1">// j is local and not affected by old</span>
    <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">42</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">43</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">M</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">44</span> <span class="o">&amp;&amp;</span> <span class="kr">this</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">44</span><span class="p">;</span>
    <span class="c1">// value is this.value; 'this' is the same</span>
    <span class="c1">// same reference in current and pre state but the</span>
    <span class="c1">// values stored in the heap as its fields are different;</span>
    <span class="c1">// '.value' evaluates to 42 in the pre-state, 43 at L,</span>
    <span class="c1">// and 44 in the current state</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">value</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">constructor</span> <span class="p">()</span>
     <span class="kr">ensures</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">10</span>
  <span class="p">{</span>
     <span class="n">value</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="n">B</span> <span class="p">{</span>
   <span class="kr">var</span> <span class="n">a</span><span class="o">:</span> <span class="n">A</span>
   <span class="kr">constructor</span> <span class="p">()</span> <span class="p">{</span> <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">A</span><span class="p">();</span> <span class="p">}</span>

   <span class="kr">method</span> <span class="n">m</span><span class="p">()</span>
     <span class="kr">requires</span> <span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">11</span>
     <span class="kr">modifies</span> <span class="kr">this</span><span class="p">,</span> <span class="kr">this</span><span class="o">.</span><span class="n">a</span>
   <span class="p">{</span>
     <span class="kr">label</span> <span class="n">L</span><span class="o">:</span>
     <span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">:=</span> <span class="mi">12</span><span class="p">;</span>
     <span class="kr">label</span> <span class="n">M</span><span class="o">:</span>
     <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">A</span><span class="p">();</span> <span class="c1">// Line X</span>
     <span class="kr">label</span> <span class="n">N</span><span class="o">:</span>
     <span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">:=</span> <span class="mi">20</span><span class="p">;</span>
     <span class="kr">label</span> <span class="n">P</span><span class="o">:</span>

     <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">11</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// this.a is from pre-state,</span>
                                <span class="c1">// but .value in current state</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">11</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// same as above</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// .value in M state is 12</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">12</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">N</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// this.a in N is the heap</span>
                                  <span class="c1">// reference at Line X</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">N</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// .value in current state is 20</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">P</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">P</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">20</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">value</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">constructor</span> <span class="p">()</span>
     <span class="kr">ensures</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">10</span>
  <span class="p">{</span>
     <span class="n">value</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="n">B</span> <span class="p">{</span>
   <span class="kr">var</span> <span class="n">a</span><span class="o">:</span> <span class="n">A</span>
   <span class="kr">constructor</span> <span class="p">()</span> <span class="p">{</span> <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">A</span><span class="p">();</span> <span class="p">}</span>

   <span class="kr">method</span> <span class="n">m</span><span class="p">()</span>
     <span class="kr">requires</span> <span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">11</span>
     <span class="kr">modifies</span> <span class="kr">this</span><span class="p">,</span> <span class="kr">this</span><span class="o">.</span><span class="n">a</span>
   <span class="p">{</span>
     <span class="kr">label</span> <span class="n">L</span><span class="o">:</span>
     <span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">:=</span> <span class="mi">12</span><span class="p">;</span>
     <span class="kr">label</span> <span class="n">M</span><span class="o">:</span>
     <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">A</span><span class="p">();</span> <span class="c1">// Line X</span>
     <span class="kr">label</span> <span class="n">N</span><span class="o">:</span>
     <span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">:=</span> <span class="mi">20</span><span class="p">;</span>
     <span class="kr">label</span> <span class="n">P</span><span class="o">:</span>

     <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">11</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// this.a is from pre-state,</span>
                                <span class="c1">// but .value in current state</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">11</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// same as above</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// .value in M state is 12</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">12</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">N</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// this.a in N is the heap</span>
                                  <span class="c1">// reference at Line X</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">N</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// .value in current state is 20</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">P</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">P</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">20</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The next example demonstrates the interaction between <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> and array elements.
<!-- %check-verify-warn Expressions.3.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">z1</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">nat</span><span class="o">&gt;</span>
  <span class="kr">var</span> <span class="n">z2</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">nat</span><span class="o">&gt;</span>

  <span class="kr">method</span> <span class="n">mm</span><span class="p">()</span>
    <span class="kr">requires</span> <span class="n">z1</span><span class="o">.</span><span class="n">Length</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">z1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">7</span>
    <span class="kr">requires</span> <span class="n">z2</span><span class="o">.</span><span class="n">Length</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">z2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">17</span>
    <span class="kr">modifies</span> <span class="n">z2</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">a</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">nat</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="n">z1</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">:=</span> <span class="n">z2</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">17</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">17</span><span class="p">;</span> <span class="c1">// a is local with value z2</span>
    <span class="n">z2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:=</span> <span class="mi">27</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">17</span><span class="p">;</span> <span class="c1">// a is local, with current value of</span>
                            <span class="c1">// z2; in pre-state z2[0] == 17</span>
    <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">27</span><span class="p">;</span> <span class="c1">// a is local, so old(a) has no effect</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="sec-fresh-expression">9.23. Fresh Expressions (<a href="#g-fresh-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">fresh</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="kr">fresh</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-dafny highlighter-rouge"><span class="kr">fresh</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code> returns a boolean value that is true if
the objects denoted by expression <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> were all
freshly allocated since the time of entry to the enclosing method,
or since <a href="#sec-labeled-statement"><code class="language-dafny highlighter-rouge"><span class="kr">label</span> <span class="n">L</span><span class="o">:</span></code></a> in the variant <code class="language-dafny highlighter-rouge"><span class="kr">fresh</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code>.
The argument is an object or set of objects.
For example, consider this valid program:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span> <span class="p">{</span> <span class="kr">constructor</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span>
<span class="kr">method</span> <span class="n">f</span><span class="p">(</span><span class="n">c1</span><span class="o">:</span> <span class="n">C</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="n">C</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="kr">fresh</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">assert</span> <span class="o">!</span><span class="kr">fresh</span><span class="p">(</span><span class="n">c1</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">c2</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">();</span>
  <span class="kr">label</span> <span class="n">AfterC2</span><span class="o">:</span>
  <span class="kr">var</span> <span class="n">c3</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">();</span>
  <span class="kr">assert</span> <span class="kr">fresh</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">fresh</span><span class="p">(</span><span class="n">c3</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="kr">fresh</span><span class="p">({</span><span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">});</span>
  <span class="kr">assert</span> <span class="o">!</span><span class="kr">fresh</span><span class="err">@</span><span class="n">AfterC2</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">fresh</span><span class="err">@</span><span class="n">AfterC2</span><span class="p">(</span><span class="n">c3</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">:=</span> <span class="n">c2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">L</span></code> in the variant <code class="language-dafny highlighter-rouge"><span class="kr">fresh</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code> must denote a <a href="#sec-labeled-statement">label</a> that, in the
enclosing methods control flow, <a href="#sec-labeled-statement">dominates the expression</a>. In this
case, <code class="language-dafny highlighter-rouge"><span class="kr">fresh</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code> returns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> if the objects denoted by <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> were all
freshly allocated since control flow reached label <code class="language-dafny highlighter-rouge"><span class="n">L</span></code>.</p>

<p>The argument of <code class="language-dafny highlighter-rouge"><span class="kr">fresh</span></code> must be either an <a href="#sec-object-type"><code class="language-dafny highlighter-rouge"><span class="kt">object</span></code></a> reference
or a set or sequence of object references.
In this case, <code class="language-dafny highlighter-rouge"><span class="kr">fresh</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code> (respectively <code class="language-dafny highlighter-rouge"><span class="kr">fresh</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code> with a label)
is a synonym of <a href="#sec-allocated-expression"><code class="language-dafny highlighter-rouge"><span class="kr">old</span><span class="p">(</span><span class="o">!</span><span class="kr">allocated</span><span class="p">(</span><span class="n">e</span><span class="p">))</span></code></a>
(respectively <a href="#sec-allocated-expression"><code class="language-dafny highlighter-rouge"><span class="kr">old</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="o">!</span><span class="kr">allocated</span><span class="p">(</span><span class="n">e</span><span class="p">))</span></code></a>)</p>

<h3 id="sec-allocated-expression">9.24. Allocated Expressions (<a href="#g-allocated-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">allocated</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="kr">allocated</span><span class="p">({</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">})</span>
</code></pre></div></div>

<p>For any expression <code class="language-dafny highlighter-rouge"><span class="n">e</span></code>, the expression <code class="language-dafny highlighter-rouge"><span class="kr">allocated</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code> evaluates to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>
in a state if the value of <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> is available in that state, meaning that
it could in principle have been the value of a variable in that state.</p>

<p>For example, consider this valid program:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">C</span> <span class="p">{</span> <span class="kr">constructor</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span>
<span class="kr">datatype</span> <span class="n">D</span> <span class="o">=</span> <span class="n">Nil</span> <span class="o">|</span> <span class="n">Cons</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="kr">method</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">:=</span> <span class="n">Nil</span><span class="p">,</span> <span class="n">Nil</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">c1</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">();</span>
  <span class="kr">label</span> <span class="n">L1</span><span class="o">:</span>
  <span class="kr">var</span> <span class="n">c2</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">C</span><span class="p">();</span>
  <span class="kr">label</span> <span class="n">L2</span><span class="o">:</span>
  <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">allocated</span><span class="p">(</span><span class="n">d2</span><span class="p">));</span>
  <span class="n">d1</span> <span class="o">:=</span> <span class="n">Cons</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">Nil</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="o">!</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">allocated</span><span class="p">(</span><span class="n">d2</span><span class="p">));</span>
  <span class="n">d2</span> <span class="o">:=</span> <span class="n">Cons</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">Nil</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="o">!</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d2</span><span class="p">));</span>
  <span class="kr">assert</span> <span class="kr">allocated</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">allocated</span><span class="p">(</span><span class="n">d2</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">L1</span><span class="p">(</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d2</span><span class="p">));</span>
  <span class="kr">assert</span> <span class="kr">old</span><span class="err">@</span><span class="n">L2</span><span class="p">(</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="kr">allocated</span><span class="p">(</span><span class="n">d2</span><span class="p">));</span>
  <span class="n">d1</span> <span class="o">:=</span> <span class="n">Nil</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="kr">old</span><span class="p">(</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This can be useful when, for example, <code class="language-dafny highlighter-rouge"><span class="kr">allocated</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code> is evaluated in an
<a href="#sec-old-expression"><code class="language-dafny highlighter-rouge"><span class="kr">old</span></code></a> state. Like in the example, where <code class="language-dafny highlighter-rouge"><span class="n">d1</span></code> is a local variable holding a datatype value
<code class="language-dafny highlighter-rouge"><span class="n">Cons</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">c1</span></code> is an object that was allocated in the enclosing
method, then <a href="#sec-old-expression"><code class="language-dafny highlighter-rouge"><span class="kr">old</span><span class="p">(</span><span class="kr">allocated</span><span class="p">(</span><span class="n">d</span><span class="p">))</span></code></a> is <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>.</p>

<p>If the expression <code class="language-dafny highlighter-rouge"><span class="n">e</span></code> is of a reference type, then <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="kr">old</span><span class="p">(</span><span class="kr">allocated</span><span class="p">(</span><span class="n">e</span><span class="p">))</span></code>
is the same as <a href="#sec-fresh-expression"><code class="language-dafny highlighter-rouge"><span class="kr">fresh</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code></a>.</p>

<h3 id="sec-unchanged-expression">9.25. Unchanged Expressions (<a href="#g-unchanged-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">unchanged</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="kr">unchanged</span><span class="p">([</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">])</span>
<span class="kr">unchanged</span><span class="err">@</span><span class="n">L</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">unchanged</span></code> expression returns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> if and only if every reference
denoted by its arguments has the same value for all its fields in the
old and current state. For example, if <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> is an object with two
fields, <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">y</span></code>, then <code class="language-dafny highlighter-rouge"><span class="kr">unchanged</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></code> is equivalent to
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="kr">old</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="kr">old</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<p>Each argument to <code class="language-dafny highlighter-rouge"><span class="kr">unchanged</span></code> can be a reference, a set of references, or
a sequence of references, each optionally followed by a back-tick and field name. 
This form with a frame field expresses that just the field <code class="language-dafny highlighter-rouge"><span class="n">f</span></code>,
not necessarily all fields, has the same value in the old and current
state.
If there is such a frame field, all the references must have the same type,
which must have a field of that name.</p>

<p>The optional <code class="language-dafny highlighter-rouge"><span class="err">@</span></code>-label says to use the state at that label as the old-state instead of using
the <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> state (the pre-state of the method). That is, using the example <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> from above, the expression
<code class="language-dafny highlighter-rouge"><span class="kr">unchanged</span><span class="err">@</span><span class="n">Lbl</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></code> is equivalent to
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="kr">old</span><span class="err">@</span><span class="n">Lbl</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="kr">old</span><span class="err">@</span><span class="n">Lbl</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<p>Each reference denoted by the arguments of <code class="language-dafny highlighter-rouge"><span class="kr">unchanged</span></code> must be non-null and
must be allocated in the old-state of the expression.</p>

<h3 id="sec-cardinality-expression">9.26. Cardinality Expressions (<a href="#g-cardinality-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="o">|</span><span class="n">s</span><span class="o">|</span>
<span class="o">|</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">i</span><span class="p">]</span><span class="o">|</span>
</code></pre></div></div>

<p>For a finite-collection expression <code class="language-dafny highlighter-rouge"><span class="n">c</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">|</span><span class="n">c</span><span class="o">|</span></code> is the cardinality of <code class="language-dafny highlighter-rouge"><span class="n">c</span></code>. For a
finite set or sequence, the cardinality is the number of elements. For
a multiset, the cardinality is the sum of the multiplicities of the
elements. For a finite map, the cardinality is the cardinality of the
domain of the map. Cardinality is not defined for infinite sets or infinite maps.
For more information, see <a href="#sec-collection-types">Section 5.5</a>.</p>

<h3 id="sec-parenthesized-expression">9.27. Parenthesized Expressions (<a href="#g-parenthesized-expression">grammar</a>)</h3>

<p>A parenthesized expression is a list of zero or more expressions
enclosed in parentheses.</p>

<p>If there is exactly one expression enclosed then the value is just
the value of that expression.</p>

<p>If there are zero or more than one, the result is a <code class="language-dafny highlighter-rouge"><span class="n">tuple</span></code> value.
See <a href="#sec-tuple-types">Section 5.13</a>.</p>

<h3 id="sec-seq-comprehension">9.28. Sequence Display Expression (<a href="#g-sequence-display-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[]</span>
<span class="kt">seq</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>A sequence display expression provides a way to construct
a sequence with given values. For example</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>
<p>is a sequence with three elements in it.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">seq</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>
<p>is a sequence of k elements whose values are obtained by evaluating the
second argument (a function, in this case a lambda expression) on the indices 0 up to k.</p>

<p>See <a href="#sec-sequences">this section</a> for more information on
sequences.</p>

<h3 id="sec-set-display-expression">9.29. Set Display Expression (<a href="#g-set-display-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{}</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="kt">iset</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
<span class="kt">multiset</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="kt">multiset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<p>A set display expression provides a way of constructing a set with given
elements. If the keyword <code class="language-dafny highlighter-rouge"><span class="kt">iset</span></code> is present, then a potentially infinite
set (with the finite set of given elements) is constructed.</p>

<p>For example</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>
<p>is a set with three elements in it.
See <a href="#sec-sets">Section 5.5.1</a> for more information on
sets.</p>

<p>A multiset display expression provides a way of constructing
a multiset with given elements and multiplicities. For example</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">multiset</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>
<p>is a multiset with three elements in it. The number 1 has a multiplicity of 2,
and the numbers 2 and 3 each have a multiplicity of 1.</p>

<p>A multiset cast expression converts a set or a sequence
into a multiset as shown here:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">s</span> <span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="kr">var</span> <span class="n">ms</span> <span class="o">:</span> <span class="kt">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="kt">multiset</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="n">ms</span> <span class="o">:=</span> <span class="n">ms</span> <span class="o">+</span> <span class="kt">multiset</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="kr">var</span> <span class="n">sq</span> <span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kr">var</span> <span class="n">ms2</span> <span class="o">:</span> <span class="kt">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="kt">multiset</span><span class="p">(</span><span class="n">sq</span><span class="p">);</span>
<span class="kr">assert</span> <span class="n">ms</span> <span class="o">==</span> <span class="n">ms2</span><span class="p">;</span>
</code></pre></div></div>

<p>Note that <code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span></code> is a multiset holding the value <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> with multiplicity 2,
but in <code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">})</span></code> the multiplicity is 1, because the expression <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span></code> is the set <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="mi">1</span><span class="p">}</span></code>,
which is then converted to a multiset.</p>

<p>See <a href="#sec-multisets">Section 5.5.2</a> for more information on multisets.</p>

<h3 id="sec-map-display-expression">9.30. Map Display Expression (<a href="#g-map-display-expression">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">map</span><span class="p">[]</span>
<span class="kt">map</span><span class="p">[</span><span class="mi">1</span> <span class="o">:=</span> <span class="s2">"a"</span><span class="p">,</span> <span class="mi">2</span> <span class="o">:=</span> <span class="s2">"b"</span><span class="p">]</span>
<span class="kt">imap</span><span class="p">[</span><span class="mi">1</span> <span class="o">:=</span> <span class="s2">"a"</span><span class="p">,</span> <span class="mi">2</span> <span class="o">:=</span> <span class="s2">"b"</span><span class="p">]</span>
</code></pre></div></div>

<p>A map display expression builds a finite or potentially infinite
map from explicit mappings. For example:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">m</span> <span class="o">:=</span> <span class="kt">map</span><span class="p">[</span><span class="mi">1</span> <span class="o">:=</span> <span class="s2">"a"</span><span class="p">,</span> <span class="mi">2</span> <span class="o">:=</span> <span class="s2">"b"</span><span class="p">]</span>
<span class="kr">ghost</span> <span class="kr">const</span> <span class="n">im</span> <span class="o">:=</span> <span class="kt">imap</span><span class="p">[</span><span class="mi">1</span> <span class="o">:=</span> <span class="s2">"a"</span><span class="p">,</span> <span class="mi">2</span> <span class="o">:=</span> <span class="s2">"b"</span><span class="p">]</span>
</code></pre></div></div>

<p>See <a href="#sec-maps">Section 5.5.4</a> for more details on maps and imaps.</p>

<h3 id="sec-endless-expression">9.31. Endless Expression (<a href="#g-endless-expression">grammar</a>)</h3>

<p><em>Endless expression</em> gets it name from the fact that all its alternate
productions have no terminating symbol to end them, but rather they
all end with an arbitrary expression at the end. The various
endless expression alternatives are described in the following subsections.</p>

<h4 id="sec-if-expression">9.31.1. If Expression (<a href="#g-if-expression">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">if</span> <span class="n">c</span> <span class="kr">then</span> <span class="n">e1</span> <span class="kr">else</span> <span class="n">e2</span>
<span class="kr">if</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="mi">0</span>
</code></pre></div></div>

<p>An <em>if expression</em> is a conditional (ternary) expression. It first evaluates
the condition expression that follows the <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code>. If the condition evaluates to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> then
the expression following the <code class="language-dafny highlighter-rouge"><span class="kr">then</span></code> is evaluated and its value is the
result of the expression. If the condition evaluates to <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> then the
expression following the <code class="language-dafny highlighter-rouge"><span class="kr">else</span></code> is evaluated and that value is the result
of the expression. It is important that only the selected expression
is evaluated as the following example shows.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">k</span> <span class="o">:=</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// error, may divide by 0.</span>
<span class="kr">var</span> <span class="n">m</span> <span class="o">:=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">10</span> <span class="o">/</span> <span class="n">x</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// ok, guarded</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> expression also permits a binding form.
In this case the condition of the <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> is an existential asking
does there exist a value satisfying the given predicate?.
If not, the else branch is evaluated. But if so, then an
(arbitrary) value that does satisfy the given predicate is
bound to the given variable and that variable is in scope in 
the then-branch of the expression.</p>

<p>For example, in the code
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">5</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="kr">var</span> <span class="n">y</span> <span class="o">:=</span> <span class="kr">if</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is given some value that satisfies <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>, namely either <code class="language-dafny highlighter-rouge"><span class="mi">5</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="mi">5</span></code>.
That value of <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is the value of the expression in the <code class="language-dafny highlighter-rouge"><span class="kr">then</span></code> branch above; if there is no value satisfying <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>,
then <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> is returned. Note that if <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is declared to be a <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> in this example, then only
the value <code class="language-dafny highlighter-rouge"><span class="mi">5</span></code> would be permissible.</p>

<p>This binding form of the <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> expression acts in the same way as the binding form of the <a href="#sec-if-statement"><code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> statement</a>.</p>

<p>In the example given, the binder for <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> has no constraining range, so the expression is <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code>;
if a range is given, such as <code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">y</span> <span class="o">:=</span> <span class="kr">if</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">;</span></code>,
then the <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">y</span></code> are no longer ghost, and <code class="language-dafny highlighter-rouge"><span class="n">y</span></code> could be used, for example, in a <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statement.</p>

<h4 id="sec-case-pattern">9.31.2. Case and Extended Patterns (<a href="#g-pattern">grammar</a>)</h4>

<p>Patterns are used for (possibly nested)
pattern matching on inductive, coinductive or base type values.
They are used in 
<a href="#sec-match-statement">match statements</a>,
<a href="#sec-match-expression">match expressions</a>,
<a href="#sec-let-expression">let expressions</a>,
and <a href="#sec-variable-declaration-statement">variable declarations</a>.
The match expressions and statements allow literals,
symbolic constants, and disjunctive (or) patterns.</p>

<p>When matching an inductive or coinductive value in
a match statement or expression, the pattern
must correspond to one of the following:</p>

<ul>
  <li>(0) a case disjunction (or-pattern)</li>
  <li>(1) bound variable (a simple identifier),</li>
  <li>(2) a constructor of the type of the value,</li>
  <li>(3) a literal of the correct type, or</li>
  <li>(4) a symbolic constant.</li>
</ul>

<p>If the extended pattern is</p>

<ul>
  <li>a sequence of <code class="language-dafny highlighter-rouge"><span class="o">|</span></code>-separated sub-patterns, then the pattern matches values
matched by any of the sub-patterns.</li>
  <li>a parentheses-enclosed possibly-empty list of patterns,
then the pattern matches a tuple.</li>
  <li>an identifier followed
by a parentheses-enclosed possibly-empty list of patterns, then the pattern
matches a constructor.</li>
  <li>a literal, then the pattern matches exactly that literal.</li>
  <li>a simple identifier, then the pattern matches
    <ul>
      <li>a parameter-less constructor if there is one defined with the correct type and the given name, else</li>
      <li>the value of a symbolic constant, if a name lookup finds a declaration for
a constant with the given name (if the name is declared but with a non-matching type, a type resolution error will occur),</li>
      <li>otherwise, the identifier is a new bound variable</li>
    </ul>
  </li>
</ul>

<p>Disjunctive patterns may not bind variables, and may not be nested inside other
patterns.</p>

<p>Any patterns inside the parentheses of a constructor (or tuple) pattern are then
matched against the arguments that were given to the
constructor when the value was constructed.
The number of patterns must match the number
of parameters to the constructor (or the arity of the
tuple).</p>

<p>When matching a value of base type, the pattern should
either be a literal expression of the same type as the value,
or a single identifier matching all values of this type.</p>

<p>Patterns may be nested. The  bound variable
identifiers contained in all the patterns must be distinct.
They are bound to the corresponding values in the value being
matched. (Thus, for example, one cannot repeat a bound variable to
attempt to match a constructor that has two identical arguments.)</p>

<h4 id="sec-match-expression">9.31.3. Match Expression (<a href="#g-match-expression">grammar</a>)</h4>

<p>A <em>match expression</em> is used to conditionally evaluate and select an
expression depending on the value of an algebraic type, i.e. an inductive
type, a coinductive type, or a base type.</p>

<p>All of the variables in the patterns must be distinct.
If types for the identifiers are not given then types are inferred
from the types of the constructors parameters. If types are
given then they must agree with the types of the
corresponding parameters.</p>

<p>The expression following the <code class="language-dafny highlighter-rouge"><span class="kr">match</span></code> keyword is called the
<em>selector</em>. A match expression is evaluated by first evaluating the selector.
The patterns of each match alternative are then compared, in order,
 with the resulting value until a matching pattern is found, as described in
the <a href="#sec-case-pattern">section on case bindings</a>.
If the constructor had
parameters, then the actual values used to construct the selector
value are bound to the identifiers in the identifier list.
The expression to the right of the <code class="language-dafny highlighter-rouge"><span class="o">=&gt;</span></code> in the matched alternative is then
evaluated in the environment enriched by this binding. The result
of that evaluation is the result of the match expression.</p>

<p>Note that the braces enclosing the sequence of match alternatives may be omitted.
Those braces are required if lemma or lambda expressions are used in the
body of any match alternative; they may also be needed for disambiguation if
there are nested match expressions.</p>

<h4 id="sec-quantifier-expression">9.31.4. Quantifier Expression (<a href="#g-quantifier-expression">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="kr">forall</span> <span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">::</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span>
<span class="kr">exists</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">25</span>
</code></pre></div></div>

<p>A <em>quantifier expression</em> is a boolean expression that specifies that a
given expression (the one following the <code class="language-dafny highlighter-rouge"><span class="o">::</span></code>) is true for all (for
<strong>forall</strong>) or some (for <strong>exists</strong>) combination of values of the
quantified variables, namely those in the given quantifier domain.
See <a href="#sec-quantifier-domains">Section 2.7.4</a> for more details on quantifier domains.</p>

<p>Here are some examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">;</span>
<span class="p">(</span><span class="kr">forall</span> <span class="n">n</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">==&gt;</span> <span class="p">(</span><span class="kr">exists</span> <span class="n">d</span> <span class="o">::</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">))</span>
<span class="kr">assert</span> <span class="kr">forall</span> <span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">::</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span>
</code></pre></div></div>

<p>The quantifier identifiers are <em>bound</em> within the scope of the
expressions in the quantifier expression.</p>

<p>If types are not given for the quantified identifiers, then Dafny
attempts to infer their types from the context of the expressions.
It this is not possible, the program is in error.</p>

<h4 id="sec-set-comprehension-expression">9.31.5. Set Comprehension Expressions (<a href="#g-set-comprehension-expression">grammar</a>)</h4>

<p>Examples:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">c1</span> <span class="o">:=</span> <span class="kt">set</span> <span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span>
<span class="kr">const</span> <span class="n">c2</span> <span class="o">:=</span> <span class="kt">set</span> <span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="kr">const</span> <span class="n">c3</span> <span class="o">:=</span> <span class="kt">set</span> <span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="kr">ghost</span> <span class="kr">const</span> <span class="n">c4</span> <span class="o">:=</span> <span class="kt">iset</span> <span class="n">x</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span>
<span class="kr">ghost</span> <span class="kr">const</span> <span class="n">c5</span><span class="o">:</span> <span class="kt">iset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="kt">iset</span> <span class="n">s</span>
<span class="kr">const</span> <span class="n">c6</span> <span class="o">:=</span> <span class="kt">set</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">c3</span> <span class="o">::</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>A set comprehension expression is an expression that yields a set
(possibly infinite only if <code class="language-dafny highlighter-rouge"><span class="kt">iset</span></code> is used) that
satisfies specified conditions. There are two basic forms.</p>

<p>If there is only one quantified variable, the optional <code class="language-dafny highlighter-rouge"><span class="s2">"::"</span> <span class="n">Expression</span></code>
need not be supplied, in which case it is as if it had been supplied
and the expression consists solely of the quantified variable.
That is,</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">set</span> <span class="n">x</span> <span class="o">:</span> <span class="n">T</span> <span class="o">|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>is equivalent to</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">set</span> <span class="n">x</span> <span class="o">:</span> <span class="n">T</span> <span class="o">|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">::</span> <span class="n">x</span>
</code></pre></div></div>

<p>For the full form</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">S</span> <span class="o">:=</span> <span class="kt">set</span> <span class="n">x1</span><span class="o">:</span> <span class="n">T1</span> <span class="o">&lt;-</span> <span class="n">C1</span> <span class="o">|</span> <span class="n">P1</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span>
             <span class="n">x2</span><span class="o">:</span> <span class="n">T2</span> <span class="o">&lt;-</span> <span class="n">C2</span> <span class="o">|</span> <span class="n">P2</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span>
             <span class="o">...</span> 
             <span class="o">::</span> <span class="n">Q</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div></div>

<p>the elements of <code class="language-dafny highlighter-rouge"><span class="n">S</span></code> will be all values resulting from evaluation of <code class="language-dafny highlighter-rouge"><span class="n">Q</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span></code>
for all combinations of quantified variables <code class="language-dafny highlighter-rouge"><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">...</span></code> (from their respective <code class="language-dafny highlighter-rouge"><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="o">...</span></code>
domains) such that all predicates <code class="language-dafny highlighter-rouge"><span class="n">P1</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">P2</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="o">...</span></code> hold.</p>

<p>For example,</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">S</span> <span class="o">:=</span> <span class="kt">set</span> <span class="n">x</span><span class="o">:</span><span class="kt">nat</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span><span class="kt">nat</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">::</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div>
<p>yields <code class="language-dafny highlighter-rouge"><span class="n">S</span> <span class="o">==</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">}</span></code></p>

<p>The types on the quantified variables are optional and if not given Dafny
will attempt to infer them from the contexts in which they are used in the
various expressions. The <code class="language-dafny highlighter-rouge"><span class="o">&lt;-</span> <span class="n">C</span></code> domain expressions are also optional and default to
<code class="language-dafny highlighter-rouge"><span class="kt">iset</span> <span class="n">x</span><span class="o">:</span> <span class="n">T</span></code> (i.e. all values of the variables type), as are the <code class="language-dafny highlighter-rouge"><span class="o">|</span> <span class="n">P</span></code> expressions which
default to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>. See also <a href="#sec-quantifier-domains">Section 2.7.4</a> for more details on quantifier domains.</p>

<p>If a finite set was specified (set keyword used), Dafny must be able to prove that the
result is finite otherwise the set comprehension expression will not be
accepted.</p>

<p>Set comprehensions involving reference types such as</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">set</span> <span class="n">o</span><span class="o">:</span> <span class="kt">object</span>
</code></pre></div></div>

<p>are allowed in ghost expressions within methods, but not in ghost functions<sup id="fnref:set-of-objects-not-in-functions" role="doc-noteref"><a href="#fn:set-of-objects-not-in-functions" class="footnote" rel="footnote">11</a></sup>.
In particular, in ghost contexts, the
check that the result is finite should allow any set comprehension
where the bound variable is of a reference type. In non-ghost contexts,
it is not allowed, becauseeven though the resulting set would be
finiteit is not pleasant or practical to compute at run time.</p>

<p>The universe in which set comprehensions are evaluated is the set of all
<em>allocated</em> objects, of the appropriate type and satisfying the given predicate.
For example, given</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">class</span> <span class="n">I</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">m</span> <span class="o">:=</span> <span class="kt">set</span> <span class="n">x</span><span class="o">:</span> <span class="n">I</span> <span class="o">::</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>the set <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> contains only those instances of <code class="language-dafny highlighter-rouge"><span class="n">I</span></code> that have been allocated
at the point in program execution that <code class="language-dafny highlighter-rouge"><span class="n">test</span></code> is evaluated. This could be
no instances, one per value of <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">.</span><span class="n">i</span></code> in the stated range, multiple instances
of <code class="language-dafny highlighter-rouge"><span class="n">I</span></code> for each value of <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">.</span><span class="n">i</span></code>, or any other combination.</p>

<h4 id="sec-statement-in-an-expression">9.31.6. Statements in an Expression (<a href="#g-statement-in-expression">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">assert</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">10</span><span class="o">/</span><span class="n">x</span>
<span class="kr">assert</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="kr">assert</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span><span class="o">/</span><span class="n">x</span>
<span class="kr">assume</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">10</span><span class="o">/</span><span class="n">x</span>
<span class="kr">expect</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">10</span><span class="o">/</span><span class="n">x</span>
<span class="kr">reveal</span> <span class="n">M</span><span class="o">.</span><span class="n">f</span><span class="p">;</span> <span class="n">M</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="kr">calc</span> <span class="p">{</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">0</span><span class="p">;</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="n">x</span><span class="o">/</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">StmtInExpr</span></code> is a kind of statement that is allowed to
precede an expression in order to ensure that the expression
can be evaluated without error. For example:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">assume</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">10</span><span class="o">/</span><span class="n">x</span>
</code></pre></div></div>

<p><code class="language-dafny highlighter-rouge"><span class="n">Assert</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> statements can be used in this way.</p>

<h4 id="sec-let-expression">9.31.7. Let and Let or Fail Expression (<a href="#g-let-expression">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="kr">var</span> <span class="n">x</span> <span class="o">:-</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="kr">var</span> <span class="n">x</span> <span class="o">:|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="kr">var</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">:=</span> <span class="n">T</span><span class="p">();</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>   <span class="c1">// T returns a tuple</span>
<span class="kr">var</span> <span class="n">R</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">:=</span> <span class="n">T</span><span class="p">();</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>   <span class="c1">// T returns a datatype value R</span>
</code></pre></div></div>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">let</span></code> expression allows binding of intermediate values to identifiers
for use in an expression. The start of the <code class="language-dafny highlighter-rouge"><span class="n">let</span></code> expression is
signaled by the <code class="language-dafny highlighter-rouge"><span class="kr">var</span></code> keyword. They look much like a local variable
declaration except the scope of the variable only extends to the
enclosed expression.</p>

<p>For example:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">sum</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">sum</span>
</code></pre></div></div>

<p>In the simple case, the pattern is just an identifier with optional
type (which if missing is inferred from the rhs).</p>

<p>The more complex case allows destructuring of constructor expressions.
For example:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Stuff</span> <span class="o">=</span> <span class="n">SCons</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">|</span> <span class="n">Other</span>
<span class="kr">function</span> <span class="n">GhostF</span><span class="p">(</span><span class="n">z</span><span class="o">:</span> <span class="n">Stuff</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">requires</span> <span class="n">z</span><span class="o">.</span><span class="n">SCons?</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">SCons</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">:=</span> <span class="n">z</span><span class="p">;</span> <span class="kr">var</span> <span class="n">sum</span> <span class="o">:=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">;</span> <span class="n">sum</span> <span class="o">*</span> <span class="n">sum</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The Let expression has a failure variant
that simply uses <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> instead of <code class="language-dafny highlighter-rouge"><span class="o">:=</span></code>. This Let-or-Fail expression also permits propagating
failure results. However, in statements (<a href="#sec-update-with-failure-statement">Section 8.6</a>), failure results in
immediate return from the method; expressions do not have side effects or immediate return
mechanisms. Rather, if the expression to the right of <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> results in a failure value <code class="language-dafny highlighter-rouge"><span class="n">V</span></code>,
the overall expression returns <code class="language-dafny highlighter-rouge"><span class="n">V</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">()</span></code>; if there is no failure, the expression following the 
semicolon is returned. Note that these two possible return values must have the same type (or be 
implicitly convertible to the same type). Typically that means that <code class="language-dafny highlighter-rouge"><span class="n">tmp</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">()</span></code> is a failure value and
<code class="language-dafny highlighter-rouge"><span class="n">E</span></code> is a value-carrying success value, both of the same failure-compatible type, 
as described in <a href="#sec-update-with-failure-statement">Section 8.6</a>.</p>

<p>The expression <code class="language-dafny highlighter-rouge"><span class="o">:-</span> <span class="n">V</span><span class="p">;</span> <span class="n">E</span></code> is desugared into the <em>expression</em>
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">tmp</span> <span class="o">:=</span> <span class="n">V</span><span class="p">;</span>
<span class="kr">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span>
<span class="kr">then</span> <span class="n">tmp</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">()</span>
<span class="kr">else</span> <span class="n">E</span>
</code></pre></div></div>

<p>The expression <code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">v</span> <span class="o">:-</span> <span class="n">V</span><span class="p">;</span> <span class="n">E</span></code> is desugared into the <em>expression</em>
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">tmp</span> <span class="o">:=</span> <span class="n">V</span><span class="p">;</span>
<span class="kr">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span>
<span class="kr">then</span> <span class="n">tmp</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">()</span>
<span class="kr">else</span> <span class="kr">var</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">Extract</span><span class="p">();</span> <span class="n">E</span>
</code></pre></div></div>

<p>If the RHS is a list of expressions then the desugaring is similar. <code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">v</span><span class="p">,</span> <span class="n">v1</span> <span class="o">:-</span> <span class="n">V</span><span class="p">,</span> <span class="n">V1</span><span class="p">;</span> <span class="n">E</span></code> becomes
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">tmp</span> <span class="o">:=</span> <span class="n">V</span><span class="p">;</span>
<span class="kr">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">IsFailure</span><span class="p">()</span>
<span class="kr">then</span> <span class="n">tmp</span><span class="o">.</span><span class="n">PropagateFailure</span><span class="p">()</span>
<span class="kr">else</span> <span class="kr">var</span> <span class="n">v</span><span class="p">,</span> <span class="n">v1</span> <span class="o">:=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">Extract</span><span class="p">(),</span> <span class="n">V1</span><span class="p">;</span> <span class="n">E</span>
</code></pre></div></div>

<p>So, if tmp is a failure value, then a corresponding failure value is propagated along; otherwise, the expression
is evaluated as normal.</p>

<h4 id="sec-map-comprehension-expression">9.31.8. Map Comprehension Expression (<a href="#g-map-comprehension-expression">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kt">map</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">map</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="o">::</span> <span class="o">-</span><span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">imap</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">10</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
</code></pre></div></div>

<p>A <em>map comprehension expression</em>  defines a finite or infinite map value
by defining a domain and for each value in the domain,
giving the mapped value using the expression following the ::.
See <a href="#sec-quantifier-domains">Section 2.7.4</a> for more details on quantifier domains.</p>

<p>For example:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">{</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="p">}</span>
<span class="kr">method</span> <span class="n">test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">m</span> <span class="o">:=</span> <span class="kt">map</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">im</span> <span class="o">:=</span> <span class="kt">imap</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
  <span class="kr">ghost</span> <span class="kr">var</span> <span class="n">im2</span> <span class="o">:=</span> <span class="kt">imap</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">::</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dafny finite maps must be finite, so the domain must be constrained to be finite.
But imaps may be infinite as the examples show. The last example shows
creation of an infinite map that gives the same results as a function.</p>

<p>If the expression includes the <code class="language-dafny highlighter-rouge"><span class="o">:=</span></code> token, that token separates
domain values from range values. For example, in the following code
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">m</span> <span class="o">:=</span> <span class="kt">map</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="o">::</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-dafny highlighter-rouge"><span class="n">m</span></code> maps <code class="language-dafny highlighter-rouge"><span class="mi">2</span></code> to <code class="language-dafny highlighter-rouge"><span class="mi">3</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">4</span></code> to <code class="language-dafny highlighter-rouge"><span class="mi">6</span></code>, and so on.</p>

<h3 id="sec-name-segment">9.32. Name Segment (<a href="#g-name-segment">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">I</span>
<span class="n">I</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span>
<span class="n">I</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
<span class="n">I</span><span class="err">#</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</code></pre></div></div>

<p>A <em>name segment</em> names a Dafny entity by giving its declared
name optionally followed by information to
make the name more complete. For the simple case, it is
just an identifier. Note that a name segment may be followed
by <a href="#sec-suffix">suffixes</a>, including the common . and further name segments.</p>

<p>If the identifier is for a generic entity, it is followed by
a <code class="language-dafny highlighter-rouge"><span class="n">GenericInstantiation</span></code> which provides actual types for
the type parameters.</p>

<p>To reference a prefix predicate (see <a href="#sec-copredicates">Section 5.14.3.5</a>) or
prefix lemma (see <a href="#sec-prefix-lemmas">Section 5.14.3.6.3</a>), the identifier
must be the name of the greatest predicate or greatest lemma and it must be
followed by a <a href="#sec-hash-call"><em>hash call</em></a>.</p>

<h3 id="sec-hash-call">9.33. Hash call (<a href="#g-hash-call">grammar</a>)</h3>

<p>A <em>hash call</em>  is used to call the prefix for a greatest predicate or greatest lemma.
In the non-generic case, just insert <code class="language-dafny highlighter-rouge"><span class="s2">"#[k]"</span></code> before the call argument
list where k is the number of recursion levels.</p>

<p>In the case where the <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span> <span class="kr">lemma</span></code> is generic, the generic type
argument is given before. Here is an example:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">codatatype</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Nil</span> <span class="o">|</span> <span class="n">Cons</span><span class="p">(</span><span class="n">head</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">stuff</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span>
                                  <span class="n">tail</span><span class="o">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>

<span class="kr">function</span> <span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="o">:</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">N</span><span class="o">:</span> <span class="n">Stream</span><span class="p">)</span><span class="o">:</span> <span class="n">Stream</span>
<span class="p">{</span>
  <span class="kr">match</span> <span class="n">M</span>
  <span class="kr">case</span> <span class="n">Nil</span> <span class="o">=&gt;</span> <span class="n">N</span>
  <span class="kr">case</span> <span class="n">Cons</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">M'</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">Cons</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">append</span><span class="p">(</span><span class="n">M'</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
<span class="p">}</span>

<span class="kr">function</span> <span class="n">zeros</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">T</span><span class="p">)</span><span class="o">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">Cons</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="p">}</span>

<span class="kr">function</span> <span class="n">ones</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span><span class="o">:</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ones</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="p">}</span>

<span class="kr">greatest</span> <span class="kr">predicate</span> <span class="n">atmost</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="n">Stream</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">match</span> <span class="n">a</span>
  <span class="kr">case</span> <span class="n">Nil</span> <span class="o">=&gt;</span> <span class="kc">true</span>
  <span class="kr">case</span> <span class="n">Cons</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">Cons?</span> <span class="o">&amp;&amp;</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="o">.</span><span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">atmost</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">tail</span><span class="p">)</span>
<span class="p">}</span>

<span class="kr">greatest</span> <span class="kr">lemma</span> <span class="p">{</span><span class="o">:</span><span class="n">induction</span> <span class="kc">false</span><span class="p">}</span> <span class="n">Theorem0</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">atmost</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">ones</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="p">{</span>
  <span class="c1">// the following shows two equivalent ways to state the</span>
  <span class="c1">// coinductive hypothesis</span>
  <span class="kr">if</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Theorem0</span><span class="err">#</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">s</span><span class="p">);</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="n">Theorem0</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where the <code class="language-dafny highlighter-rouge"><span class="n">HashCall</span></code> is <code class="language-dafny highlighter-rouge"><span class="s2">"Theorem0#&lt;T&gt;[_k-1](s);"</span></code>.
See <a href="#sec-copredicates">Section 5.14.3.5</a> and <a href="#sec-prefix-lemmas">Section 5.14.3.6.3</a>.</p>

<h3 id="sec-suffix">9.34. Suffix (<a href="#g-suffix">grammar</a>)</h3>

<p>A <em>suffix</em> describes ways of deriving a new value from
the entity to which the suffix is appended. The several kinds
of suffixes are described below.</p>

<h4 id="sec-augmented-dot-suffix">9.34.1. Augmented Dot Suffix (<a href="#g-augmented-dot-suffix">grammar</a>)</h4>

<p>Examples: (expression with suffix)
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="o">.</span><span class="n">b</span>
<span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">b</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="n">a</span><span class="o">.</span><span class="n">b</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
<span class="n">a</span><span class="o">.</span><span class="n">b</span><span class="err">#</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</code></pre></div></div>

<p>An augmented dot suffix consists of a simple <a href="#sec-identifier-variations">dot suffix</a> optionally
followed by either</p>

<ul>
  <li>a <code class="language-dafny highlighter-rouge"><span class="n">GenericInstantiation</span></code> (for the case where the item
selected by the <code class="language-dafny highlighter-rouge"><span class="n">DotSuffix</span></code> is generic), or</li>
  <li>a <code class="language-dafny highlighter-rouge"><span class="n">HashCall</span></code> for the case where we want to call a prefix predicate
or prefix lemma. The result is the result of calling the prefix predicate
or prefix lemma.</li>
</ul>

<h4 id="sec-datatype-update-suffix">9.34.2. Datatype Update Suffix (<a href="#g-datatype-update-suffix">grammar</a>)</h4>

<p>Examples: (expression with suffix)
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="n">f</span> <span class="o">:=</span> <span class="n">e1</span><span class="p">,</span> <span class="n">g</span><span class="o">:=</span> <span class="n">e2</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span> <span class="o">:=</span> <span class="n">e1</span><span class="p">)</span>
<span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">f</span> <span class="o">:=</span> <span class="n">e1</span><span class="p">,</span> <span class="n">g</span><span class="o">:=</span> <span class="n">e2</span><span class="p">)</span>
</code></pre></div></div>

<p>A <em>datatype update suffix</em> is used to produce a new datatype value
that is the same as an old datatype value except that the
value corresponding to a given destructor has the specified value.
In a <em>member binding update</em>, the given identifier (or digit sequence) is the
name of a destructor (i.e. the formal parameter name) for one of the
constructors of the datatype. The expression to the right of the
<code class="language-dafny highlighter-rouge"><span class="o">:=</span></code> is the new value for that formal.</p>

<p>All of the destructors in a datatype update suffix must be
for the same constructor, and if they do not cover all of the
destructors for that constructor then the datatype value being
updated must have a value derived from that same constructor.</p>

<p>Here is an example:</p>

<!-- %check-verify Expressions.4.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">NewSyntax</span> <span class="p">{</span>
  <span class="kr">datatype</span> <span class="n">MyDataType</span> <span class="o">=</span> <span class="n">MyConstructor</span><span class="p">(</span><span class="n">myint</span><span class="o">:</span><span class="kt">int</span><span class="p">,</span> <span class="n">mybool</span><span class="o">:</span><span class="kt">bool</span><span class="p">)</span>
                    <span class="o">|</span> <span class="n">MyOtherConstructor</span><span class="p">(</span><span class="n">otherbool</span><span class="o">:</span><span class="kt">bool</span><span class="p">)</span>
                    <span class="o">|</span> <span class="n">MyNumericConstructor</span><span class="p">(</span><span class="mi">42</span><span class="o">:</span><span class="kt">int</span><span class="p">)</span>

  <span class="kr">method</span> <span class="n">test</span><span class="p">(</span><span class="n">datum</span><span class="o">:</span><span class="n">MyDataType</span><span class="p">,</span> <span class="n">x</span><span class="o">:</span><span class="kt">int</span><span class="p">)</span>
    <span class="kr">returns</span> <span class="p">(</span><span class="n">abc</span><span class="o">:</span><span class="n">MyDataType</span><span class="p">,</span> <span class="n">def</span><span class="o">:</span><span class="n">MyDataType</span><span class="p">,</span>
             <span class="n">ghi</span><span class="o">:</span><span class="n">MyDataType</span><span class="p">,</span> <span class="n">jkl</span><span class="o">:</span><span class="n">MyDataType</span><span class="p">)</span>
    <span class="kr">requires</span> <span class="n">datum</span><span class="o">.</span><span class="n">MyConstructor?</span>
    <span class="kr">ensures</span> <span class="n">abc</span> <span class="o">==</span> <span class="n">datum</span><span class="o">.</span><span class="p">(</span><span class="n">myint</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="kr">ensures</span> <span class="n">def</span> <span class="o">==</span> <span class="n">datum</span><span class="o">.</span><span class="p">(</span><span class="n">otherbool</span> <span class="o">:=</span> <span class="o">!</span><span class="n">datum</span><span class="o">.</span><span class="n">mybool</span><span class="p">)</span>  <span class="c1">// error</span>
    <span class="kr">ensures</span> <span class="n">ghi</span> <span class="o">==</span> <span class="n">datum</span><span class="o">.</span><span class="p">(</span><span class="n">myint</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">mybool</span> <span class="o">:=</span> <span class="kc">false</span><span class="p">)</span>
    <span class="c1">// Resolution error: no non_destructor in MyDataType</span>
    <span class="c1">//ensures jkl == datum.(non_destructor := 5) // error</span>
    <span class="kr">ensures</span> <span class="n">jkl</span> <span class="o">==</span> <span class="n">datum</span><span class="o">.</span><span class="p">(</span><span class="mi">42</span> <span class="o">:=</span> <span class="mi">7</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">abc</span> <span class="o">:=</span> <span class="n">MyConstructor</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">datum</span><span class="o">.</span><span class="n">mybool</span><span class="p">);</span>
    <span class="n">abc</span> <span class="o">:=</span> <span class="n">datum</span><span class="o">.</span><span class="p">(</span><span class="n">myint</span> <span class="o">:=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">def</span> <span class="o">:=</span> <span class="n">MyOtherConstructor</span><span class="p">(</span><span class="o">!</span><span class="n">datum</span><span class="o">.</span><span class="n">mybool</span><span class="p">);</span>
    <span class="n">ghi</span> <span class="o">:=</span> <span class="n">MyConstructor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
    <span class="n">jkl</span> <span class="o">:=</span> <span class="n">datum</span><span class="o">.</span><span class="p">(</span><span class="mi">42</span> <span class="o">:=</span> <span class="mi">7</span><span class="p">);</span> <span class="c1">// error</span>

    <span class="kr">assert</span> <span class="n">abc</span><span class="o">.</span><span class="p">(</span><span class="n">myint</span> <span class="o">:=</span> <span class="n">abc</span><span class="o">.</span><span class="n">myint</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">datum</span><span class="o">.</span><span class="p">(</span><span class="n">myint</span> <span class="o">:=</span> <span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="sec-subsequence-suffix">9.34.3. Subsequence Suffix (<a href="#g-subsequence-suffix">grammar</a>)</h4>

<p>Examples: (with leading expression)
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="p">[</span><span class="n">lo</span> <span class="o">..</span> <span class="n">hi</span> <span class="p">]</span>
<span class="p">(</span><span class="n">e</span><span class="p">)[</span> <span class="n">lo</span> <span class="o">..</span> <span class="p">]</span>
<span class="n">e</span><span class="p">[</span> <span class="o">..</span> <span class="n">hi</span> <span class="p">]</span>
<span class="n">e</span><span class="p">[</span> <span class="o">..</span> <span class="p">]</span>
</code></pre></div></div>

<p>A subsequence suffix applied to a sequence produces a new sequence whose
elements are taken from a contiguous part of the original sequence. For
example, expression <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">hi</span><span class="p">]</span></code> for sequence <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>, and integer-based
numeric bounds <code class="language-dafny highlighter-rouge"><span class="n">lo</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">hi</span></code> satisfying <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span> <span class="o">&lt;=</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span></code>. See
<a href="#sec-other-sequence-expressions">the section about other sequence expressions</a> for details.</p>

<p>A subsequence suffix applied to an array produces a <em>sequence</em> consisting of 
the values of the designated elements. A concise way of converting a whole 
array to a sequence is to write <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="p">]</span></code>.</p>

<h4 id="sec-subsequence-slices-suffix">9.34.4. Subsequence Slices Suffix (<a href="#g-subsequence-slices-suffix">grammar</a>)</h4>

<p>Examples: (with leading expression)
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="p">[</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">3</span> <span class="p">]</span>
<span class="n">a</span><span class="p">[</span> <span class="n">e1</span> <span class="o">:</span> <span class="n">e2</span> <span class="o">:</span> <span class="n">e3</span> <span class="p">]</span>
<span class="n">a</span><span class="p">[</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">2</span> <span class="o">:</span> <span class="p">]</span>
</code></pre></div></div>

<p>Applying a <em>subsequence slices suffix</em> to a sequence produces a
sequence of subsequences of the original sequence.
See <a href="#sec-other-sequence-expressions">the section about other sequence expressions</a> for details.</p>

<h4 id="sec-sequence-update-suffix">9.34.5. Sequence Update Suffix (<a href="#g-sequence-update-suffix">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">s</span><span class="p">[</span><span class="mi">1</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="o">:=</span> <span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>For a sequence <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> and expressions <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">v</span></code>, the expression
<code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">:=</span> <span class="n">v</span><span class="p">]</span></code> is the same as the sequence <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> except that at
index <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> it has value <code class="language-dafny highlighter-rouge"><span class="n">v</span></code>.</p>

<p>If the type of <code class="language-dafny highlighter-rouge"><span class="n">s</span></code> is <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code>, then <code class="language-dafny highlighter-rouge"><span class="n">v</span></code> must have type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code>.
The index <code class="language-dafny highlighter-rouge"><span class="n">i</span></code> can have any integer- or bit-vector-based type
(this is one situation in which Dafny implements implicit
conversion, as if an <code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="kt">int</span></code> were appended to the index expression).
The expression <code class="language-dafny highlighter-rouge"><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">:=</span> <span class="n">v</span><span class="p">]</span></code> has the same type as <code class="language-dafny highlighter-rouge"><span class="n">s</span></code>.</p>

<h4 id="sec-selection-suffix">9.34.6. Selection Suffix (<a href="#g-selection-suffix">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">j</span><span class="o">.</span><span class="n">k</span><span class="p">]</span>
</code></pre></div></div>

<p>If a selection suffix  has only one expression in it, it is a
zero-based index that may be used to select a single element of a
sequence or from a single-dimensional array.</p>

<p>If a selection suffix has more than one expression in it, then
it is a list of indices to index into a multi-dimensional array.
The rank of the array must be the same as the number of indices.</p>

<p>If the selection suffix is used with an array or a sequence,
then each index expression can have any integer- or bit-vector-based
type
(this is one situation in which Dafny implements implicit
conversion, as if an <code class="language-dafny highlighter-rouge"><span class="ow">as</span> <span class="kt">int</span></code> were appended to the index expression).</p>

<h4 id="sec-argument-list-suffix">9.34.7. Argument List Suffix (<a href="#g-argument-list-suffix">grammar</a>)</h4>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">()</span>
<span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>
<p>An argument list suffix is a parenthesized list of expressions that
are the arguments to pass to a method or function that is being
called. Applying such a suffix causes the method or function
to be called and the result is the result of the call.</p>

<p>Note that method calls may only appear in <a href="#sec-rhs-expression">right-hand-side</a>
locations, whereas function calls may appear in expressions and specifications;
this distinction can be made only during name and type resolution, not by the
parser.</p>

<h3 id="sec-expression-list">9.35. Expression Lists (<a href="#g-expression-list">grammar</a>)</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>                <span class="c1">// empty list</span>
<span class="n">a</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span>
</code></pre></div></div>

<p>An expression list is a comma-separated sequence of expressions, used, for example,
as actual araguments in a method or function call or in parallel assignment.</p>

<h3 id="sec-parameter-bindings">9.36. Parameter Bindings (<a href="#g-parameter-bindings">grammar</a>)</h3>

<p>Examples: 
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">a</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="n">a</span><span class="p">,</span> <span class="n">optimize</span> <span class="o">:=</span> <span class="n">b</span>
</code></pre></div></div>

<p>Method calls, object-allocation calls (<code class="language-dafny highlighter-rouge"><span class="kr">new</span></code>), function calls, and
datatype constructors can be called with both positional arguments
and named arguments.</p>

<p>Formal parameters have three ways to indicate how they are to be passed in:</p>
<ul>
  <li>nameonly: the only way to give a specific argument value is to name the parameter</li>
  <li>positional only: these are nameless parameters (which are allowed only for datatype constructor parameters)</li>
  <li>either positional or by name: this is the most common parameter</li>
</ul>

<p>A parameter is either required or optional:</p>
<ul>
  <li>required: a caller has to supply an argument</li>
  <li>optional: the parameter has a default value that is used if a caller omits passing a specific argument</li>
</ul>

<p>The syntax for giving a positional-only (i.e., nameless) parameter does not allow a default-value expression, so a positional-only parameter is always required.</p>

<p>At a call site, positional arguments are not allowed to follow named arguments. Therefore, if <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is a nameonly parameter, then there is no way to supply the parameters after <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> by position. 
Thus, any parameter that follows <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> must either be passed by name or have a default value. 
That is, if a later (in the formal parameter declaration) parameter does not have a default value, it is effectively nameonly.</p>

<p>Positional arguments must be given before any named arguments.
Positional arguments are passed to the formals in the corresponding
position. Named arguments are passed to the formal of the given
name. Named arguments can be given out of order from how the corresponding
formal parameters are declared. A formal declared with the modifier
<code class="language-dafny highlighter-rouge"><span class="kr">nameonly</span></code> is not allowed to be passed positionally.
The list of bindings for a call must
provide exactly one value for every required parameter and at most one
value for each optional parameter, and must never name
non-existent formals. Any optional parameter that is not given a value
takes on the default value declared in the callee for that optional parameter.</p>

<h3 id="sec-assigned-expression">9.37. Assigned Expressions</h3>

<p>Examples:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">assigned</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>For any variable, constant, out-parameter, or object field <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>,
the expression <code class="language-dafny highlighter-rouge"><span class="n">assigned</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> evaluates to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> in a state
if <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is definitely assigned in that state.</p>

<p>See <a href="#sec-definite-assignment">Section 12.6</a> for more details on definite assignment.</p>

<h3 id="sec-termination-ordering-expressions">9.38. Termination Ordering Expressions</h3>

<p>When proving that a loop or recursive callable terminates, Dafny
automatically generates a proof obligation that the sequence of
expressions listed in a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause gets smaller (in the
<a href="#sec-decreases-clause">lexicographic termination ordering</a>) with each
iteration or recursive call. Normally, this proof obligation is purely
internal. However, it can be written as a Dafny expression using the
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="kr">to</span></code> operator.</p>

<p>The Boolean expression <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">b</span> <span class="kr">decreases</span> <span class="kr">to</span> <span class="n">a'</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">b'</span><span class="p">)</span></code> encodes
this ordering. (The parentheses can be omitted if there is exactly 1 left-hand side
and exactly 1 right-hand side.) For example, the following assertions are valid:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">M</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="mi">1</span> <span class="kr">decreases</span> <span class="kr">to</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span> <span class="kr">decreases</span> <span class="kr">to</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kr">decreases</span> <span class="kr">to</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Conversely, the following assertion is invalid:
<!-- %check-verify Expressions.5.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">M</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">x</span> <span class="kr">decreases</span> <span class="kr">to</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="kr">to</span></code> operator is strict, that is, it means strictly greater than.
The <code class="language-dafny highlighter-rouge"><span class="n">nonincreases</span> <span class="kr">to</span></code> operator is the non-strict (greater than or equal) version of it.</p>

<h3 id="sec-compile-time-constants">9.39. Compile-Time Constants</h3>

<p>In certain situations in Dafny it is helpful to know what the value of a
constant is during program analysis, before verification or execution takes
place. For example, a compiler can choose an optimized representation of a
<code class="language-dafny highlighter-rouge"><span class="kr">newtype</span></code> that is a subset of <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> if it knows the range of possible values
of the subset type: if the range is within 0 to less than 256, then an
unsigned 8-bit representation can be used.</p>

<p>To continue this example, suppose a new type is defined as
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">const</span> <span class="n">MAX</span> <span class="o">:=</span> <span class="mi">47</span>
<span class="kr">newtype</span> <span class="n">mytype</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="o">*</span><span class="mi">4</span>
</code></pre></div></div>
<p>In this case, we would prefer that Dafny recognize that <code class="language-dafny highlighter-rouge"><span class="n">MAX</span><span class="o">*</span><span class="mi">4</span></code> is
known to be constant with a value of <code class="language-dafny highlighter-rouge"><span class="mi">188</span></code>. The kinds of expressions
for which such an optimization is possible are called
<em>compile-time constants</em>. Note that the representation of <code class="language-dafny highlighter-rouge"><span class="n">mytype</span></code> makes
no difference semantically, but can affect how compiled code is represented at run time.
In addition, though, using a symbolic constant (which may
well be used elsewhere as well) improves the self-documentation of the code.</p>

<p>In Dafny, the following expressions are compile-time constants<sup id="fnref:CTC" role="doc-noteref"><a href="#fn:CTC" class="footnote" rel="footnote">12</a></sup>, recursively
(that is, the arguments of any operation must themselves be compile-time constants):</p>

<ul>
  <li>int, bit-vector, real, boolean, char and string literals</li>
  <li>int operations: <code class="language-dafny highlighter-rouge"><span class="o">+</span> <span class="o">-</span> <span class="o">*</span> <span class="o">/</span> <span class="o">%</span></code> and unary <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> and comparisons <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span> <span class="o">&lt;=</span> <span class="o">&gt;</span> <span class="o">&gt;=</span> <span class="o">==</span> <span class="o">!=</span></code></li>
  <li>real operations: <code class="language-dafny highlighter-rouge"><span class="o">+</span> <span class="o">-</span> <span class="o">*</span></code> and unary <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> and comparisons <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span> <span class="o">&lt;=</span> <span class="o">&gt;</span> <span class="o">&gt;=</span> <span class="o">==</span> <span class="o">!=</span></code></li>
  <li>bool operations: <code class="language-dafny highlighter-rouge"><span class="o">&amp;&amp;</span> <span class="o">||</span> <span class="o">==&gt;</span> <span class="o">&lt;==</span> <span class="o">&lt;==&gt;</span> <span class="o">==</span> <span class="o">!=</span></code> and unary <code class="language-dafny highlighter-rouge"><span class="o">!</span></code></li>
  <li>bit-vector operations: <code class="language-dafny highlighter-rouge"><span class="o">+</span> <span class="o">-</span> <span class="o">*</span> <span class="o">/</span> <span class="o">%</span> <span class="o">&lt;&lt;</span> <span class="o">&gt;&gt;</span> <span class="o">&amp;</span> <span class="o">|</span> <span class="o">^</span></code> and unary <code class="language-dafny highlighter-rouge"><span class="o">!</span> <span class="o">-</span></code> and comparisons <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span> <span class="o">&lt;=</span> <span class="o">&gt;</span> <span class="o">&gt;=</span> <span class="o">==</span> <span class="o">!=</span></code></li>
  <li>char operations: <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span> <span class="o">&lt;=</span> <span class="o">&gt;</span> <span class="o">&gt;=</span> <span class="o">==</span> <span class="o">!=</span></code></li>
  <li>string operations: length: <code class="language-dafny highlighter-rouge"><span class="o">|...|</span></code>, concatenation: <code class="language-dafny highlighter-rouge"><span class="o">+</span></code>, comparisons <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span> <span class="o">&lt;=</span> <span class="o">==</span> <span class="o">!=</span></code>, indexing <code class="language-dafny highlighter-rouge"><span class="p">[]</span></code></li>
  <li>conversions between: <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> <code class="language-dafny highlighter-rouge"><span class="kt">real</span></code> <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> bit-vector</li>
  <li>newtype operations: newtype arguments, but not newtype results</li>
  <li>symbolic values that are declared <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> and have an explicit initialization value that is a compile-time constant</li>
  <li>conditional (if-then-else) expressions</li>
  <li>parenthesized expressions</li>
</ul>

<h3 id="sec-list-of-specification-expressions">9.40. List of specification expressions</h3>

<p>The following is a list of expressions that can only appear in specification contexts or in ghost blocks.</p>

<ul>
  <li><a href="#sec-fresh-expression">Fresh expressions</a></li>
  <li><a href="#sec-allocated-expression">Allocated expressions</a></li>
  <li><a href="#sec-unchanged-expression">Unchanged expressions</a></li>
  <li><a href="#sec-old-expression">Old expressions</a></li>
  <li><a href="#sec-assigned-expression">Assigned expressions</a></li>
  <li><a href="#sec-statement-in-an-expression">Assert and calc expressions</a></li>
  <li><a href="#sec-hash-call">Hash Calls</a></li>
  <li><a href="#sec-termination-ordering-expressions">Termination ordering expression</a></li>
</ul>

<!--PDF NEWPAGE-->
<h2 id="sec-module-refinement">10. Refinement</h2>

<p>Refinement is the process of replacing something somewhat abstract with something somewhat more concrete.
For example, in one module one might declare a type name, with no definition,
such as <code class="language-dafny highlighter-rouge"><span class="kr">type</span> <span class="n">T</span></code>, and then in a refining module, provide a definition.
One could prove general properties about the contents of an (abstract) module,
and use that abstract module, and then later provide a more concrete implementation without having to redo all of the proofs.</p>

<p>Dafny supports <em>module refinement</em>, where one module is created from another,
and in that process the new module may be made more concrete than the previous.
More precisely, refinement takes the following form in Dafny. One module
declares some program entities. A second module <em>refines</em> the first by
declaring how to augment or replace (some of) those program entities.
The first module is called the <em>refinement parent</em>; the second is the
<em>refining</em> module; the result of combining the two (the original declarations
and the augmentation directives) is the <em>assembled</em> module or <em>refinement result</em>.</p>

<p>Syntactically, the refinement parent is a normal module declaration.
The refining module declares which module is its refinement parent with the
<code class="language-dafny highlighter-rouge"><span class="kr">refines</span></code> clause:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">P</span> <span class="p">{</span> <span class="c1">// refinement parent</span>
<span class="p">}</span>
<span class="kr">module</span> <span class="n">M</span> <span class="kr">refines</span> <span class="n">P</span> <span class="p">{</span> <span class="c1">// refining module</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The refinement result is created as follows.</p>

<p>0) The refinement result is a module within the same enclosing module as the
refining module, has the same name, and in fact replaces the refining module in their shared scope.</p>

<p>1) All the declarations (including import and export declarations) of the parent are copied into the refinement result.
These declarations are <em>not</em> re-resolved. That is, the assignment of
declarations and types to syntactic names is not changed. The refinement
result may exist in a different enclosing module and with a different set of
imports than the refinement parent, so that if names were reresolved, the
result might be different (and possibly not semantically valid).
This is why Dafny does not re-resolve the names in their new context.</p>

<p>2) All the declarations of the refining module that have different names
than the declarations in the refinement parent are also copied into the
refinement result.
However, because the refining module is just a set of augmentation
directives and may refer to names copied from the refinement parent,
resolution of names and types of the declarations copied in this step is
performed in the context of the full refinement result.</p>

<p>3) Where declarations in the parent and refinement module have the same name,
the second refines the first and the combination, a refined declaration, is
the result placed in the refinement result module, to the exclusion of the
declarations with the same name from the parent and refinement modules.</p>

<p>The way the refinement result declarations are assembled depends on the kind of declaration;
the rules are described in subsections below.</p>

<p>So that it is clear that refinement is taking place, refining declarations
have some syntactic indicator that they are refining some parent declaration.
Typically this is the presence of a <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> token.</p>

<h3 id="101-export-set-declarations">10.1. Export set declarations</h3>

<p>A refining export set declaration begins with <a href="#g-module-export">the syntax</a></p>
<pre><code class="language-grammar">"export" Ident ellipsis
</code></pre>
<p>but otherwise contains the same <code class="language-dafny highlighter-rouge"><span class="kr">provides</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">extends</span></code> sections,
with the ellipsis indicating that it is a refining declaration.</p>

<p>The result declaration has the same name as the two input declarations and the unions of names from each of the <code class="language-dafny highlighter-rouge"><span class="kr">provides</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">reveals</span></code>, and <code class="language-dafny highlighter-rouge"><span class="kr">extends</span></code>
sections, respectively.</p>

<p>An unnamed export set declaration from the parent is copied into the result
module with the name of the parent module. The result module has a default
export set according to the general rules for export sets, after all of
the result modules export set declarations have been assembled.</p>

<h3 id="102-import-declarations">10.2. Import declarations</h3>

<p>Aliasing import declarations are not refined. The result module contains the union
of the import declarations from the two input modules.
There must be no names in common among them.</p>

<p>Abstract import declarations (declared with <code class="language-dafny highlighter-rouge"><span class="o">:</span></code> instead of <code class="language-dafny highlighter-rouge"><span class="o">=</span></code>, <a href="#sec-module-abstraction">Section 4.6</a>) are refined. The refinement parent contains the
abstract import and the refining module contains a regular aliasing
import for the same name. Dafny checks that the refining import <em>adheres</em> to
the abstract import.</p>

<h3 id="103-sub-module-declarations">10.3. Sub-module declarations</h3>

<p>With respect to refinement, a nested module behaves just like a top-level module. It may be declared abstract and it may be declared to <code class="language-dafny highlighter-rouge"><span class="n">refine</span></code> some refinement parent. If the nested module is not refining anything and not being refined, then it is copied into the refinement result like any other declaration.</p>

<p>Here is some example code:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">P</span> <span class="p">{</span>
  <span class="kr">module</span> <span class="n">A</span> <span class="p">{</span> <span class="kr">const</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">5</span> <span class="p">}</span>
  <span class="kr">abstract</span> <span class="kr">module</span> <span class="n">B</span> <span class="p">{</span> <span class="kr">type</span> <span class="n">T</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">X</span> <span class="kr">refines</span> <span class="n">P</span> <span class="p">{</span>
  <span class="kr">module</span> <span class="n">B'</span> <span class="kr">refines</span> <span class="n">P</span><span class="o">.</span><span class="n">B</span> <span class="p">{</span> <span class="kr">type</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">}</span>
  <span class="kr">module</span> <span class="n">C</span> <span class="p">{</span> <span class="kr">const</span> <span class="n">k</span> <span class="o">:=</span> <span class="mi">6</span><span class="p">}</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="n">X</span>
  <span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">z</span><span class="o">:</span> <span class="n">X</span><span class="o">.</span><span class="n">B'</span><span class="o">.</span><span class="n">T</span> <span class="o">:=</span> <span class="n">X</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">k</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The refinement result of <code class="language-dafny highlighter-rouge"><span class="n">P</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> contains nested modules <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">B'</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">C</span></code>. It is this refinement result that is imported into <code class="language-dafny highlighter-rouge"><span class="n">M</span></code>.
Hence the names <code class="language-dafny highlighter-rouge"><span class="n">X</span><span class="o">.</span><span class="n">B'</span><span class="o">.</span><span class="n">T</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">X</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">i</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">X</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">k</span></code> are all valid.</p>

<h3 id="104-const-declarations">10.4. Const declarations</h3>

<p>Const declarations can be refined as in the following example.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">ToDefine</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">const</span> <span class="n">ToDefineWithoutType</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">const</span> <span class="n">ToGhost</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">B</span> <span class="kr">refines</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="n">ToDefine</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="mi">2</span>
  <span class="kr">const</span> <span class="n">ToDefineWithoutType</span> <span class="o">...</span> <span class="o">:=</span> <span class="mi">3</span>
  <span class="kr">ghost</span> <span class="kr">const</span> <span class="n">ToGhost</span><span class="o">:</span> <span class="kt">int</span>
  <span class="kr">const</span> <span class="n">NewConst</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Formally, a child <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> declaration may refine a <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> declaration
from a parent module if</p>

<ul>
  <li>the parent has no initialization,</li>
  <li>the child has the same type as the parent, and</li>
  <li>one or both of the following holds:
    <ul>
      <li>the child has an initializing expression</li>
      <li>the child is declared <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> and the parent is not <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code>.</li>
    </ul>
  </li>
</ul>

<p>A refining module can also introduce new <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> declarations that do
not exist in the refinement parent.</p>

<h3 id="105-method-declarations">10.5. Method declarations</h3>

<p>Method declarations can be refined as in the following example.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">method</span> <span class="n">ToImplement</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
    <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">x</span>

  <span class="kr">method</span> <span class="n">ToStrengthen</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>

  <span class="kr">method</span> <span class="n">ToDeterminize</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
    <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">x</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">y</span> <span class="o">:|</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">;</span>
    <span class="kr">return</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="kr">module</span> <span class="n">B</span> <span class="kr">refines</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">method</span> <span class="n">ToImplement</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kr">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kr">method</span> <span class="n">ToStrengthen</span> <span class="o">...</span>
    <span class="kr">ensures</span> <span class="n">r</span> <span class="o">==</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span>
  <span class="p">{</span>
    <span class="kr">return</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kr">method</span> <span class="n">ToDeterminize</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kr">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Formally, a child <code class="language-dafny highlighter-rouge"><span class="kr">method</span></code> definition may refine a parent <code class="language-dafny highlighter-rouge"><span class="kr">method</span></code>
declaration or definition by performing one or more of the following
operations:</p>

<ul>
  <li>provide a body missing in the parent (as in <code class="language-dafny highlighter-rouge"><span class="n">ToImplement</span></code>),</li>
  <li>strengthen the postcondition of the parent method by adding one or more
<code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses (as in <code class="language-dafny highlighter-rouge"><span class="n">ToStrengthen</span></code>),</li>
  <li>provide a more deterministic version of a non-deterministic parent
body (as in <code class="language-dafny highlighter-rouge"><span class="n">ToDeterminize</span></code>), or</li>
</ul>

<p>The type signature of a child method must be the same as that of the
parent method it refines. This can be ensured by providing an explicit
type signature equivalent to that of the parent (with renaming of
parameters allowed) or by using an ellipsis (<code class="language-dafny highlighter-rouge"><span class="o">...</span></code>) to indicate copying
of the parent type signature. The body of a child method must satisfy
any ensures clauses from its parent in addition to any it adds.</p>

<p>A refined method is allowed only if it does not invalidate any parent
lemmas that mention it.</p>

<p>A refining module can also introduce new <code class="language-dafny highlighter-rouge"><span class="kr">method</span></code> declarations or
definitions that do not exist in the refinement parent.</p>

<h3 id="106-lemma-declarations">10.6. Lemma declarations</h3>

<p>As lemmas are (ghost) methods, the description of method refinement from
the previous section also applies to lemma refinement.</p>

<p>A valid refinement is one that does not invalidate any proofs. A lemma
from a refinement parent must still be valid for the refinement result
of any method or lemma it mentions.</p>

<h3 id="107-function-and-predicate-declarations">10.7. Function and predicate declarations</h3>

<p>Function (and equivalently predicate) declarations can be refined as in
the following example.</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
    <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">x</span>

  <span class="kr">function</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
    <span class="kr">ensures</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">x</span>
  <span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">B</span> <span class="kr">refines</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="n">F</span> <span class="o">...</span>
  <span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>

  <span class="kr">function</span> <span class="n">G</span> <span class="o">...</span>
    <span class="kr">ensures</span> <span class="n">r</span> <span class="o">==</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Formally, a child <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> (or <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code>) definition can refine a
parent <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> (or <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code>) declaration or definition to</p>

<ul>
  <li>provide a body missing in the parent,</li>
  <li>strengthen the postcondition of the parent function by adding one or more
<code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses.</li>
</ul>

<p>The relation between the type signature of the parent and child function
is the same as for methods and lemmas, as described in the previous section.</p>

<p>A refining module can also introduce new <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> declarations or
definitions that do not exist in the refinement parent.</p>

<h3 id="108-class-trait-and-iterator-declarations">10.8. Class, trait and iterator declarations</h3>

<p>Class, trait, and iterator declarations are refined as follows:</p>
<ul>
  <li>If a class (or trait or iterator, respectively) <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> in a refining parent contains a
member that is not matched by a same-named member in the class <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> in the refining module, or vice-versa, then that class is copied as is to the 
refinement result.</li>
  <li>When there are members with the same name in the class in the refinement parent and in the refining module, then the combination occurs 
according to the rules for that category of member.</li>
</ul>

<p>Here is an example code snippet:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">P</span> <span class="p">{</span>
  <span class="kr">class</span> <span class="n">C</span> <span class="p">{</span>
    <span class="kr">function</span> <span class="n">F</span><span class="p">()</span><span class="o">:</span> <span class="kt">int</span>
      <span class="kr">ensures</span> <span class="n">F</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">X</span> <span class="kr">refines</span> <span class="n">P</span> <span class="p">{</span>
  <span class="kr">class</span> <span class="n">C</span> <span class="o">...</span> <span class="p">{</span>
    <span class="kr">function</span> <span class="n">F</span><span class="o">...</span>
      <span class="kr">ensures</span> <span class="n">F</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="109-type-declarations">10.9. Type declarations</h3>

<p>Types can be refined in two ways:</p>

<ul>
  <li>Turning an abstract type into a concrete type;</li>
  <li>Adding members to a datatype or a newtype.</li>
</ul>

<p>For example, consider the following abstract module:</p>

<!-- %check-verify %save Parent.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">Parent</span> <span class="p">{</span>
  <span class="kr">type</span> <span class="n">T</span>
  <span class="kr">type</span> <span class="n">B</span> <span class="o">=</span> <span class="kt">bool</span>
  <span class="kr">type</span> <span class="n">S</span> <span class="o">=</span> <span class="n">s</span><span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">witness</span> <span class="s2">"!"</span>
  <span class="kr">newtype</span> <span class="n">Pos</span> <span class="o">=</span> <span class="n">n</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">witness</span> <span class="mi">1</span>
  <span class="kr">datatype</span> <span class="n">Bool</span> <span class="o">=</span> <span class="n">True</span> <span class="o">|</span> <span class="n">False</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this module, type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> is opaque and hence can be refined with any type,
including class types.  Types <code class="language-dafny highlighter-rouge"><span class="n">B</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">S</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">Pos</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">Bool</span></code> are concrete and
cannot be refined further, except (for <code class="language-dafny highlighter-rouge"><span class="n">Pos</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Bool</span></code>) by giving them
additional members or attributes (or refining their existing members, if any).
Hence, the following are valid refinements:</p>

<!-- %check-verify %use Parent.tmp -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">ChildWithTrait</span> <span class="kr">refines</span> <span class="n">Parent</span> <span class="p">{</span>
  <span class="kr">trait</span> <span class="n">T</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">ChildWithClass</span> <span class="kr">refines</span> <span class="n">Parent</span> <span class="p">{</span>
  <span class="kr">class</span> <span class="n">T</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">ChildWithSynonymType</span> <span class="kr">refines</span> <span class="n">Parent</span> <span class="p">{</span>
  <span class="kr">type</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">ChildWithSubsetType</span> <span class="kr">refines</span> <span class="n">Parent</span> <span class="p">{</span>
  <span class="kr">type</span> <span class="n">T</span> <span class="o">=</span> <span class="n">s</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">|</span> <span class="n">s</span> <span class="o">!=</span> <span class="p">[]</span> <span class="kr">witness</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">ChildWithDataType</span> <span class="kr">refines</span> <span class="n">Parent</span> <span class="p">{</span>
  <span class="kr">datatype</span> <span class="n">T</span> <span class="o">=</span> <span class="n">True</span> <span class="o">|</span> <span class="n">False</span>
<span class="p">}</span>

<span class="kr">abstract</span> <span class="kr">module</span> <span class="n">ChildWithExtraMembers</span> <span class="kr">refines</span> <span class="n">Parent</span> <span class="p">{</span>
  <span class="kr">newtype</span> <span class="n">Pos</span> <span class="o">...</span> <span class="p">{</span>
    <span class="kr">method</span> <span class="n">Print</span><span class="p">()</span> <span class="p">{</span> <span class="kr">print</span> <span class="kr">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="kr">datatype</span> <span class="n">Bool</span> <span class="o">...</span> <span class="p">{</span>
    <span class="kr">function</span> <span class="n">AsDafnyBool</span><span class="p">()</span> <span class="o">:</span> <span class="kt">bool</span> <span class="p">{</span> <span class="kr">this</span><span class="o">.</span><span class="n">True?</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>(The last example is marked <code class="language-dafny highlighter-rouge"><span class="kr">abstract</span></code> because it leaves <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> opaque.)</p>

<p>Note that datatype constructors, codatatype destructors, and newtype definitions
cannot be refined: it is not possible to add or remove <code class="language-dafny highlighter-rouge"><span class="kr">datatype</span></code> constructors,
nor to change destructors of a <code class="language-dafny highlighter-rouge"><span class="kr">codatatype</span></code>, nor to change the base
type, constraint, or witness of a <code class="language-dafny highlighter-rouge"><span class="kr">newtype</span></code>.</p>

<p>When a type takes arguments, its refinement must use the same type arguments
with the same type constraints and the same variance.</p>

<p>When a type has type constraints, these type constraints must be preserved by
refinement.  This means that a type declaration <code class="language-dafny highlighter-rouge"><span class="kr">type</span> <span class="n">T</span><span class="p">(</span><span class="o">!</span><span class="kr">new</span><span class="p">)</span></code> cannot be refined
by a <code class="language-dafny highlighter-rouge"><span class="kr">class</span> <span class="n">T</span></code>, for example. Similarly, a <code class="language-dafny highlighter-rouge"><span class="kr">type</span> <span class="n">T</span><span class="p">(</span><span class="mi">00</span><span class="p">)</span></code> cannot be refined by a
subset type with a <code class="language-dafny highlighter-rouge"><span class="kr">witness</span> <span class="o">*</span></code> clause.</p>

<p>The refinement of an abstract type with body-less members can include both a definition
for the type along with a body for the member, as in this example:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">abstract</span> <span class="kr">module</span> <span class="n">P</span> <span class="p">{</span>
  <span class="kr">type</span> <span class="n">T3</span> <span class="p">{</span>
    <span class="kr">function</span> <span class="n">ToString</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">X</span> <span class="kr">refines</span> <span class="n">P</span> <span class="p">{</span>
  <span class="kr">newtype</span> <span class="n">T3</span> <span class="o">=</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
    <span class="kr">function</span> <span class="n">ToString</span><span class="o">...</span> <span class="p">{</span> <span class="s2">""</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that type refinements are not required to include the <code class="language-dafny highlighter-rouge"><span class="o">...</span></code> indicator that they are refining a parent type.</p>

<h3 id="1010-statements">10.10. Statements</h3>

<p>The refinement syntax (<code class="language-dafny highlighter-rouge"><span class="o">...</span></code>) in statements is deprecated.</p>

<!--PDF NEWPAGE-->
<h2 id="sec-attributes">11. Attributes</h2>

<p>Dafny allows many of its entities to be annotated with <em>Attributes</em>.
Attributes are declared between <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span></code> and <code class="language-dafny highlighter-rouge"><span class="p">}</span></code> like this:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{</span><span class="o">:</span><span class="n">attributeName</span> <span class="s2">"argument"</span><span class="p">,</span> <span class="s2">"second"</span> <span class="o">+</span> <span class="s2">"argument"</span><span class="p">,</span> <span class="mi">57</span><span class="p">}</span>
</code></pre></div></div>
<p>(White-space may follow but not precede the <code class="language-dafny highlighter-rouge"><span class="o">:</span></code> in <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span></code>.)</p>

<p>In general an attribute may have any name the user chooses. It may be
followed by a comma-separated list of expressions. These expressions will
be resolved and type-checked in the context where the attribute appears.</p>

<p>Any Dafny entity may have a list of attributes.
Dafny does not check that the attributes listed for an entity
are appropriate for it (which means that misspellings may
go silently unnoticed).</p>

<p>The grammar shows where the attribute annotations may appear:</p>
<pre><code class="language-grammar">Attribute = "{:" AttributeName [ Expressions ] "}"
</code></pre>

<p>Dafny has special processing for some attributes<sup id="fnref:boogie-attributes" role="doc-noteref"><a href="#fn:boogie-attributes" class="footnote" rel="footnote">13</a></sup>.  Of those,
some apply only to the entity bearing the attribute, while others (inherited
attributes) apply to the entity and its descendants (such as nested modules,
types, or declarations).  The attribute declaration closest to the entity
overrides those further away.</p>

<p>For attributes with a single boolean expression argument, the attribute
with no argument is interpreted as if it were true.</p>

<h3 id="111-attributes-on-top-level-declarations">11.1. Attributes on top-level declarations</h3>

<h4 id="sec-attributes-autocontracts">11.1.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autocontracts</span><span class="p">}</span></code></h4>
<p>Dynamic frames [@Kassios:FM2006;@SmansEtAl:VeriCool;@SmansEtAl:ImplicitDynamicFrames;
@LEINO:Dafny:DynamicFrames]
are frame expressions that can vary dynamically during
program execution. AutoContracts is an experimental feature that will
fill much of the dynamic-frames boilerplate into a class.</p>

<p>From the users perspective, what needs to be done is simply:</p>

<ul>
  <li>mark the class with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autocontracts</span><span class="p">}</span></code></li>
  <li>declare a function (or predicate) called <code class="language-dafny highlighter-rouge"><span class="n">Valid</span><span class="p">()</span></code></li>
</ul>

<p>AutoContracts will then:</p>

<ul>
  <li>Declare:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ghost</span> <span class="kr">var</span> <span class="n">Repr</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="kt">object</span><span class="o">&gt;</span>
</code></pre></div>    </div>
  </li>
  <li>For function/predicate <code class="language-dafny highlighter-rouge"><span class="n">Valid</span><span class="p">()</span></code>, insert:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">reads</span> <span class="kr">this</span><span class="p">,</span> <span class="n">Repr</span>
</code></pre></div>    </div>
  </li>
  <li>Into body of <code class="language-dafny highlighter-rouge"><span class="n">Valid</span><span class="p">()</span></code>, insert (at the beginning of the body):
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">this</span> <span class="ow">in</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="kc">null</span> <span class="o">!</span><span class="ow">in</span> <span class="n">Repr</span>
</code></pre></div>    </div>
  </li>
  <li>and also insert, for every array-valued field <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> declared in the class:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">==&gt;</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">Repr</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>and for every field <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> of a class type <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> has a field called <code class="language-dafny highlighter-rouge"><span class="n">Repr</span></code>, also insert:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="p">(</span><span class="n">F</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">==&gt;</span> <span class="n">F</span> <span class="ow">in</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="n">F</span><span class="o">.</span><span class="n">Repr</span> <span class="o">&lt;=</span> <span class="n">Repr</span> <span class="o">&amp;&amp;</span> <span class="kr">this</span> <span class="o">!</span><span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">Repr</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>Except, if A or F is declared with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autocontracts</span> <span class="kc">false</span><span class="p">}</span></code>, then the implication will not
be added.</p>
  </li>
  <li>For every constructor, add:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">modifies</span> <span class="kr">this</span>
 <span class="kr">ensures</span> <span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="kr">fresh</span><span class="p">(</span><span class="n">Repr</span> <span class="o">-</span> <span class="p">{</span><span class="kr">this</span><span class="p">})</span>
</code></pre></div>    </div>
  </li>
  <li>At the end of the body of the constructor, add:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="n">Repr</span> <span class="o">:=</span> <span class="p">{</span><span class="kr">this</span><span class="p">};</span>
 <span class="kr">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">Repr</span> <span class="o">:=</span> <span class="n">Repr</span> <span class="o">+</span> <span class="p">{</span><span class="n">A</span><span class="p">};</span> <span class="p">}</span>
 <span class="kr">if</span> <span class="p">(</span><span class="n">F</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">Repr</span> <span class="o">:=</span> <span class="n">Repr</span> <span class="o">+</span> <span class="p">{</span><span class="n">F</span><span class="p">}</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">Repr</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>For every method, add:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">requires</span> <span class="n">Valid</span><span class="p">()</span>
 <span class="kr">modifies</span> <span class="n">Repr</span>
 <span class="kr">ensures</span> <span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="kr">fresh</span><span class="p">(</span><span class="n">Repr</span> <span class="o">-</span> <span class="kr">old</span><span class="p">(</span><span class="n">Repr</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li>At the end of the body of the method, add:
<!-- %no-check -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="kr">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">Repr</span> <span class="o">:=</span> <span class="n">Repr</span> <span class="o">+</span> <span class="p">{</span><span class="n">A</span><span class="p">};</span> <span class="p">}</span>
 <span class="kr">if</span> <span class="p">(</span><span class="n">F</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">Repr</span> <span class="o">:=</span> <span class="n">Repr</span> <span class="o">+</span> <span class="p">{</span><span class="n">F</span><span class="p">}</span> <span class="o">+</span> <span class="n">F</span><span class="o">.</span><span class="n">Repr</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="sec-nativetype">11.1.2. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">nativeType</span><span class="p">}</span></code></h4>
<p>The <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">nativeType</span><span class="p">}</span></code> attribute is only recognized by a <code class="language-dafny highlighter-rouge"><span class="kr">newtype</span></code> declaration
where the base type is an integral type or a real type. For example:</p>

<!-- %check-resolve Attributes.1.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">newtype</span> <span class="p">{</span><span class="o">:</span><span class="n">nativeType</span> <span class="s2">"byte"</span><span class="p">}</span> <span class="n">ubyte</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">256</span>
<span class="kr">newtype</span> <span class="p">{</span><span class="o">:</span><span class="n">nativeType</span> <span class="s2">"byte"</span><span class="p">}</span> <span class="n">bad_ubyte</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">257</span> <span class="c1">// Fails</span>
</code></pre></div></div>

<p>It can take one of the following forms:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">nativeType</span><span class="p">}</span></code> - With no parameters it has no effect and the declaration
will have its default behavior, which is to choose a native type that can hold any
value satisfying the constraints, if possible, and otherwise to use BigInteger.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">nativeType</span> <span class="kc">true</span><span class="p">}</span></code> - Also gives default behavior,
but gives an error if the base type is not integral.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">nativeType</span> <span class="kc">false</span><span class="p">}</span></code> - Inhibits using a native type. BigInteger is used.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">nativeType</span> <span class="s2">"typename"</span><span class="p">}</span></code> - This form has an native integral
type name as a string literal. Acceptable values are:
    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="s2">"byte"</span></code>      8 bits, unsigned</li>
      <li><code class="language-dafny highlighter-rouge"><span class="s2">"sbyte"</span></code>     8 bits, signed</li>
      <li><code class="language-dafny highlighter-rouge"><span class="s2">"ushort"</span></code>    16 bits, unsigned</li>
      <li><code class="language-dafny highlighter-rouge"><span class="s2">"short"</span></code>     16 bits, signed</li>
      <li><code class="language-dafny highlighter-rouge"><span class="s2">"uint"</span></code>      32 bits, unsigned</li>
      <li><code class="language-dafny highlighter-rouge"><span class="s2">"int"</span></code>       32 bits, signed</li>
      <li><code class="language-dafny highlighter-rouge"><span class="s2">"number"</span></code>    53 bits, signed</li>
      <li><code class="language-dafny highlighter-rouge"><span class="s2">"ulong"</span></code>     64 bits, unsigned</li>
      <li><code class="language-dafny highlighter-rouge"><span class="s2">"long"</span></code>      64 bits, signed</li>
    </ul>

    <p>If the target compiler
does not support a named native type X, then an error is generated. Also, if, after
scrutinizing the constraint predicate, the compiler cannot confirm
that the types values will fit in X, an error is generated.
The names given above do not have to match the names in the target compilation language,
just the characteristics of that type.</p>
  </li>
</ul>

<h4 id="1113-ignore-deprecated">11.1.3. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">ignore</span><span class="p">}</span></code> (deprecated)</h4>
<p>Ignore the declaration (after checking for duplicate names).</p>

<h4 id="sec-extern">11.1.4. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code></h4>

<p><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> is a target-language dependent modifier used</p>

<ul>
  <li>to alter the <code class="language-dafny highlighter-rouge"><span class="n">CompileName</span></code> of entities such as modules, classes, methods, etc.,</li>
  <li>to alter the <code class="language-dafny highlighter-rouge"><span class="n">ReferenceName</span></code> of the entities,</li>
  <li>to decide how to define external abstract types,</li>
  <li>to decide whether to emit target code or not, and</li>
  <li>to decide whether a declaration is allowed not to have a body.</li>
</ul>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">CompileName</span></code> is the name for the entity when translating to one of the target languages.
The <code class="language-dafny highlighter-rouge"><span class="n">ReferenceName</span></code> is the name used to refer to the entity in the target language.
A common use case of <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> is to avoid name clashes with existing library functions.</p>

<p><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> takes 0, 1, or 2 (possibly empty) string arguments:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code>: Dafny will use the Dafny-determined name as the <code class="language-dafny highlighter-rouge"><span class="n">CompileName</span></code> and not affect the <code class="language-dafny highlighter-rouge"><span class="n">ReferenceName</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span> <span class="n">s1</span><span class="p">}</span></code>: Dafny will use <code class="language-dafny highlighter-rouge"><span class="n">s1</span></code> as the <code class="language-dafny highlighter-rouge"><span class="n">CompileName</span></code>, and replaces the last portion of the <code class="language-dafny highlighter-rouge"><span class="n">ReferenceName</span></code> by <code class="language-dafny highlighter-rouge"><span class="n">s1</span></code>.
   When used on an abstract type, s1 is used as a hint as to how to declare that type when compiling.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">}</span></code> Dafny will use <code class="language-dafny highlighter-rouge"><span class="n">s2</span></code> as the <code class="language-dafny highlighter-rouge"><span class="n">CompileName</span></code>.
   Dafny will use a combination of <code class="language-dafny highlighter-rouge"><span class="n">s1</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">s2</span></code> such as for example <code class="language-dafny highlighter-rouge"><span class="n">s1</span><span class="o">.</span><span class="n">s2</span></code> as the <code class="language-dafny highlighter-rouge"><span class="n">ReferenceName</span></code>
   It may also be the case that one of the arguments is simply ignored.</li>
</ul>

<p>Dafny does not perform sanity checks on the argumentsit is the users responsibility not to generate
  malformed target code.</p>

<p>For more detail on the use of <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code>, see the corresponding <a href="#sec-extern-decls">section</a> in the users guide.</p>

<h4 id="sec-disable-nonlinear-arithmetic">11.1.5. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">disableNonlinearArithmetic</span><span class="p">}</span></code></h4>
<p>This attribute only applies to module declarations. It overrides the global option <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">disable</span><span class="o">-</span><span class="n">nonlinear</span><span class="o">-</span><span class="n">arithmetic</span></code> for that specific module. The attribute can be given true or false to disable or enable nonlinear arithmetic. When no value is given, the default value is true.</p>

<h3 id="112-attributes-on-functions-and-methods">11.2. Attributes on functions and methods</h3>

<h4 id="1121-abstemious">11.2.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">abstemious</span><span class="p">}</span></code></h4>
<p>The <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">abstemious</span><span class="p">}</span></code> attribute is appropriate for functions on codatatypes.
If appropriate to a function, the attribute can aid in proofs that the function is <em>productive</em>.
See <a href="#sec-abstemious">the section on abstemious functions</a> for more description.</p>

<h4 id="1122-autoreq">11.2.2. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoReq</span><span class="p">}</span></code></h4>
<p>For a function declaration, if this attribute is set true at the nearest
level, then its <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause is strengthened sufficiently so that
it may call the functions that it calls.</p>

<p>For following example
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="kt">int</span><span class="p">)</span> <span class="o">:</span> <span class="kt">bool</span>
  <span class="kr">requires</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="p">{</span>
  <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">7</span>
<span class="p">}</span>

<span class="c1">// Should succeed thanks to auto_reqs</span>
<span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">autoReq</span><span class="p">}</span> <span class="n">g</span><span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span><span class="kt">bool</span><span class="p">)</span> <span class="o">:</span> <span class="kt">bool</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="kr">else</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoReq</span><span class="p">}</span></code> attribute causes Dafny to
deduce a <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause for g as if it had been
declared
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="kt">int</span><span class="p">)</span> <span class="o">:</span> <span class="kt">bool</span>
  <span class="kr">requires</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="p">{</span>
  <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">7</span>
<span class="p">}</span>
<span class="kr">function</span> <span class="n">g</span><span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span><span class="kt">bool</span><span class="p">)</span> <span class="o">:</span> <span class="kt">bool</span>
  <span class="kr">requires</span> <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="kr">else</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="sec-autorevealdependencies">11.2.3. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="n">k</span><span class="p">}</span></code></h4>
<p>When setting <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">default</span><span class="o">-</span><span class="kr">function</span><span class="o">-</span><span class="n">opacity</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">autoRevealDependencies</span></code>, the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="n">k</span><span class="p">}</span></code> attribute can be set on methods and functions to make sure that only function dependencies of depth <code class="language-dafny highlighter-rouge"><span class="n">k</span></code> in the call-graph or less are revealed automatically. As special cases, one can also use <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="kc">false</span><span class="p">}</span></code> (or <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="mi">0</span><span class="p">}</span></code>) to make sure that no dependencies are revealed, and <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="kc">true</span><span class="p">}</span></code> to make sure that all dependencies are revealed automatically.</p>

<p>For example, when the following code is run with <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">default</span><span class="o">-</span><span class="kr">function</span><span class="o">-</span><span class="n">opacity</span></code> set to <code class="language-dafny highlighter-rouge"><span class="n">autoRevealDependencies</span></code>, the function <code class="language-dafny highlighter-rouge"><span class="n">p</span><span class="p">()</span></code> should verify and <code class="language-dafny highlighter-rouge"><span class="n">q</span><span class="p">()</span></code> should not.
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>   <span class="kr">function</span> <span class="n">t1</span><span class="p">()</span> <span class="o">:</span> <span class="kt">bool</span> <span class="p">{</span> <span class="kc">true</span> <span class="p">}</span>
   
   <span class="kr">function</span> <span class="n">t2</span><span class="p">()</span> <span class="o">:</span> <span class="kt">bool</span> <span class="p">{</span> <span class="n">t1</span><span class="p">()</span> <span class="p">}</span>

   <span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="mi">1</span><span class="p">}</span> <span class="n">p</span><span class="p">()</span> <span class="o">:</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> 
     <span class="kr">ensures</span> <span class="n">r</span>
   <span class="p">{</span> <span class="n">t1</span><span class="p">()</span> <span class="p">}</span>
   
   <span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="mi">1</span><span class="p">}</span> <span class="n">q</span><span class="p">()</span> <span class="o">:</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> 
     <span class="kr">ensures</span> <span class="n">r</span>
   <span class="p">{</span> <span class="n">t2</span><span class="p">()</span> <span class="p">}</span>
</code></pre></div></div>

<h4 id="sec-axiom">11.2.4. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code></h4>
<p>The <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code> attribute may be placed on a function or method.
It means that the post-condition may be assumed to be true
without proof. In that case also the body of the function or
method may be omitted.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code> attribute only prevents Dafny from verifying that the body matches the post-condition.
Dafny still verifies the <a href="#sec-assertion-batches">well-formedness</a> of pre-conditions, of post-conditions, and of the body if provided.
To prevent Dafny from running all these checks, one would use <a href="#sec-verify"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">verify</span> <span class="kc">false</span><span class="p">}</span></code></a>, which is not recommended.</p>

<p>The compiler will still emit code for an <a href="#sec-axiom"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code></a>, if it is a <a href="#sec-function-declarations"><code class="language-dafny highlighter-rouge"><span class="kr">function</span></code>, a <code class="language-dafny highlighter-rouge"><span class="kr">method</span></code> or a <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">by</span> <span class="kr">method</span></code></a> with a body.</p>

<h4 id="1125-compile">11.2.5. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">compile</span><span class="p">}</span></code></h4>
<p>The <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">compile</span><span class="p">}</span></code> attribute takes a boolean argument. It may be applied to
any top-level declaration. If that argument is false, then that declaration
will not be compiled at all.
The difference with <a href="#sec-extern"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code></a> is that <a href="#sec-extern"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code></a>
will still emit declaration code if necessary,
whereas <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">compile</span> <span class="kc">false</span><span class="p">}</span></code> will just ignore the declaration for compilation purposes.</p>

<h4 id="sec-concurrent-attribute">11.2.6. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">concurrent</span><span class="p">}</span></code></h4>
<p>The <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">concurrent</span><span class="p">}</span></code> attribute indicates that the compiled code for a function or method
may be executed concurrently.
While Dafny is a sequential language and does not support any native concepts for spawning
or controlling concurrent execution,
it does support restricting the specification of declarations such that it is safe to execute them concurrently
using integration with the target language environment.</p>

<p>Currently, the only way to satisfy this requirement is to ensure that the specification
of the function or method includes the equivalent of <code class="language-dafny highlighter-rouge"><span class="kr">reads</span> <span class="p">{}</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span> <span class="p">{}</span></code>.
This ensures that the code does not read or write any shared mutable state,
although it is free to read and write newly allocated objects.</p>

<h4 id="sec-extern-method">11.2.7. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">}</span></code></h4>
<p>See <a href="#sec-extern"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">}</span></code></a>.</p>

<h4 id="sec-fuel">11.2.8. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">fuel</span> <span class="n">X</span><span class="p">}</span></code></h4>

<p>The fuel attribute is used to specify how much fuel a function should have,
i.e., how many times the verifier is permitted to unfold its definition.  The
<code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">fuel</span><span class="p">}</span></code> annotation can be added to the function itself, in which
case it will apply to all uses of that function, or it can be overridden
within the scope of a module, function, method, iterator, calc, forall,
while, assert, or assume.  The general format is:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{</span><span class="o">:</span><span class="n">fuel</span> <span class="n">functionName</span><span class="p">,</span><span class="n">lowFuel</span><span class="p">,</span><span class="n">highFuel</span><span class="p">}</span>
</code></pre></div></div>

<p>When applied as an annotation to the function itself, omit
functionName.  If highFuel is omitted, it defaults to lowFuel + 1.</p>

<p>The default fuel setting for recursive functions is 1,2.  Setting the
fuel higher, say, to 3,4, will give more unfoldings, which may make
some proofs go through with less programmer assistance (e.g., with
fewer assert statements), but it may also increase verification time,
so use it with care.  Setting the fuel to 0,0 is similar to making the
definition opaque, except when used with all literal arguments.</p>

<h4 id="1129-id-string">11.2.9. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">id</span> <span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="p">}</span></code></h4>
<p>Assign a custom unique ID to a function or a method to be used for verification
result caching.</p>

<h4 id="sec-induction">11.2.10. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code></h4>
<p>The <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code> attribute controls the application of
proof by induction to two contexts. Given a list of
variables on which induction might be applied, the
<code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code> attribute selects a sub-list of those
variables (in the same order) to which to apply induction.</p>

<p>Dafny issue <a href="https://github.com/Microsoft/dafny/issues/34">34</a>
proposes to remove the restriction that the sub-list
be in the same order, and would apply induction in the
order given in the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code> attribute.</p>

<p>The two contexts are:</p>

<ul>
  <li>A method, in which case the bound variables are all the
in-parameters of the method.</li>
  <li>A <a href="#sec-induction-quantifier">quantifier expression</a>, in which case the bound variables
are the bound variables of the quantifier expression.</li>
</ul>

<p>The form of the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code> attribute is one of the following:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code> or <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span> <span class="kc">true</span><span class="p">}</span></code>  apply induction to all bound variables</li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span> <span class="kc">false</span><span class="p">}</span></code>  suppress induction, that is, dont apply it to any bound variable</li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span> <span class="n">L</span><span class="p">}</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">L</span></code> is a sublist of the bound variables
 apply induction to the specified bound variables</li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span> <span class="n">X</span><span class="p">}</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> is anything else  raise an error.</li>
</ul>

<p>Here is an example of using it on a quantifier expression:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Unary</span> <span class="o">=</span> <span class="n">Zero</span> <span class="o">|</span> <span class="n">Succ</span><span class="p">(</span><span class="n">Unary</span><span class="p">)</span>

<span class="kr">function</span> <span class="n">UnaryToNat</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="n">Unary</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span> <span class="p">{</span>
  <span class="kr">match</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">Zero</span> <span class="o">=&gt;</span> <span class="mi">0</span>
  <span class="kr">case</span> <span class="n">Succ</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">UnaryToNat</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kr">function</span> <span class="n">NatToUnary</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="n">Unary</span> <span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="n">Zero</span> <span class="kr">else</span> <span class="n">Succ</span><span class="p">(</span><span class="n">NatToUnary</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>

<span class="kr">lemma</span> <span class="n">Correspondence</span><span class="p">()</span>
  <span class="kr">ensures</span> <span class="kr">forall</span> <span class="n">n</span><span class="o">:</span> <span class="kt">nat</span> <span class="p">{</span><span class="o">:</span><span class="n">induction</span> <span class="n">n</span><span class="p">}</span> <span class="o">::</span> <span class="n">UnaryToNat</span><span class="p">(</span><span class="n">NatToUnary</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">==</span> <span class="n">n</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="sec-induction-trigger">11.2.11. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">inductionTrigger</span><span class="p">}</span></code></h4>

<p>Dafny automatically generates triggers for quantified induction hypotheses.  The default selection can be overridden using the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">inductionTrigger</span><span class="p">}</span></code> attribute, which works like the usual <a href="#sec-trigger"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span><span class="p">}</span></code> attribute</a>.</p>

<h4 id="sec-only-functions-methods">11.2.12. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code></h4>

<p><code class="language-dafny highlighter-rouge"><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span> <span class="n">X</span><span class="p">()</span> <span class="p">{}</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span> <span class="n">X</span><span class="p">()</span> <span class="p">{}</span></code>  temporarily disables the verification of all other non-<code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code> members, e.g. other functions and methods, in the same file, even if they contain <a href="#sec-only">assertions with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code></a>.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span> <span class="n">TestVerified</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                  <span class="c1">// Unchecked</span>
  <span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span> <span class="kc">true</span> <span class="kr">by</span> <span class="p">{</span>      <span class="c1">// Checked</span>
    <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                <span class="c1">// Checked</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                  <span class="c1">// Unchecked</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">TestUnverified</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                  <span class="c1">// Unchecked</span>
  <span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span> <span class="kc">true</span> <span class="kr">by</span> <span class="p">{</span>      <span class="c1">// Unchecked because of {:only} Test()</span>
    <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                <span class="c1">// Unchecked</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                  <span class="c1">// Unchecked</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code> can help focusing on a particular member, for example a lemma or a function, as it simply disables the verification of all other lemmas, methods and functions in the same file. Its equivalent to adding <a href="#sec-verify"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">verify</span> <span class="kc">false</span><span class="p">}</span></code></a> to all other declarations simulatenously on the same file. Since its meant to be a temporary construct, it always emits a warning.</p>

<p>More information about the Boogie implementation of <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">opaque</span><span class="p">}</span></code> is <a href="https://github.com/dafny-lang/dafny/blob/master/docs/Compilation/Boogie.md">here</a>.</p>

<h4 id="sec-print">11.2.13. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="kr">print</span><span class="p">}</span></code></h4>
<p>This attribute declares that a method may have print effects,
that is, it may use <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statements and may call other methods
that have print effects. The attribute can be applied to compiled
methods, constructors, and iterators, and it gives an error if
applied to functions or ghost methods. An overriding method is
allowed to use a <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="kr">print</span><span class="p">}</span></code> attribute only if the overridden method
does.
Print effects are enforced only with <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">track</span><span class="o">-</span><span class="kr">print</span><span class="o">-</span><span class="n">effects</span></code>.</p>

<h4 id="11214-priority">11.2.14. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">priority</span><span class="p">}</span></code></h4>
<p><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">priority</span> <span class="n">N</span><span class="p">}</span></code> assigns a positive priority N to a method or function to control the order
in which methods or functions are verified (default: N = 1).</p>

<h4 id="sec-rlimit">11.2.15. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">resource_limit</span><span class="p">}</span></code> and <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">rlimit</span><span class="p">}</span></code></h4>

<p><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">resource_limit</span> <span class="n">N</span><span class="p">}</span></code> limits the verifier resource usage to verify the method or function to <code class="language-dafny highlighter-rouge"><span class="n">N</span></code>.</p>

<p>This is the per-method equivalent of the command-line flag <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">rlimit</span><span class="o">:</span><span class="n">N</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">resource</span><span class="o">-</span><span class="n">limit</span> <span class="n">N</span></code>.
If using <a href="#sec-isolate_assertions"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code></a> as well, the limit will be set for each assertion.</p>

<p>The attribute <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">rlimit</span> <span class="n">N</span><span class="p">}</span></code> is also available, and limits the verifier resource usage to verify the method or function to <code class="language-dafny highlighter-rouge"><span class="n">N</span> <span class="o">*</span> <span class="mi">1000</span></code>. This version is deprecated, however.</p>

<p>To give orders of magnitude about resource usage, here is a list of examples indicating how many resources are used to verify each method:</p>

<ul>
  <li>8K resource usage
<!-- %check-verify -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>10K resource usage using assertions that do not add assumptions:
<!-- %check-verify -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">a</span><span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span> <span class="o">==&gt;</span> <span class="o">!</span><span class="n">a</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">b</span><span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span> <span class="o">==&gt;</span> <span class="o">!</span><span class="n">a</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">c</span><span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span> <span class="o">==&gt;</span> <span class="o">!</span><span class="n">a</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">d</span><span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span> <span class="o">==&gt;</span> <span class="o">!</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>40K total resource usage using <a href="#sec-isolate_assertions"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code></a>
<!-- %check-verify -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">bool</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">a</span><span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span> <span class="o">==&gt;</span> <span class="o">!</span><span class="n">a</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">b</span><span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span> <span class="o">==&gt;</span> <span class="o">!</span><span class="n">a</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">c</span><span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span> <span class="o">==&gt;</span> <span class="o">!</span><span class="n">a</span><span class="p">);</span>
  <span class="kr">assert</span> <span class="n">d</span><span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;==&gt;</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span> <span class="o">==&gt;</span> <span class="o">!</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>37K total resource usage and thus fails with <code class="language-dafny highlighter-rouge"><span class="n">out</span> <span class="n">of</span> <span class="n">resource</span></code>.
<!-- %check-verify Attributes.4.expect -->
    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">rlimit</span> <span class="mi">30</span><span class="p">}</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">c</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Note that, the default solver Z3 tends to overshoot by <code class="language-dafny highlighter-rouge"><span class="err">7K</span></code> to <code class="language-dafny highlighter-rouge"><span class="err">8K</span></code>, so if you put <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">rlimit</span> <span class="mi">20</span><span class="p">}</span></code> in the last example, the total resource usage would be <code class="language-dafny highlighter-rouge"><span class="err">27K</span></code>.</p>

<h4 id="11216-selective_checking">11.2.16. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">selective_checking</span><span class="p">}</span></code></h4>
<p>Turn all assertions into assumptions except for the ones reachable from after the
assertions marked with the attribute <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">start_checking_here</span><span class="p">}</span></code>.
Thus, <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="p">{</span><span class="o">:</span><span class="n">start_checking_here</span><span class="p">}</span> <span class="n">something</span><span class="p">;</span></code> becomes an inverse
of <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span></code>: the first one disables all verification before
it, and the second one disables all verification after.</p>

<h4 id="11217-tailrecursion">11.2.17. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">tailrecursion</span><span class="p">}</span></code></h4>
<p>This attribute is used on method or function declarations. It has a boolean argument.</p>

<p>If specified with a <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> value, it means the user specifically
requested no tail recursion, so none is done.</p>

<p>If specified with a <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> value, or if no argument is specified,
then tail recursive optimization will be attempted subject to
the following conditions:</p>

<ul>
  <li>It is an error if the method is a ghost method and tail
recursion was explicitly requested.</li>
  <li>Only direct recursion is supported, not mutually recursive methods.</li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">tailrecursion</span> <span class="kc">true</span><span class="p">}</span></code> was specified but the code does not allow it,
an error message is given.</li>
</ul>

<p>If you have a stack overflow, it might be that you have
a function on which automatic attempts of tail recursion
failed, but for which efficient iteration can be implemented by hand. To do this,
use a <a href="#sec-function-by-method">function by method</a> and
define the loop in the method yourself,
proving that it implements the function.</p>

<p>Using a function by method to implement recursion can
be tricky. It usually helps to look at the result of the function
on two to three iterations, without simplification,
and see what should be the first computation. For example,
consider the following tail-recursion implementation:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Success</span><span class="p">(</span><span class="n">value</span><span class="o">:</span> <span class="n">V</span><span class="p">)</span> <span class="o">|</span> <span class="n">Failure</span><span class="p">(</span><span class="n">error</span><span class="o">:</span> <span class="n">E</span><span class="p">)</span>

<span class="kr">function</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="n">Result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="o">&gt;</span>

<span class="c1">//  {:tailrecursion true}  Not possible here</span>
<span class="kr">function</span> <span class="n">MakeTailRec</span><span class="p">(</span>
  <span class="n">obj</span><span class="o">:</span> <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">)</span><span class="o">:</span> <span class="n">Result</span><span class="o">&lt;</span><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">string</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="o">|</span><span class="n">obj</span><span class="o">|</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="n">Success</span><span class="p">([])</span>
  <span class="kr">else</span>
    <span class="kr">var</span> <span class="n">tail</span> <span class="o">:=</span> <span class="n">MakeTailRec</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]);</span>
    <span class="kr">var</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="kr">if</span> <span class="n">r</span><span class="o">.</span><span class="n">Failure?</span> <span class="kr">then</span>
      <span class="n">Failure</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">error</span><span class="p">)</span>
    <span class="kr">else</span> <span class="kr">if</span> <span class="n">tail</span><span class="o">.</span><span class="n">Failure?</span> <span class="kr">then</span>
      <span class="n">tail</span>
    <span class="kr">else</span>
      <span class="n">Success</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="p">}</span> <span class="kr">by</span> <span class="kr">method</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">i</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">:=</span> <span class="o">|</span><span class="n">obj</span><span class="o">|</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">tail</span> <span class="o">:=</span> <span class="n">Success</span><span class="p">([]);</span> <span class="c1">// Base case</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="kr">decreases</span> <span class="n">i</span>
    <span class="kr">invariant</span> <span class="n">tail</span> <span class="o">==</span> <span class="n">MakeTailRec</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">])</span>
  <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kr">var</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">f</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="kr">if</span> <span class="n">r</span><span class="o">.</span><span class="n">Failure?</span> <span class="p">{</span>
      <span class="n">tail</span> <span class="o">:=</span> <span class="n">Failure</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">error</span><span class="p">);</span>
    <span class="p">}</span> <span class="kr">else</span> <span class="kr">if</span> <span class="n">tail</span><span class="o">.</span><span class="n">Success?</span> <span class="p">{</span>
      <span class="n">tail</span> <span class="o">:=</span> <span class="n">Success</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kr">return</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The rule of thumb to unroll a recursive call into a sequential one
is to look at how the result would be computed if the operations were not
simplified. For example, unrolling the function on <code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span></code> yields the result
<code class="language-dafny highlighter-rouge"><span class="n">Success</span><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">+</span> <span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">+</span> <span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">+</span> <span class="p">[])))</span></code>.
If you had to compute this expression manually, youd start with
<code class="language-dafny highlighter-rouge"><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">+</span> <span class="p">[])</span></code>, then add <code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span></code> to the left, then 
<code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">]</span></code>.
This is why the method loop iterates with the objects
from the end, and why the intermediate invariants are
all about proving <code class="language-dafny highlighter-rouge"><span class="n">tail</span> <span class="o">==</span> <span class="n">MakeTailRec</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">])</span></code>, which
makes verification succeed easily because we replicate
exactly the behavior of <code class="language-dafny highlighter-rouge"><span class="n">MakeTailRec</span></code>.
If we were not interested in the first error but the last one,
a possible optimization would be, on the first error, to finish
iterate with a ghost loop that is not executed.</p>

<p>Note that the function definition can be changed by computing
the tail closer to where its used or switching the order of computing
<code class="language-dafny highlighter-rouge"><span class="n">r</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">tail</span></code>, but the <code class="language-dafny highlighter-rouge"><span class="kr">by</span> <span class="kr">method</span></code> body can stay the same.</p>

<h4 id="sec-test-attribute">11.2.18. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span></code></h4>
<p>This attribute indicates the target function or method is meant
to be executed at runtime in order to test that the program is working as intended.</p>

<p>There are two different ways to dynamically test functionality in a test:</p>

<ol>
  <li>A test can optionally return a single value to indicate success or failure.
If it does, this must be a <em>failure-compatible</em> type
just as the <a href="#sec-update-with-failure-statement">update-with-failure statement</a> requires. That is,
the returned type must define a <code class="language-dafny highlighter-rouge"><span class="n">IsFailure</span><span class="p">()</span></code> function method. If <code class="language-dafny highlighter-rouge"><span class="n">IsFailure</span><span class="p">()</span></code>
evaluates to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> on the return value, the test will be marked a failure, and this
return value used as the failure message.</li>
  <li>Code in the control flow of the test can use <a href="#sec-expect-statement"><code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statements</a>
to dynamically test if a boolean expression is true, and cause the test to halt
if not (but not the overall testing process). The optional second argument to 
a failed <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statement will be used as the test failure message.</li>
</ol>

<p>Note that the <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> keyword can also be used to form assign or halt statements
such as <code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">x</span> <span class="o">:-</span> <span class="kr">expect</span> <span class="n">CalculateX</span><span class="p">();</span></code>, which is a convenient way to invoke a method
that may produce a failure within a test without having to return a value from the test.</p>

<p>There are also two different approaches to executing all tests in a program:</p>

<ol>
  <li>By default, the compiler will mark each compiled method as necessary so that
a designated target language testing framework will discover and run it.
This is currently only implemented for C#, using the xUnit <code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="n">Fact</span><span class="p">]</span></code> annotation.</li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">test</span></code> is used, Dafny will instead produce a main method
that invokes each test and prints the results.
This runner is currently very basic, but avoids introducing any additional target
language dependencies in the compiled code.</li>
</ol>

<p>A method marked <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span></code> may not have any input arguments. If there is an
output value that does not have a failure-compatible type, that value is 
ignored. A method that does have input arguments can be wrapped in a test
harness that supplies input arguments but has no inputs of its own and that
checks any output values, perhaps with <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statements. The test harness
is then the method marked with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span></code>.</p>

<h4 id="sec-time-limit">11.2.19. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">timeLimit</span> <span class="n">N</span><span class="p">}</span></code></h4>
<p>Set the time limit for verifying a given function or method.</p>

<h4 id="11220-timelimitmultiplier-x">11.2.20. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">timeLimitMultiplier</span> <span class="n">X</span><span class="p">}</span></code></h4>
<p>This attribute may be placed on a method or function declaration
and has an integer argument. If <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">timeLimitMultiplier</span> <span class="n">X</span><span class="p">}</span></code> was
specified a <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">timeLimit</span> <span class="n">Y</span><span class="p">}</span></code> attribute is passed on to Boogie
where <code class="language-dafny highlighter-rouge"><span class="n">Y</span></code> is <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> times either the default verification time limit
for a function or method, or times the value specified by the
Boogie <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">timeLimit</span></code> command-line option.</p>

<h4 id="sec-transparent">11.2.21. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">transparent</span><span class="p">}</span></code></h4>

<p>By default, the body of a function is transparent to its users. This can be overridden using the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">default</span><span class="o">-</span><span class="kr">function</span><span class="o">-</span><span class="n">opacity</span></code> command line flag. If default function opacity is set to <code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">autoRevealDependencies</span></code>, then this attribute can be used on functions to make them always non-opaque.</p>

<h4 id="sec-verify">11.2.22. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">verify</span> <span class="kc">false</span><span class="p">}</span></code></h4>

<p>Skip verification of a function or a method altogether,
not even trying to verify the <a href="#sec-assertion-batches">well-formedness</a> of postconditions and preconditions.
We discourage using this attribute and prefer <a href="#sec-axiom"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code></a>,
which performs these minimal checks while not checking that the body satisfies the postconditions.</p>

<p>If you simply want to temporarily disable all verification except on a single function or method, use the <a href="#sec-only-functions-methods"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code></a> attribute on that function or method.</p>

<h4 id="sec-vcs_max_cost">11.2.23. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">vcs_max_cost</span> <span class="n">N</span><span class="p">}</span></code></h4>
<p>Per-method version of the command-line option <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">vcsMaxCost</span></code>.</p>

<p>The <a href="#sec-assertion-batches">assertion batch</a> of a method
will not be split unless the cost of an <a href="#sec-assertion-batches">assertion batch</a> exceeds this
number, defaults to 2000.0. In
<a href="#sec-vcs_max_keep_going_splits">keep-going mode</a>, only applies to the first round.
If <a href="#sec-isolate_assertions"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code></a> is set, then this parameter is useless.</p>

<h4 id="sec-vcs_max_keep_going_splits">11.2.24. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">vcs_max_keep_going_splits</span> <span class="n">N</span><span class="p">}</span></code></h4>

<p>Per-method version of the command-line option <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">vcsMaxKeepGoingSplits</span></code>.
If set to more than 1, activates the <em>keep going mode</em> where, after the first round of splitting,
<a href="#sec-assertion-batches">assertion batches</a> that timed out are split into N <a href="#sec-assertion-batches">assertion batches</a> and retried
until we succeed proving them, or there is only one
single assertion that it timeouts (in which
case an error is reported for that assertion).
Defaults to 1.
If <a href="#sec-isolate_assertions"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code></a> is set, then this parameter is useless.</p>

<h4 id="sec-vcs_max_splits">11.2.25. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">vcs_max_splits</span> <span class="n">N</span><span class="p">}</span></code></h4>

<p>Per-method version of the command-line option <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">vcsMaxSplits</span></code>.
Maximal number of <a href="#sec-assertion-batches">assertion batches</a> generated for this method.
In <a href="#sec-vcs_max_keep_going_splits">keep-going mode</a>, only applies to the first round.
Defaults to 1.
If <a href="#sec-isolate_assertions"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code></a> is set, then this parameter is useless.</p>

<h4 id="sec-isolate_assertions">11.2.26. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code></h4>
<p>Per-method version of the command-line option<span id="sec-vcs_split_on_every_assert"></span> <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">vcsSplitOnEveryAssert</span></code></p>

<p>In the first and only verification round, this option will split the original <a href="#sec-assertion-batches">assertion batch</a>
into one assertion batch per assertion.
This is mostly helpful for debugging which assertion is taking the most time to prove, e.g. to profile them.</p>

<h4 id="sec-synthesize-attr">11.2.27. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">synthesize</span><span class="p">}</span></code></h4>

<p>The <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">synthesize</span><span class="p">}</span></code> attribute must be used on methods that have no body and
return one or more fresh objects. During compilation, 
the postconditions associated with such a
method are translated to a series of API calls to the target languagess
mocking framework. The object returned, therefore, behaves exactly as the
postconditions specify. If there is a possibility that this behavior violates
the specifications on the objects instance methods or hardcodes the values of
its fields, the compiler will throw an error but the compilation will go
through. Currently, this compilation pass is only supported in C# and requires
adding the latest version of the Moq library to the .csproj file before
generating the binary.</p>

<p>Not all Dafny postconditions can be successfully compiled - below is the
grammar for postconditions that are supported (<code class="language-dafny highlighter-rouge"><span class="n">S</span></code> is the start symbol, <code class="language-dafny highlighter-rouge"><span class="n">EXPR</span></code>
stands for an arbitrary Dafny expression, and <code class="language-dafny highlighter-rouge"><span class="n">ID</span></code> stands for
variable/method/type identifiers):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code>S         = FORALL
          | EQUALS
          | S &amp;&amp; S
EQUALS    = ID.ID (ARGLIST) == EXPR // stubs a function call
          | ID.ID           == EXPR // stubs field access
          | EQUALS &amp;&amp; EQUALS
FORALL    = forall BOUNDVARS :: EXPR ==&gt; EQUALS
ARGLIST   = ID   // this can be one of the bound variables
          | EXPR // this expr may not reference any of the bound variables
          | ARGLIST, ARGLIST
BOUNDVARS = ID : ID
          | BOUNDVARS, BOUNDVARS
</code></pre></div></div>

<h4 id="sec-attr-options">11.2.28. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">options</span> <span class="n">OPT0</span><span class="p">,</span> <span class="n">OPT1</span><span class="p">,</span> <span class="o">...</span> <span class="p">}</span></code></h4>

<p>This attribute applies only to modules. It configures Dafny as if
<code class="language-dafny highlighter-rouge"><span class="n">OPT0</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">OPT1</span></code>,  had been passed on the command line.  Outside of the module,
options revert to their previous values.</p>

<p>Only a small subset of Dafnys command line options is supported.  Use the
<code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">attrHelp</span></code> flag to see which ones.</p>

<h3 id="113-attributes-on-reads-and-modifies-clauses">11.3. Attributes on reads and modifies clauses</h3>

<h4 id="1131-assume_concurrent">11.3.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">assume_concurrent</span><span class="p">}</span></code></h4>
<p>This attribute is used to allow non-empty <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clauses on methods
with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">concurrent</span><span class="p">}</span></code> attribute, which would otherwise reject them.</p>

<p>In some cases it is possible to know that Dafny code that reads or writes shared mutable state
is in fact safe to use in a concurrent setting, especially when that state is exclusively ghost.
Since the semantics of <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">concurrent</span><span class="p">}</span></code> arent directly expressible in Dafny syntax,
it isnt possible to express this assumption with an <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span> <span class="o">...</span></code> statement.</p>

<p>See also the <a href="#sec-concurrent-attribute"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">concurrent</span><span class="p">}</span></code></a> attribute.</p>

<h3 id="sec-verification-attributes-on-assertions">11.4. Attributes on assertions, preconditions and postconditions</h3>

<h4 id="sec-only">11.4.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code></h4>

<p><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span> <span class="n">X</span><span class="p">;</span></code> temporarily transforms all other non-<code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code> assertions in the surrounding declaration into assumptions.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Test</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                  <span class="c1">// Unchecked</span>
  <span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span> <span class="kc">true</span> <span class="kr">by</span> <span class="p">{</span>      <span class="c1">// Checked</span>
    <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                <span class="c1">// Checked</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                  <span class="c1">// Unchecked</span>
  <span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span> <span class="s2">"after"</span><span class="p">}</span> <span class="kc">true</span><span class="p">;</span>  <span class="c1">// Checked</span>
  <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                  <span class="c1">// Checked</span>
  <span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span> <span class="s2">"before"</span><span class="p">}</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// Checked</span>
  <span class="kr">assert</span> <span class="kc">true</span><span class="p">;</span>                  <span class="c1">// Unchecked</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code> can help focusing on a particular proof or a particular branch, as it transforms not only other explicit assertions, but also other implicit assertions, and call requirements, into assumptions.
Since its meant to be a temporary construct, it always emits a warning.
It also has two variants <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span> <span class="s2">"before"</span><span class="p">}</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span> <span class="s2">"after"</span><span class="p">}</span></code>.
Here is precisely how Dafny determines what to verify or not.
Each <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code> annotation defines a verification interval which is visual:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span> <span class="n">X</span> <span class="p">[</span><span class="kr">by</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="o">|</span> <span class="p">;]</span></code> sets a verification interval that starts at the keyword <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> and ends either at the end of the proof <code class="language-dafny highlighter-rouge"><span class="p">}</span></code> or the semicolon <code class="language-dafny highlighter-rouge"><span class="p">;</span></code>, depending on which variant of <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> is being used.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span> <span class="o">...</span></code> inside another verification interval removes that verification interval and sets a new one.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span> <span class="s2">"before"</span><span class="p">}</span> <span class="o">...</span></code> inside another verification interval finishes that verification interval earlier at the end of this assertion. Outside a verification interval, it sets a verification interval from the beginning of the declaration to the end of this assertion, but only if there were no other verification intervals before.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span> <span class="s2">"after"</span><span class="p">}</span> <span class="o">...</span></code> inside another verification interval moves the start of that verification interval to the start of this new assert. Outside a verification interval, it sets a verification interval from the beginning of this <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> to the end of the declaration.</li>
</ul>

<p>The start of an asserted expression is used to determines if its inside a verification interval or not.
For example, in <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">B</span> <span class="o">==&gt;</span> <span class="p">(</span><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span> <span class="s2">"after"</span><span class="p">}</span> <span class="kc">true</span><span class="p">;</span> <span class="n">C</span><span class="p">)</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">C</span></code> is actually the start of the asserted expression, so it is verified because its after <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span> <span class="s2">"after"</span><span class="p">}</span> <span class="kc">true</span></code>.</p>

<p>As soon as a declaration contains one <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code>, none of the postconditions are verified; youd need to make them explicit with assertions if you wanted to verify them at the same time.</p>

<p>You can also isolate the verification of a single member using <a href="#sec-only-functions-methods">a similar <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">only</span><span class="p">}</span></code> attribute</a>.</p>

<h4 id="sec-focus">11.4.2. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">focus</span><span class="p">}</span></code></h4>
<p><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">focus</span><span class="p">}</span> <span class="n">X</span><span class="p">;</span></code> splits verification into two <a href="#sec-assertion-batches">assertion batches</a>.
The first batch considers all assertions that are not on the block containing the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">focus</span><span class="p">}</span> <span class="n">X</span><span class="p">;</span></code>
The second batch considers all assertions that are on the block containing the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">focus</span><span class="p">}</span> <span class="n">X</span><span class="p">;</span></code> and those that will <em>always</em> follow afterwards.
Hence, it might also occasionally double-report errors.
If you truly want a split on the batches, prefer <a href="#sec-split_here"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">split_here</span><span class="p">}</span></code></a>.</p>

<p>Here are two examples illustrating how <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">focus</span><span class="p">}</span></code> works, where <code class="language-dafny highlighter-rouge"><span class="o">--</span></code> in the comments stands for <code class="language-dafny highlighter-rouge"><span class="n">Assumption</span></code>:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">doFocus1</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>                     <span class="c1">// Batch 1    Batch 2</span>
  <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>              <span class="c1">// Assertion  --</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="kc">false</span> <span class="p">{</span>
      <span class="kr">assert</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1">// --         Assertion</span>
      <span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">focus</span><span class="p">}</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// --         Assertion</span>
      <span class="n">y</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1">// --         Assertion</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>            <span class="c1">// Assertion  --</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>              <span class="c1">// Assertion  Assertion</span>
  <span class="kr">if</span> <span class="o">!</span><span class="n">x</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span>            <span class="c1">// Assertion  Assertion</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>            <span class="c1">// Assertion  Assertion</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And another one where the focused block is guarded with a <code class="language-dafny highlighter-rouge"><span class="kr">while</span></code>, resulting in remaining assertions not being part of the first assertion batch:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">doFocus2</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>                     <span class="c1">// Batch 1    Batch 2</span>
  <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>              <span class="c1">// Assertion  --</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">{</span>
    <span class="kr">while</span> <span class="kc">false</span> <span class="p">{</span>
      <span class="kr">assert</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1">// --         Assertion</span>
      <span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">focus</span><span class="p">}</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// --         Assertion</span>
      <span class="n">y</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1">// --         Assertion</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>            <span class="c1">// Assertion  --</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>              <span class="c1">// Assertion  --</span>
  <span class="kr">if</span> <span class="o">!</span><span class="n">x</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span>            <span class="c1">// Assertion  --</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>            <span class="c1">// Assertion  --</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="sec-split_here">11.4.3. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">split_here</span><span class="p">}</span></code></h4>
<p><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">split_here</span><span class="p">}</span> <span class="n">X</span><span class="p">;</span></code> splits verification into two <a href="#sec-assertion-batches">assertion batches</a>.
It verifies the code leading to this point (excluded) in a first assertion batch,
and the code leading from this point (included) to the next <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">split_here</span><span class="p">}</span></code> or until the end in a second assertion batch.
It might help with timeouts.</p>

<p>Here is one example, where <code class="language-dafny highlighter-rouge"><span class="o">--</span></code> in the comments stands for <code class="language-dafny highlighter-rouge"><span class="n">Assumption</span></code>:
<!-- %check-verify --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">doSplitHere</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">y</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>                      <span class="c1">// Batch 1    Batch 2     Batch 3</span>
  <span class="kr">assert</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>               <span class="c1">// Assertion  --          --</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>             <span class="c1">// Assertion  --          --</span>
    <span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">split_here</span><span class="p">}</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// --         Assertion   --</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span>             <span class="c1">// --         Assertion   --</span>
    <span class="kr">assert</span> <span class="p">{</span><span class="o">:</span><span class="n">split_here</span><span class="p">}</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// --         --          Assertion</span>
    <span class="kr">if</span> <span class="n">x</span> <span class="p">{</span>
      <span class="kr">assert</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>           <span class="c1">// --         --          Assertion</span>
    <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
      <span class="kr">assert</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span>           <span class="c1">// --         --          Assertion</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">;</span>             <span class="c1">// Assertion  --          --</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>              <span class="c1">// Assertion  --          --</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="1144-subsumption-n">11.4.4. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">subsumption</span> <span class="n">n</span><span class="p">}</span></code></h4>
<p>Overrides the <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">subsumption</span></code> command-line setting for this assertion.
<code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">subsumption</span> <span class="mi">0</span><span class="p">}</span></code> checks an assertion but does not assume it after proving it.
You can achieve the same effect using <a href="#sec-labeling-revealing-assertions">labelled assertions</a>.</p>

<h4 id="sec-error-attribute">11.4.5. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">error</span> <span class="s2">"errorMessage"</span><span class="p">,</span> <span class="s2">"successMessage"</span><span class="p">}</span></code></h4>
<p>Provides a custom error message in case the assertion fails.
As a hint, messages indicating what the user needs to do to fix the error are usually better than messages that indicate the error only.
For example:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Process</span><span class="p">(</span><span class="n">instances</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">price</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="p">{</span><span class="o">:</span><span class="n">error</span> <span class="s2">"There should be an even number of instances"</span><span class="p">,</span> <span class="s2">"The number of instances is always even"</span><span class="p">}</span> <span class="n">instances</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="kr">requires</span> <span class="p">{</span><span class="o">:</span><span class="n">error</span> <span class="s2">"Could not prove that the price is positive"</span><span class="p">,</span> <span class="s2">"The price is always positive"</span><span class="p">}</span> <span class="n">price</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="kr">method</span> <span class="n">Test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="o">*</span> <span class="p">{</span>
    <span class="n">Process</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Error: There should be an even number of instances</span>
  <span class="p">}</span>
  <span class="kr">if</span> <span class="o">*</span> <span class="p">{</span>
    <span class="n">Process</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Error: Could not prove that the price is positive</span>
  <span class="p">}</span>
  <span class="kr">if</span> <span class="o">*</span> <span class="p">{</span>
    <span class="n">Process</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// Success: The number of instances is always even</span>
                   <span class="c1">// Success: The price is always positive</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The success message is optional but is recommended if errorMessage is set.</p>

<h4 id="1146-contradiction">11.4.6. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">contradiction</span><span class="p">}</span></code></h4>

<p>Silences warnings about this assertion being involved in a proof using contradictory assumptions when <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">warn</span><span class="o">-</span><span class="n">contradictory</span><span class="o">-</span><span class="n">assumptions</span></code> is enabled. This allows clear identification of intentional proofs by contradiction.</p>

<h3 id="115-attributes-on-variable-declarations">11.5. Attributes on variable declarations</h3>

<h4 id="sec-assumption">11.5.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">assumption</span><span class="p">}</span></code></h4>
<p>This attribute can only be placed on a local ghost bool
variable of a method. Its declaration cannot have a rhs, but it is
allowed to participate as the lhs of exactly one assignment of the
form: <code class="language-dafny highlighter-rouge"><span class="n">b</span> <span class="o">:=</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">expr</span><span class="p">;</span></code>. Such a variable declaration translates in the
Boogie output to a declaration followed by an <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="n">b</span></code> command.
See [@LeinoWuestholz2015], Section 3, for example uses of the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">assumption</span><span class="p">}</span></code>
attribute in Boogie.</p>

<h3 id="116-attributes-on-quantifier-expressions-forall-exists">11.6. Attributes on quantifier expressions (forall, exists)</h3>

<h4 id="1161-heapquantifier">11.6.1. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">heapQuantifier</span><span class="p">}</span></code></h4>

<p><em>This attribute has been removed.</em></p>

<h4 id="sec-induction-quantifier">11.6.2. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code></h4>
<p>See <a href="#sec-induction"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">induction</span><span class="p">}</span></code></a> for functions and methods.</p>

<h4 id="sec-trigger">11.6.3. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span><span class="p">}</span></code></h4>
<p>Trigger attributes are used on quantifiers and comprehensions.</p>

<p>The verifier instantiates the body of a quantified expression only when it can find an expression that matches the provided trigger.</p>

<p>Here is an example:
<!-- %check-verify Attributes.3.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="kr">predicate</span> <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>

<span class="kr">lemma</span> <span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span> <span class="n">PHoldEvenly</span><span class="p">()</span>
  <span class="kr">ensures</span>  <span class="kr">forall</span> <span class="n">i</span> <span class="p">{</span><span class="o">:</span><span class="n">trigger</span> <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="kr">lemma</span> <span class="n">PHoldsForTwo</span><span class="p">()</span>
  <span class="kr">ensures</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">forall</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span>
    <span class="kr">ensures</span> <span class="n">P</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">P</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kr">if</span> <span class="n">P</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="c1">// Trivial assertion</span>
      
      <span class="n">PHoldEvenly</span><span class="p">();</span>
      <span class="c1">// Invoking the lemma assumes `forall i :: P(i) ==&gt; P(i + 4)`,</span>
      <span class="c1">// but it's not instantiated yet</span>
      
      <span class="c1">// The verifier sees `Q(j)`, so it instantiates</span>
      <span class="c1">// `forall i :: P(i) ==&gt; P(i + 4)` with `j`</span>
      <span class="c1">// and we get the axiom `P(j) ==&gt; P(j + 2) &amp;&amp; Q(j)`</span>
      <span class="kr">assert</span> <span class="n">Q</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>     <span class="c1">// hence it can prove `Q(j)`</span>
      <span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//   and it can prove `P(j + 2)`</span>
      <span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// But it cannot prove this</span>
      <span class="c1">// because it did not instantiate `forall i :: P(i) ==&gt; P(i + 4)` with `j+2`</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are ways one can prove <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span></code>:</p>
<ul>
  <li>Add <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">Q</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span></code> just before <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span></code>, so that the verifier sees the trigger.</li>
  <li>Change the trigger <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span> <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span></code> to <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span></code> (replace the trigger)</li>
  <li>Change the trigger <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span> <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span></code> to <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span> <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span> <span class="p">{</span><span class="o">:</span><span class="n">trigger</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span></code> (add a trigger)</li>
  <li>Remove <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span> <span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span></code> so that it will automatically determine all possible triggers thanks to the option <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">autoTriggers</span><span class="o">:</span><span class="mi">1</span></code> which is the default.</li>
</ul>

<h3 id="117-deprecated-attributes">11.7. Deprecated attributes</h3>

<p>These attributes have been deprecated or removed. They are no longer useful (or perhaps never were) or were experimental.
They will likely be removed entirely sometime soon after the release of Dafny 4.</p>

<p>Removed:</p>
<ul>
  <li>:heapQuantifier</li>
  <li>:dllimport</li>
  <li>:handle</li>
</ul>

<p>Deprecated:</p>
<ul>
  <li>:opaque : This attribute has been promoted to a first-class modifier for functions. Find more information <a href="#sec-opaque">here</a>.</li>
</ul>

<h3 id="118-other-undocumented-verification-attributes">11.8. Other undocumented verification attributes</h3>

<p>A scan of Dafnys sources shows it checks for the
following attributes.</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="err">$</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="err">$</span><span class="n">renamed</span><span class="err">$</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">InlineAssume</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">PossiblyUnreachable</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="err">__</span><span class="n">dominator_enabled</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="err">__</span><span class="n">enabled</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">a</span><span class="err">##</span><span class="n">post</span><span class="err">##</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">absdomain</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">ah</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">assumption</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">assumption_variable_initialization</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">atomic</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">aux</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">both</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">bvbuiltin</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">candidate</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">captureState</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">checksum</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="kr">constructor</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="kr">datatype</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">do_not_predicate</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">entrypoint</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">existential</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">exitAssert</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">expand</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">focus</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">hidden</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">ignore</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">inline</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">left</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">linear</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">linear_in</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">linear_out</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">msg</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">name</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">originated_from_invariant</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">partition</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">positive</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">post</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">pre</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">precondition_previous_snapshot</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">qid</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">right</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">selective_checking</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">si_fcall</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">si_unique_call</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">sourcefile</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">sourceline</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">split_here</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">stage_active</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">stage_complete</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">staged_houdini_tag</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">start_checking_here</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">subsumption</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">template</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">terminates</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">upper</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">verified_under</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">weight</span><span class="p">}</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="kr">yields</span><span class="p">}</span></code></li>
</ul>

<h3 id="sec-at-attributes">11.9. New attribute syntax</h3>

<p>There is a new syntax for typed prefix attributes that is being added: <code class="language-dafny highlighter-rouge"><span class="err">@</span><span class="n">Attribute</span><span class="p">(</span><span class="o">...</span><span class="p">)</span></code>.
For now, the new syntax works only as top-level declarations. When all previous attributes will be migrated, this section will be rewritten. For example, you can write</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="err">@</span><span class="n">IsolateAssertions</span>
<span class="kr">method</span> <span class="n">Test</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>instead of</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span> <span class="n">Test</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dafny rewrites <code class="language-dafny highlighter-rouge"><span class="err">@</span></code>-attributes to old-style equivalent attributes. The definition of these attributes is similar to the following:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">Attribute</span> <span class="o">=</span>
  <span class="o">|</span> <span class="n">AutoContracts</span>
  <span class="o">|</span> <span class="n">AutoRequires</span>
  <span class="o">|</span> <span class="n">AutoRevealDependenciesAll</span>
  <span class="o">|</span> <span class="n">AutoRevealDependencies</span>
  <span class="o">|</span> <span class="n">Axiom</span>
  <span class="o">|</span> <span class="n">Compile</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">Concurrent</span>
  <span class="o">|</span> <span class="n">DisableNonlinearArithmetic</span>
  <span class="o">|</span> <span class="n">Fuel</span><span class="p">(</span><span class="n">low</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">high</span><span class="o">:</span> <span class="kt">int</span> <span class="o">:=</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">functionName</span><span class="o">:</span> <span class="kt">string</span> <span class="o">:=</span> <span class="s2">""</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">IsolateAssertions</span>
  <span class="o">|</span> <span class="n">NativeUInt8</span> <span class="o">|</span> <span class="n">NativeInt8</span> <span class="o">...</span> <span class="o">|</span> <span class="n">NativeUInt128</span> <span class="o">|</span> <span class="n">NativeInt128</span> <span class="o">|</span> <span class="n">NativeInt</span> <span class="o">|</span> <span class="n">NativeNone</span> <span class="o">|</span> <span class="n">NativeIntOrReal</span>
  <span class="o">|</span> <span class="n">Options</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">Print</span>
  <span class="o">|</span> <span class="n">Priority</span><span class="p">(</span><span class="n">weight</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">ResourceLimit</span><span class="p">(</span><span class="n">value</span><span class="o">:</span> <span class="kt">string</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">Synthesize</span>
  <span class="o">|</span> <span class="n">TimeLimit</span><span class="p">(</span><span class="n">amount</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">TimeLimitMultiplier</span><span class="p">(</span><span class="n">multiplier</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">TailRecursion</span>
  <span class="o">|</span> <span class="n">Test</span>
  <span class="o">|</span> <span class="n">TestEntry</span>
  <span class="o">|</span> <span class="n">TestInline</span><span class="p">(</span><span class="n">amount</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">Transparent</span>
  <span class="o">|</span> <span class="n">VcsMaxCost</span>
  <span class="o">|</span> <span class="n">VcsMaxKeepGoingSplits</span>
  <span class="o">|</span> <span class="n">VcsMaxSplits</span>
  <span class="o">|</span> <span class="n">Verify</span><span class="p">(</span><span class="n">verify</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">VerifyOnly</span>
  
</code></pre></div></div>

<p>@-attributes have the same checks as regular resolved datatype values</p>
<ul>
  <li>The attribute should exist</li>
  <li>Arguments should be compatible with the parameters, like for a datatype constructor call</li>
</ul>

<p>However, @-attributes have more checks:</p>
<ul>
  <li>The attribute should be applied to a place where it can be used by Dafny</li>
  <li>Arguments should be literals</li>
</ul>

<!--PDF NEWPAGE-->
<h2 id="sec-advanced-topics">12. Advanced Topics</h2>

<h3 id="sec-type-parameter-completion">12.1. Type Parameter Completion</h3>

<p>Generic types, like <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span></code>, consist of a <em>type constructor</em>, here <code class="language-dafny highlighter-rouge"><span class="n">A</span></code>, and type parameters, here <code class="language-dafny highlighter-rouge"><span class="n">T</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">U</span></code>.
Type constructors are not first-class entities in Dafny, they are always used syntactically to construct
type names; to do so, they must have the requisite number of type parameters, which must be either concrete types, type parameters, or 
a generic type instance.</p>

<p>However, those type parameters do not always have to be explicit; Dafny can often infer what they ought to be.
For example, here is a fully parameterized function signature:
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kr">function</span> <span class="n">Elements</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="o">:</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>However, Dafny also accepts
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kr">function</span> <span class="n">Elements</span><span class="p">(</span><span class="n">list</span><span class="o">:</span> <span class="n">List</span><span class="p">)</span><span class="o">:</span> <span class="kt">set</span>
</code></pre></div></div>
<p>In the latter case, Dafny knows that the already defined types <code class="language-dafny highlighter-rouge"><span class="kt">set</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">List</span></code> each take one type parameter
so it fills in <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> (using some unique type parameter name) and then determines that the function itself needs
a type parameter <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code> as well.</p>

<p>Dafny also accepts
<!-- %check-resolve --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="kr">function</span> <span class="n">Elements</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="o">:</span> <span class="n">List</span><span class="p">)</span><span class="o">:</span> <span class="kt">set</span>
</code></pre></div></div>
<p>In this case, the function already has a type parameter list. <code class="language-dafny highlighter-rouge"><span class="n">List</span></code> and <code class="language-dafny highlighter-rouge"><span class="kt">set</span></code> are each known to need type parameters,
so Dafny takes the first <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> parameters from the function signature and applies them to <code class="language-dafny highlighter-rouge"><span class="n">List</span></code> and <code class="language-dafny highlighter-rouge"><span class="kt">set</span></code>, where <code class="language-dafny highlighter-rouge"><span class="n">n</span></code> (here <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code>) is the
number needed by those type constructors.</p>

<p>It never hurts to simply write in all the type parameters, but that can reduce readability.
Omitting them in cases where Dafny can intuit them makes a more compact definition.</p>

<p>This process is described in more detail with more examples in this paper:
<a href="http://leino.science/papers/krml270.html">http://leino.science/papers/krml270.html</a>.</p>

<h3 id="sec-type-inference">12.2. Type Inference</h3>

<p>Signatures of methods, functions, fields (except <code class="language-dafny highlighter-rouge"><span class="kr">const</span></code> fields with a
RHS), and datatype constructors have to declare the types of their
parameters. In other places, types can be omitted, in which case
Dafny attempts to infer them. Type inference is best effort and may
fail. If it fails to infer a type, the remedy is simply for the
program to give the type explicitly.</p>

<p>Despite being just best effort, the types of most local variables,
bound variables, and the type parameters of calls are usually inferred
without the need for a program to give the types explicitly. Here are
some notes about type inference:</p>

<ul>
  <li>With some exceptions, type inference is performed across a whole
method body. In some cases, the information needed to infer a local
variables type may be found after the variable has been declared
and used. For example, the nonsensical program</li>
</ul>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">```</span><span class="n">dafny</span>
<span class="kr">method</span> <span class="n">M</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="n">n</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="n">a</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">y</span> <span class="o">:=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">```</span>
</code></pre></div></div>

<p>uses <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">b</span></code> after their declarations. Still, their types are
  inferred to be <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>, because of the presence of the assignment <code class="language-dafny highlighter-rouge"><span class="n">y</span> <span class="o">:=</span> <span class="n">a</span><span class="p">;</span></code>.</p>

<p>A more useful example is this:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">```</span><span class="n">dafny</span>
<span class="kr">class</span> <span class="n">Cell</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">data</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">LastFive</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">u</span> <span class="o">:=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="kr">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="kr">to</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">{</span>
      <span class="n">u</span> <span class="o">:=</span> <span class="kr">new</span> <span class="n">Cell</span><span class="p">;</span>
      <span class="n">u</span><span class="o">.</span><span class="n">data</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">r</span> <span class="o">:=</span> <span class="kr">if</span> <span class="n">u</span> <span class="o">==</span> <span class="kc">null</span> <span class="kr">then</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span> <span class="kr">else</span> <span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">```</span>
</code></pre></div></div>

<p>Here, using only the assignment <code class="language-dafny highlighter-rouge"><span class="n">u</span> <span class="o">:=</span> <span class="kc">null</span><span class="p">;</span></code> to infer the type of
  <code class="language-dafny highlighter-rouge"><span class="n">u</span></code> would not be helpful. But Dafny looks past the initial
  assignment and infers the type of <code class="language-dafny highlighter-rouge"><span class="n">u</span></code> to be <code class="language-dafny highlighter-rouge"><span class="n">Cell?</span></code>.</p>

<ul>
  <li>The primary example where type inference does not inspect the entire
context before giving up on inference is when there is a member
lookup. For example,</li>
</ul>

<!-- %check-resolve Topics.1.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">```</span><span class="n">dafny</span>
<span class="kr">datatype</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Nil</span> <span class="o">|</span> <span class="n">Cons</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>

<span class="kr">method</span> <span class="n">Tutone</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="kr">forall</span> <span class="n">pair</span> <span class="o">::</span> <span class="n">pair</span><span class="o">.</span><span class="mi">0</span> <span class="o">==</span> <span class="mi">867</span> <span class="o">&amp;&amp;</span> <span class="n">pair</span><span class="o">.</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">5309</span> <span class="o">==&gt;</span> <span class="n">pair</span> <span class="o">==</span> <span class="p">(</span><span class="mi">867</span><span class="p">,</span> <span class="mi">5309</span><span class="p">);</span> <span class="c1">// error: members .0 and .1 not found</span>
  <span class="kr">assert</span> <span class="kr">forall</span> <span class="n">pair</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">::</span> <span class="n">pair</span><span class="o">.</span><span class="mi">0</span> <span class="o">==</span> <span class="mi">867</span> <span class="o">&amp;&amp;</span> <span class="n">pair</span><span class="o">.</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">5309</span> <span class="o">==&gt;</span> <span class="n">pair</span> <span class="o">==</span> <span class="p">(</span><span class="mi">867</span><span class="p">,</span> <span class="mi">5309</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">```</span>
</code></pre></div></div>

<p>In the first quantifier, type inference fails to infer the type of
  <code class="language-dafny highlighter-rouge"><span class="n">pair</span></code> before it tries to look up the members <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="mi">0</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="mi">1</span></code>, which
  results in a type of the receiver not fully determined error. The
  remedy is to provide the type of <code class="language-dafny highlighter-rouge"><span class="n">pair</span></code> explicitly, as is done in the
  second quantifier.</p>

<p>(In the future, Dafny may do more type inference before giving up on the member lookup.)</p>

<ul>
  <li>If type parameters cannot be inferred, then they can be given
explicitly in angle brackets. For example, in</li>
</ul>

<!-- %check-resolve Topics.2.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">```</span><span class="n">dafny</span>
<span class="kr">datatype</span> <span class="n">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">None</span> <span class="o">|</span> <span class="n">Some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

<span class="kr">method</span> <span class="n">M</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">a</span><span class="o">:</span> <span class="n">Option</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="n">None</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">None</span><span class="p">;</span> <span class="c1">// error: type is underspecified</span>
  <span class="kr">var</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">Option</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;.</span><span class="n">None</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">None</span><span class="p">;</span>
  <span class="n">d</span> <span class="o">:=</span> <span class="n">Some</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">```</span>
</code></pre></div></div>

<p>the type of <code class="language-dafny highlighter-rouge"><span class="n">b</span></code> cannot be inferred, because it is underspecified.
  However, the types of <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">d</span></code> are inferred to be <code class="language-dafny highlighter-rouge"><span class="n">Option</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code>.</p>

<p>Here is another example:</p>

<!-- %check-resolve Topics.3.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">```</span><span class="n">dafny</span>
<span class="kr">function</span> <span class="n">EmptySet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">{}</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">M</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">EmptySet</span><span class="p">();</span> <span class="c1">// error: type is underspecified</span>
  <span class="kr">var</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">EmptySet</span><span class="p">();</span>
  <span class="n">b</span> <span class="o">:=</span> <span class="n">b</span> <span class="o">+</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="kr">var</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">EmptySet</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">```</span>
</code></pre></div></div>

<p>The type instantiation in the initial assignment to <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> cannot
  be inferred, because it is underspecified. However, the type
  instantiation in the initial assignment to <code class="language-dafny highlighter-rouge"><span class="n">b</span></code> is inferred to
  be <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>, and the types of <code class="language-dafny highlighter-rouge"><span class="n">b</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> are inferred to be
  <code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code>.</p>

<ul>
  <li>Even the element type of <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> is optional, if it can be inferred. For example, in</li>
</ul>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">```</span><span class="n">dafny</span>
<span class="kr">method</span> <span class="n">NewArrays</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">a</span> <span class="o">:=</span> <span class="kr">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kr">var</span> <span class="n">b</span><span class="o">:</span> <span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="kr">new</span> <span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kr">var</span> <span class="n">c</span> <span class="o">:=</span> <span class="kr">new</span> <span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">d</span> <span class="o">:=</span> <span class="kr">new</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">77</span><span class="p">];</span>
  <span class="kr">var</span> <span class="n">e</span> <span class="o">:=</span> <span class="kr">new</span> <span class="p">[]</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">77</span><span class="p">];</span>
  <span class="kr">var</span> <span class="n">f</span> <span class="o">:=</span> <span class="kr">new</span> <span class="p">[</span><span class="mi">3</span><span class="p">](</span><span class="n">_</span> <span class="o">=&gt;</span> <span class="mi">990</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">```</span>
</code></pre></div></div>

<p>the omitted types of local variables are all inferred as
  <code class="language-dafny highlighter-rouge"><span class="kt">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span></code> and the omitted element type of each <code class="language-dafny highlighter-rouge"><span class="kr">new</span></code> is inferred
  to be <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>.</p>

<ul>
  <li>
    <p>In the absence of any other information, integer-looking literals
(like <code class="language-dafny highlighter-rouge"><span class="mi">5</span></code> and <code class="language-dafny highlighter-rouge"><span class="mi">7</span></code>) are inferred to have type <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> (and not, say,
<code class="language-dafny highlighter-rouge"><span class="kt">bv128</span></code> or <code class="language-dafny highlighter-rouge"><span class="kt">ORDINAL</span></code>).</p>
  </li>
  <li>
    <p>Many of the types inferred can be inspected in the IDE.</p>
  </li>
</ul>

<h3 id="sec-ghost-inference">12.3. Ghost Inference</h3>

<p>After<sup id="fnref:why-after-type-inference" role="doc-noteref"><a href="#fn:why-after-type-inference" class="footnote" rel="footnote">14</a></sup> <a href="#sec-type-inference">type inference</a>, Dafny revisits the program
and makes a final decision about which statements are to be compiled,
and which statements are ghost.
The ghost statements form what is called the <em>ghost context</em> of expressions.</p>

<p>These statements are determined to be ghost:</p>

<ul>
  <li><a href="#sec-assert-statement"><code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code></a>, <a href="#sec-assume-statement"><code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code></a>, <a href="#sec-reveal-statement"><code class="language-dafny highlighter-rouge"><span class="kr">reveal</span></code></a>, and <a href="#sec-calc-statement"><code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code></a> statements.</li>
  <li>The body of the <code class="language-dafny highlighter-rouge"><span class="kr">by</span></code> of an <a href="#sec-assert-statement"><code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code></a> statement.</li>
  <li>Calls to ghost methods, including <a href="#sec-lemmas">lemmas</a>.</li>
  <li><a href="#sec-if-statement"><code class="language-dafny highlighter-rouge"><span class="kr">if</span></code></a>, <a href="#sec-match-statement"><code class="language-dafny highlighter-rouge"><span class="kr">match</span></code></a>, and <a href="#sec-while-statement"><code class="language-dafny highlighter-rouge"><span class="kr">while</span></code></a> statements with condition expressions or alternatives containing ghost expressions. Their bodies are also ghost.</li>
  <li><a href="#sec-for-statement"><code class="language-dafny highlighter-rouge"><span class="kr">for</span></code></a> loops whose start expression contains ghost expressions.</li>
  <li><a href="#sec-variable-declaration-statement">Variable declarations</a> if they are explicitly ghost or if their respective right-hand side is a ghost expression.</li>
  <li><a href="#sec-update-and-call-statement">Assignments or update statement</a> if all updated variables are ghost.</li>
  <li><a href="#sec-forall-statement"><code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code></a> statements, unless there is exactly one assignment to a non-ghost array in its body.</li>
</ul>

<p>These statements always non-ghost:</p>

<ul>
  <li><a href="#sec-expect-statement"><code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code></a> statements.</li>
  <li><a href="#sec-print-statement"><code class="language-dafny highlighter-rouge"><span class="kr">print</span></code></a> statements.</li>
</ul>

<p>The following expressions are ghost, which is used in some of the tests above:</p>

<ul>
  <li>All <a href="#sec-list-of-specification-expressions">specification expressions</a></li>
  <li>All calls to functions and predicates marked as <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code></li>
  <li>All variables, <a href="#sec-constant-field-declaration">constants</a> and <a href="#sec-field-declaration">fields</a> declared using the <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span></code> keyword</li>
</ul>

<p>Note that inferring ghostness can uncover other errors, such as updating non-ghost variables in ghost contexts.
For example, if <code class="language-dafny highlighter-rouge"><span class="n">f</span></code> is a ghost function, in the presence of the following code:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">if</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dafny will infer that the entire <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> is ghost because the condition uses a ghost function,
and will then raise the error that its not possible to update the non-ghost variable <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> in a ghost context.</p>

<h3 id="sec-extreme">12.4. Well-founded Functions and Extreme Predicates</h3>

<p>Recursive functions are a core part of computer science and mathematics.
Roughly speaking, when the definition of such a function spells out a
terminating computation from given arguments, we may refer to
it as a <em>well-founded function</em>.  For example, the common factorial and
Fibonacci functions are well-founded functions.</p>

<p>There are also other ways to define functions.  An important case
regards the definition of a boolean function as an extreme solution
(that is, a least or greatest solution) to some equation.  For
computer scientists with interests in logic or programming languages,
these <em>extreme predicates</em> are important because they describe the
judgments that can be justified by a given set of inference rules
(see, e.g., [@CamilleriMelham:InductiveRelations;
@Winskel:FormalSemantics;
  @LeroyGrall:CoinductiveBigStep; @Pierce:SoftwareFoundations;
  @NipkowKlein:ConcreteSemantics]).</p>

<p>To benefit from machine-assisted reasoning, it is necessary not just
to understand extreme predicates but also to have techniques for
proving theorems about them.  A foundation for this reasoning was
developed by Paulin-Mohring [@PaulinMohring:InductiveCoq] and is the
basis of the constructive logic supported by Coq [@Coq:book] as well
as other proof assistants [@BoveDybjerNorell:BriefAgda;
@SwamyEtAl:Fstar2011].  Essentially, the idea is to represent the
knowledge that an extreme predicate holds by the proof term by which
this knowledge was derived.  For a predicate defined as the least
solution, such proof terms are values of an inductive datatype (that
is, finite proof trees), and for the greatest solution, a coinductive
datatype (that is, possibly infinite proof trees).  This means that
one can use induction and coinduction when reasoning about these proof
trees.  These extreme predicates are known as,
respectively, <em>least predicates</em> and <em>greatest predicates</em>.
Support for extreme predicates is also
available in the proof assistants Isabelle [@Paulson:CADE1994] and HOL
[@Harrison:InductiveDefs].</p>

<p>Dafny supports both well-founded functions and extreme predicates.
This section describes the difference in general
terms, and then describes novel syntactic support in Dafny for
defining and proving lemmas with extreme predicates.  Although Dafnys
verifier has at its core a first-order SMT solver, Dafnys logical
encoding makes it possible to reason about fixpoints in an automated
way.</p>

<p>The encoding for greatest predicates in Dafny was described previously
[@LeinoMoskal:Coinduction] and is here described in <a href="#sec-coinductive-datatypes">the section about datatypes</a>.</p>

<h4 id="1241-function-definitions">12.4.1. Function Definitions</h4>

<p>To define a function $f \colon X \to Y$ in terms of itself, one can
write a general equation like</p>

<p style="text-align: center;" id="eq-general">
$$f = \mathcal{F}(f)$$
</p>

<p>where $\mathcal{F}$ is a non-recursive function of type
$(X \to Y) \to X \to Y$.
Because it takes a function as an argument,
$\mathcal{F}$
is referred to as a <em>functor</em> (or <em>functional</em>, but not to be
confused by the category-theory notion of a functor).
Throughout, assume that
$\mathcal{F}(f)$
by itself is well defined,
for example that it does not divide by zero.  Also assume that
$f$
occurs
only in fully applied calls in
$\mathcal{F}(f)$;
 eta expansion can be applied to
ensure this.  If
$f$
is a <code class="language-dafny highlighter-rouge"><span class="n">boolean</span></code> function, that is, if
$Y$
is
the type of booleans, then 
$f$ is called
a <em>predicate</em>.</p>

<p>For example, the common Fibonacci function over the
natural numbers can be defined by the equation</p>
<p style="text-align: center;">
$$
\mathit{fib} = \lambda n \bullet\: \mathbf{if}\:n &lt; 2 \:\mathbf{then}\: n \:\mathbf{else}\: \mathit{fib}(n-2) + \mathit{fib}(n-1)
$$
</p>

<p>With the understanding that the argument $n$ is universally
quantified, we can write this equation equivalently as</p>

<p style="text-align: center;" id="eq-fib">
$$
\mathit{fib}(n) = \mathbf{if}\:n &lt; 2\:\mathbf{then}\:n\:\mathbf{else}\:\mathit{fib}(n-2)%2B\mathit{fib}(n-1)
$$
</p>

<p>The fact that the function being defined occurs on both sides of the equation
causes concern that we might not be defining the function properly, leading to a
logical inconsistency.  In general, there
could be many solutions to an equation like <a href="#eq-general">the general equation</a> or there could be none.
Lets consider two ways to make sure were defining the function uniquely.</p>

<h5 id="12411-well-founded-functions">12.4.1.1. Well-founded Functions</h5>

<p>A standard way to ensure that <a href="#eq-general">the general equation</a> has a unique solution in $f$ is
to make sure the recursion is well-founded, which roughly means that the
recursion terminates.  This is done by introducing any well-founded
relation $\ll$ on the domain of $f$ and making sure that the argument to each recursive
call goes down in this ordering.  More precisely, if we formulate <a href="#eq-general">the general equation</a> as</p>
<p style="text-align: center;">
$$
f(x) = \mathcal{F}{'}(f)
$$
</p>

<p>then we want to check $E \ll x$ for each call $f(E)$ in $f(x) = \mathcal{F}(f)$.
When a function
definition satisfies  this <em>decrement condition</em>, then the function is said to be
<em>well-founded</em>.</p>

<p>For example, to check the decrement condition for $\mathit{fib}$
in <a href="#eq-fib">the fib equation</a>, we can pick $\ll$
to be the arithmetic less-than relation on natural numbers and check the
following, for any $n$:</p>
<p style="text-align: center;"> $$ 2 \leq n \;\Longrightarrow\; n-2 \ll n \;\wedge\; n-1 \ll n $$
</p>

<p>Note that we are entitled to use the antecedent
$2 \leq n$ because that is the
condition under which the else branch in <a href="#eq-fib">the fib equation</a> is evaluated.</p>

<p>A well-founded function is often thought of as terminating in the sense
that the recursive <em>depth</em> in evaluating $f$
on any given argument is finite.  That is, there are no infinite descending chains
of recursive calls.  However, the evaluation of $f$ on a given argument
may fail to terminate, because its <em>width</em> may be infinite.  For example, let $P$
be some predicate defined on the ordinals and let $\mathit{P}_\downarrow$ be a predicate on the
ordinals defined by the following equation:</p>

<p style="text-align: center;">
$\mathit{P}_\downarrow = P(o) \;\wedge\; \forall p \bullet\; p \ll o \;\Longrightarrow\; \mathit{P}_\downarrow(p)$
</p>

<p>With $\ll$ as the usual ordering on ordinals, this equation satisfies the decrement
condition, but evaluating $\mathit{P}_\downarrow(\omega)$ would require evaluating
$\mathit{P}_\downarrow(n)$ for every natural number $n$.  However, what we are concerned
about here is to avoid mathematical inconsistencies, and that is
indeed a consequence of the decrement condition.</p>

<h5 id="sec-fib-example">12.4.1.2. Example with Well-founded Functions</h5>

<p>So that we can later see how inductive proofs are done in Dafny, lets prove that
for any $n$, $\mathit{fib}(n)$ is even iff $n$ is a multiple of $3$.
We split our task into
two cases.  If $n &lt; 2$, then the property follows directly from the definition
of $\mathit{fib}$.  Otherwise, note that exactly one of the three numbers $n-2$, $n-1$, and $n$
is a multiple of 3.  If $n$ is the multiple of 3, then by invoking the
induction hypothesis on $n-2$
and $n-1$, we obtain that $\mathit{fib}(n-2) + \mathit{fib}(n-1)$ is the sum of two odd numbers,
which is even.  If $n-2$ or $n-1$ is a multiple of 3, then by invoking the induction
hypothesis on $n-2$ and $n-1$, we obtain that $\mathit{fib}(n-2) + \mathit{fib}(n-1)$ is the sum of an
even number and an odd number, which is odd.  In this proof, we invoked the induction
hypothesis on $n-2$ and on $n-1$.  This is allowed, because both are smaller than
$n$, and hence the invocations go down in the well-founded ordering on natural numbers.</p>

<h5 id="12413-extreme-solutions">12.4.1.3. Extreme Solutions</h5>

<p>We dont need to exclude the possibility of <a href="#eq-general">the general equation</a> having multiple
solutionsinstead, we can just be clear about which one of them we want.
Lets explore this, after a smidgen of lattice theory.</p>

<p>For any complete lattice $(Y,\leq)$ and any set $X$, we can by <em>pointwise extension</em> define
a complete lattice $(X \to Y, \dot{\Rightarrow})$, where for any $f,g \colon X \to Y$,</p>

<p style="text-align: center;">
$$
f \dot{\Rightarrow} g  \;\;\equiv\;\; \forall x \bullet\; f(x) \leq g(x)
$$
</p>

<p>In particular, if $Y$ is the set of booleans ordered by implication (<code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> $\leq$ <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>),
then the set of predicates over any domain $X$ forms a complete lattice.
Tarskis Theorem [@Tarski:theorem] tells us that any monotonic function over a
complete lattice has a least and a greatest fixpoint.  In particular, this means that
$\mathcal{F}$ has a least fixpoint and a greatest fixpoint, provided $\mathcal{F}$ is monotonic.</p>

<p>Speaking about the <em>set of solutions</em> in $f$ to <a href="#eq-general">the general equation</a> is the same as speaking
about the <em>set of fixpoints</em> of functor $\mathcal{F}$.  In particular, the least and greatest
solutions to <a href="#eq-general">the general equation</a> are the same as the least and greatest fixpoints of $\mathcal{F}$.
In casual speak, it happens that we say fixpoint of <a href="#eq-general">the general equation</a>, or more
grotesquely, fixpoint of $f$ when we really mean fixpoint of $\mathcal{F}$.</p>

<p>To conclude our little excursion into lattice theory, we have that, under the
proviso of $\mathcal{F}$ being monotonic, the set of solutions in $f$ to <a href="#eq-general">the general equation</a> is nonempty,
and among these solutions, there is in the $\dot{\Rightarrow}$ ordering a least solution (that is,
a function that returns <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> more often than any other) and a greatest solution (that
is, a function that returns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> more often than any other).</p>

<p>When discussing extreme solutions, lets now restrict our attention to boolean functions
(that is, with $Y$ being the type of booleans).  Functor $\mathcal{F}$ is monotonic
if the calls to $f$ in $\mathcal{F}(f)$ are in <em>positive positions</em> (that is, under an even number
of negations).  Indeed, from now on, we will restrict our attention to such monotonic
functors $\mathcal{F}$.</p>

<p>Here is a running example.  Consider the following equation,
where $x$ ranges over the integers:</p>

<p style="text-align: center;" id="eq-EvenNat" title="the EvenNat equation">
$$
g(x) = (x = 0 \:\vee\: g(x-2))
$$
</p>

<p>This equation has four solutions in $g$.  With $w$ ranging over the integers, they are:</p>

<p style="text-align: center;">
$$
 \begin{array}{r@{}l}
  g(x) \;\;\equiv\;\;{}&amp;  x \in \{w \;|\; 0 \leq w \;\wedge\; w\textrm{ even}\} \\
  g(x) \;\;\equiv\;\;{}&amp;  x \in \{w \;|\; w\textrm{ even}\} \\
  g(x) \;\;\equiv\;\;{}&amp;  x \in \{w \;|\; (0 \leq w \;\wedge\; w\textrm{ even}) \:\vee\: w\textrm{ odd}\} \\
  g(x) \;\;\equiv\;\;{}&amp;  x \in \{w \;|\; \mathit{true}\}
  \end{array}
$$
</p>

<p>The first of these is the least solution and the last is the greatest solution.</p>

<p>In the literature, the definition of an extreme predicate is often given as a set of
<em>inference rules</em>.  To designate the least solution, a single line separating the
antecedent (on top) from conclusion (on bottom) is used:</p>

<p style="text-align: center;" id="g-ind-rule" title="the inductive rules">
  $$\dfrac{}{g(0)} \qquad\qquad \dfrac{g(x-2)}{g(x)}$$
</p>

<p>Through repeated applications of such rules, one can show that the predicate holds for
a particular value.  For example, the <em>derivation</em>, or <em>proof tree</em>,
to the left in <a href="#fig-proof-trees">the proof tree figure</a> shows that $g(6)$ holds.
(In this simple example, the derivation is a rather degenerate proof tree.)
The use of these inference rules gives rise to a least solution, because proof trees are
accepted only if they are <em>finite</em>.</p>

<p>When inference rules are to designate the greatest solution, a thick
line is used:</p>

<p style="text-align: center;" id="g-coind-rule" title="the coinductive rules">
    $$\genfrac{}{}{1.2pt}0{}{g(0)}
  \qquad\qquad
    \genfrac{}{}{1.2pt}0{g(x-2)}{g(x)}$$
</p>

<p>In this case, proof trees are allowed to be infinite.
For example, the left-hand example below shows a finite proof tree that uses <a href="#g-ind-rule">the inductive rules</a> to establish $g(6)$.
On the right is a partial depiction of an infinite proof tree that uses <a href="#g-coind-rule">the coinductive rules</a> to establish $g(1)$.</p>

<p style="text-align: center;" id="fig-proof-trees" title="the proof tree figure">
$$\dfrac{
  \dfrac{
    \dfrac{
      \dfrac{}{g(0)}
      }{g(2)}
    }{g(4)}
  }{g(6)}
\qquad\qquad
\genfrac{}{}{1.2pt}0{
  \genfrac{}{}{1.2pt}0{
    \genfrac{}{}{1.2pt}0{
      \genfrac{}{}{1.2pt}0{
          {} {\vdots }
        }{g(-5)}
      }{g(-3)}
    }{g(-1)}
  }{g(1)}$$
</p>

<p>Note that derivations may not be unique.  For example, in the case of the greatest
solution for $g$, there are two proof trees that establish $g(0)$:  one is the finite
proof tree that uses the left-hand rule of <a href="#g-coind-rule">these coinductive rules</a> once, the other is the infinite
proof tree that keeps on using the right-hand rule of <a href="#g-coind-rule">these coinductive rules</a>.</p>

<h4 id="sec-extreme-predicates">12.4.2. Working with Extreme Predicates</h4>

<p>In general, one cannot evaluate whether or not an extreme predicate holds for some
input, because doing so may take an infinite number of steps.  For example, following
the recursive calls in the definition <a href="#eq-EvenNat">the EvenNat equation</a> to try to evaluate $g(7)$ would never
terminate.  However, there are useful ways to establish that an extreme predicate holds
and there are ways to make use of one once it has been established.</p>

<p>For any $\mathcal{F}$ as in <a href="#eq-general">the general equation</a>, define two infinite series of well-founded
functions, ${ {}^{\flat}\kern-1mm f}_k$ and ${ {}^{\sharp}\kern-1mm f}_k$
where $k$ ranges over the natural numbers:</p>

<p style="text-align: center;" id="eq-least-approx" title="the least approx definition">
$$
   { {}^{\flat}\kern-1mm f}_k(x) = \left\{
    \begin{array}{ll}
      \mathit{false}         &amp; \textrm{if } k = 0 \\
      \mathcal{F}({ {}^{\flat}\kern-1mm f}_{k-1})(x) &amp; \textrm{if } k &gt; 0
    \end{array}
     \right\} 
$$
</p>

<p style="text-align: center;" id="eq-greatest-approx" title="the greatest approx definition">
$$
   { {}^{\sharp}\kern-1mm f}_k(x) = \left\{
    \begin{array}{ll}
      \mathit{true}          &amp; \textrm{if } k = 0 \\
      \mathcal{F}({ {}^{\sharp}\kern-1mm f}_{k-1})(x) &amp; \textrm{if } k &gt; 0
    \end{array}
    \right\} 
$$
</p>

<p>These functions are called the <em>iterates</em> of $f$, and we will also refer to them
as the <em>prefix predicates</em> of $f$ (or the <em>prefix predicate</em> of $f$, if we think
of $k$ as being a parameter).
Alternatively, we can define ${ {}^{\flat}\kern-1mm f}_k$ and ${ {}^{\sharp}\kern-1mm f}_k$ without mentioning $x$:
let $\bot$ denote the function that always returns <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>, let $\top$
denote the function that always returns <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>, and let a superscript on $\mathcal{F}$ denote
exponentiation (for example, $\mathcal{F}^0(f) = f$ and $\mathcal{F}^2(f) = \mathcal{F}(\mathcal{F}(f))$).
Then, <a href="#eq-least-approx">the least approx definition</a> and <a href="#eq-greatest-approx">the greatest approx definition</a> can be stated equivalently as
${ {}^{\flat}\kern-1mm f}_k = \mathcal{F}^k(\bot)$ and ${ {}^{\sharp}\kern-1mm f}_k = \mathcal{F}^k(\top)$.</p>

<p>For any solution $f$ to <a href="#eq-general">the general equation</a>, we have, for any $k$ and $\ell$
such that $k \leq \ell$:</p>

<p style="text-align: center;" id="eq-prefix-postfix" title="the prefix postfix result">$$
 {\;{}^{\flat}\kern-1mm f}_k    \quad\;\dot{\Rightarrow}\;\quad {\;{}^{\flat}\kern-1mm f}_\ell \quad\;\dot{\Rightarrow}\;\quad f      \quad\;\dot{\Rightarrow}\;\quad {\;{}^{\sharp}\kern-1mm f}_\ell \quad\;\dot{\Rightarrow}\;\quad { {}^{\sharp}\kern-1mm f}_k $$</p>

<p>In other words, every ${\;{}^{\flat}\kern-1mm f}_{k}$ is a <em>pre-fixpoint</em> of $f$ and every ${\;{}^{\sharp}\kern-1mm f}_{k}$ is a <em>post-fixpoint</em>
of $f$.  Next, define two functions, $f^{\downarrow}$ and $f^{\uparrow}$, in
terms of the prefix predicates:</p>

<p style="text-align: center;" id="eq-least-is-exists" title="the least exists definition">$$
 f^{\downarrow}(x) \;=\;  \exists k \bullet\; { {}^{\flat}\kern-1mm f}_k(x) $$</p>
<p style="text-align: center;" id="eq-greatest-is-forall" title="the greatest forall definition">$$
  f^{\uparrow}(x) \;=\;  \forall k \bullet\; { {}^{\sharp}\kern-1mm f}_k(x) $$</p>

<p>By <a href="#eq-prefix-postfix">the prefix postfix result</a>, we also have that $f^{\downarrow}$ is a pre-fixpoint of $\mathcal{F}$ and $f^{\uparrow}$
is a post-fixpoint of $\mathcal{F}$.  The marvelous thing is that, if $\mathcal{F}$ is <em>continuous</em>, then
$f^{\downarrow}$ and $f^{\uparrow}$ are the least and greatest fixpoints of $\mathcal{F}$.
These equations let us do proofs by induction when dealing with extreme predicates.
<a href="#sec-friendliness">The extreme predicate section</a> explains how to check for continuity.</p>

<p>Lets consider two examples, both involving function $g$ in
<a href="#eq-EvenNat">the EvenNat equation</a>.  As it turns out, $g$s defining functor is continuous,
and therefore I will write $g^{\downarrow}$ and $g^{\uparrow}$ to denote the
least and greatest solutions for $g$ in <a href="#eq-EvenNat">the EvenNat equation</a>.</p>

<h5 id="sec-example-least-solution">12.4.2.1. Example with Least Solution</h5>

<p>The main technique for establishing that $g^{\downarrow}(x)$ holds for some
$x$, that is, proving something of the form $Q \Longrightarrow g^{\downarrow}(x)$, is to
construct a proof tree like the one for $g(6)$ in <a href="#fig-proof-trees">the proof tree figure</a>.
For a proof in this direction, since were just
applying the defining equation, the fact that
were using a least solution for $g$ never plays a role (as long as we
limit ourselves to finite derivations).</p>

<p>The technique for going in the other direction, proving something <em>from</em> an established
$g^{\downarrow}$ property, that is, showing something of the form $g^{\downarrow}(x) \Longrightarrow R$, typically
uses induction on the structure of the proof tree.  When the antecedent of our proof
obligation includes a predicate term $g^{\downarrow}(x)$, it is sound to
imagine that we have been given a proof tree for $g^{\downarrow}(x)$.  Such a proof tree
would be a data structureto be more precise, a term in an
<em>inductive datatype</em>.
Least solutions like $g^{\downarrow}$ have been given the
name <em>least predicate</em>.</p>

<p>Lets prove $g^{\downarrow}(x) \Longrightarrow 0 \leq x \wedge x \text{ even}$.
We split our task into two cases, corresponding to which of the two
proof rules in <a href="#g-ind-rule">the inductive rules</a> was the
last one applied to establish $g^{\downarrow}(x)$.  If it was the left-hand rule, then $x=0$,
which makes it easy to establish the conclusion of our proof goal.  If it was the
right-hand rule, then we unfold the proof tree one level and obtain $g^{\downarrow}(x-2)$.
Since the proof tree for $g^{\downarrow}(x-2)$ is smaller than where we started, we invoke
the <em>induction hypothesis</em> and obtain $0 \leq (x-2) \wedge (x-2) \textrm{ even}$, from which
it is easy to establish the conclusion of our proof goal.</p>

<p>Heres how we do the proof formally using <a href="#eq-least-is-exists">the least exists definition</a>.  We massage the
general form of our proof goal:</p>

<p style="text-align: center;">
$$
\begin{array}{lll}
    &amp; f^{\uparrow}(x) \;\Longrightarrow\; R  &amp; \\
  = &amp;  &amp; \textrm{ (the least exists definition) }    \\
    &amp; (\exists k \bullet\; { {}^{\flat}\kern-1mm f}_k(x)) \;\Longrightarrow\; R    &amp;     \\
  = &amp;  &amp; \text{distribute} \;\Longrightarrow\; \text{over} \;\exists\; \text{to the left}  \\
    &amp; \forall k \bullet\; ({ {}^{\flat}\kern-1mm f}_k(x) \;\Longrightarrow\; R)        &amp;       
\end{array}
$$
</p>

<p>The last line can be proved by induction over $k$.  So, in our case, we prove
${ {}^{\flat}\kern-1mm g}_k(x) \Longrightarrow 0 \leq x \wedge x \textrm{ even}$ for every $k$.
If $k = 0$, then ${ {}^{\flat}\kern-1mm g}_k(x)$ is <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>, so our goal holds trivially.
If $k &gt; 0$, then ${ {}^{\flat}\kern-1mm g}_k(x) = (x = 0 :\vee: { {}^{\flat}\kern-1mm g}_{k-1}(x-2))$.  Our goal holds easily
for the first disjunct ($x=0$).  For the other disjunct,
we apply the induction hypothesis (on the smaller $k-1$ and with $x-2$) and
obtain $0 \leq (x-2)\;\wedge\; (x-2) \textrm{ even}$, from which our proof goal
follows.</p>

<h5 id="sec-example-greatest-solution">12.4.2.2. Example with Greatest Solution</h5>

<p>We can think of a predicate $g^{\uparrow}(x)$ as being represented
by a proof treein this case a term in a <em>coinductive datatype</em>,
since the proof may be infinite.
Greatest solutions like $g^{\uparrow}$ have
been given the name <em>greatest predicate</em>.
The main technique for proving something from a given proof tree, that
is, to prove something of the form $g^{\uparrow}(x) \;\Longrightarrow\; R$, is to
destruct the proof.  Since this is just unfolding the defining
equation, the fact that were using a greatest solution for $g$ never
plays a role (as long as we limit ourselves to a finite number of
unfoldings).</p>

<p>To go in the other direction, to establish a predicate defined as a greatest solution,
like $Q \Longrightarrow g^{\uparrow}(x)$, we may need an infinite number of steps.  For this purpose,
we can use inductions dual, <em>coinduction</em>.  Were it not for one little detail, coinduction
is as simple as continuations in programming: the next part of the proof obligation
is delegated to the <em>coinduction hypothesis</em>.  The little detail is making sure that
it is the next part were passing on for the continuation, not the same part.  This
detail is called <em>productivity</em> and corresponds to the requirement in
induction of making sure were going down a well-founded relation when
applying the induction hypothesis.  There are
many sources with more information, see for example the classic account by
Jacobs and Rutten [@JacobsRutten:IntroductionCoalgebra]
or a new attempt by Kozen and Silva
that aims to emphasize the simplicity, not the mystery, of
coinduction [@KozenSilva:Coinduction].</p>

<p>Lets prove $\mathit{true} \Longrightarrow g^{\uparrow}(x)$.  The intuitive coinductive proof goes like this:
According to the right-hand rule of <a href="#g-coind-rule">these coinductive rules</a>, $g^{\uparrow}(x)$ follows if we
establish $g^{\uparrow}(x-2)$, and thats easy to do by invoking the coinduction hypothesis.
The little detail, productivity, is satisfied in this proof because we applied
a rule in <a href="#g-coind-rule">these coinductive rules</a> before invoking the coinduction hypothesis.</p>

<p>For anyone who may have felt that the intuitive proof felt too easy, here is a formal
proof using <a href="#eq-greatest-is-forall">the greatest forall definition</a>, which relies only on induction.  We massage the
general form of our proof goal:</p>

<p style="text-align: center;">
$$
\begin{array}{lll}
    &amp; Q \;\Longrightarrow\; f^{\uparrow}(x)           &amp;             \\
  = &amp;  &amp; \textrm{ (the greatest forall definition) }   \\
    &amp; Q \;\Longrightarrow\; \forall k \bullet\; { {}^{\sharp}\kern-1mm f}_k(x)  &amp;  \\
  = &amp;  &amp; \text{distribute} \;\Longrightarrow\; \text{over} \;\forall\; \text{to the right } \\
    &amp; \forall k \bullet\; Q \;\Longrightarrow\; { {}^{\sharp}\kern-1mm f}_k(x)                 &amp;
\end{array}
$$
</p>

<p>The last line can be proved by induction over $k$.  So, in our case, we prove
$\mathit{true} \;\Longrightarrow\; { {}^{\sharp}\kern-1mm g}_k(x)$ for every $k$.
If $k=0$, then ${ {}^{\sharp}\kern-1mm g}_k(x)$ is $\mathit{true}$, so our goal holds trivially.
If $k &gt; 0$, then ${ {}^{\sharp}\kern-1mm g}_k(x) = (x = 0 :\vee: { {}^{\sharp}\kern-1mm g}_{k-1}(x-2))$.  We establish the second
disjunct by applying the induction hypothesis (on the smaller $k-1$ and with $x-2$).</p>

<h4 id="1243-other-techniques">12.4.3. Other Techniques</h4>

<p>Although this section has considered only well-founded functions and extreme
predicates, it is worth mentioning that there are additional ways of making sure that
the set of solutions to <a href="#eq-general">the general equation</a> is nonempty.  For example, if all calls to $f$ in
$\mathcal{F}(f)$ are <em>tail-recursive calls</em>, then (under the assumption that $Y$ is nonempty) the set of
solutions is nonempty.  To see this, consider an attempted evaluation of $f(x)$ that fails
to determine a definite result value because of an infinite chain of calls that applies $f$
to each value of some subset $X$ of $X$.  Then, apparently, the value of $f$ for any one
of the values in $X$ is not determined by the equation, but picking any particular result
value for these makes for a consistent definition.
This was pointed out by Manolios and Moore [@ManoliosMoore:PartialFunctions].
Functions can be underspecified in this way in the proof assistants ACL2 [@ACL2:book]
and HOL [@Krauss:PhD].</p>

<h3 id="125-functions-in-dafny">12.5. Functions in Dafny</h3>

<p>This section explains with examples the support in
Dafny for well-founded functions, extreme predicates,
and proofs regarding these, building on the concepts 
explained in the previous section.</p>

<h4 id="1251-well-founded-functions-in-dafny">12.5.1. Well-founded Functions in Dafny</h4>

<p>Declarations of well-founded functions are unsurprising.  For example, the Fibonacci
function is declared as follows:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">function</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dafny verifies that the body (given as an expression in curly braces) is well defined.
This includes decrement checks for recursive (and mutually recursive) calls.  Dafny
predefines a well-founded relation on each type and extends it to lexicographic tuples
of any (fixed) length.  For example, the well-founded relation $x \ll y$ for integers
is $x &lt; y \;\wedge\; 0 \leq y$, the one for reals is $x \leq y - 1.0 \;\wedge\; 0.0 \leq y$
(this is the same ordering as for integers, if you read the integer
relation as $x \leq y - 1 \;\wedge\; 0 \leq y$), the one for inductive
datatypes is structural inclusion,
and the one for coinductive datatypes is <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>.</p>

<p>Using a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause, the programmer can specify the term in this predefined
order.  When a function definition omits a <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clause, Dafny makes a simple
guess.  This guess (which can be inspected by hovering over the function name in the
Dafny IDE) is very often correct, so users are rarely bothered to provide explicit
<code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clauses.</p>

<p>If a function returns <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code>, one can drop the result type <code class="language-dafny highlighter-rouge"><span class="o">:</span> <span class="kt">bool</span></code> and change the
keyword <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> to <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code>.</p>

<h4 id="sec-proofs-in-dafny">12.5.2. Proofs in Dafny</h4>

<p>Dafny has <code class="language-dafny highlighter-rouge"><span class="kr">lemma</span></code> declarations, as described in <a href="#sec-lemmas">Section 6.3.3</a>:
lemmas can have pre- and postcondition specifications and their body is a code block.
Here is the lemma we stated and proved in <a href="#sec-fib-example">the fib example</a> in the previous section:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">lemma</span> <span class="n">FibProperty</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&lt;==&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
  <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
    <span class="n">FibProperty</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="n">FibProperty</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">function</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The postcondition of this lemma (keyword <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code>) gives the proof
goal.  As in any program-correctness logic (e.g.,
[@Hoare:AxiomaticBasis]), the postcondition must
be established on every control path through the lemmas body.  For
<code class="language-dafny highlighter-rouge"><span class="n">FibProperty</span></code>, I give the proof by
an <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> statement, hence introducing a case split.  The then branch is empty, because
Dafny can prove the postcondition automatically in this case.  The else branch
performs two recursive calls to the lemma.  These are the invocations of the induction
hypothesis and they follow the usual program-correctness rules,
namely: the precondition must hold at the call site, the call must terminate, and then
the caller gets to assume the postcondition upon return.  The proof glue needed
to complete the proof is done automatically by Dafny.</p>

<p>Dafny features an aggregate statement using which it is possible to make (possibly
infinitely) many calls at once.  For example, the induction hypothesis can be called
at once on all values <code class="language-dafny highlighter-rouge"><span class="n">n'</span></code> smaller than <code class="language-dafny highlighter-rouge"><span class="n">n</span></code>:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">n'</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n'</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
  <span class="n">FibProperty</span><span class="p">(</span><span class="n">n'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For our purposes, this corresponds to <em>strong induction</em>.  More
generally, the <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement has the form</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">k</span> <span class="o">|</span> <span class="n">P</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">Q</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span> <span class="n">Statements</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>Logically, this statement corresponds to <em>universal introduction</em>: the body proves that
<code class="language-dafny highlighter-rouge"><span class="n">Q</span><span class="p">(</span><span class="n">k</span><span class="p">)</span></code> holds for an arbitrary <code class="language-dafny highlighter-rouge"><span class="n">k</span></code> such that <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="p">(</span><span class="n">k</span><span class="p">)</span></code>, and the conclusion of the <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement
is then $\forall k \bullet\; P(k) \;\Longrightarrow\; Q(k)$.  When the body of the <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement is
a single call (or <code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code> statement), the <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause is inferred and can be omitted,
like in our <code class="language-dafny highlighter-rouge"><span class="n">FibProperty</span></code> example.</p>

<p>Lemma <code class="language-dafny highlighter-rouge"><span class="n">FibProperty</span></code> is simple enough that its whole body can be replaced by the one
<code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement above.  In fact, Dafny goes one step further: it automatically
inserts such a <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement at the beginning of every lemma [@Leino:induction].
Thus, <code class="language-dafny highlighter-rouge"><span class="n">FibProperty</span></code> can be declared and proved simply by:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">lemma</span> <span class="n">FibProperty</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&lt;==&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">{</span> <span class="p">}</span>
<span class="kr">function</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="n">n</span> <span class="kr">else</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Going in the other direction from universal introduction is existential elimination,
also known as Skolemization.  Dafny has a statement for this, too:
for any variable <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> and boolean expression <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code>, the
<em>assign such that</em> statement <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:|</span> <span class="n">Q</span><span class="p">;</span></code> says to assign to <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> a value such that <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code>
will hold.  A proof obligation when using this statement is to show that there
exists an <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> such that <code class="language-dafny highlighter-rouge"><span class="n">Q</span></code> holds.  For example, if the fact
$\exists k \bullet\; 100 \leq \mathit{fib}(k) &lt; 200$ is known, then the statement
<code class="language-dafny highlighter-rouge"><span class="n">k</span> <span class="o">:|</span> <span class="mi">100</span> <span class="o">&lt;=</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">;</span></code> will assign to <code class="language-dafny highlighter-rouge"><span class="n">k</span></code> some value (chosen arbitrarily)
for which <code class="language-dafny highlighter-rouge"><span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="p">)</span></code> falls in the given range.</p>

<h4 id="sec-friendliness">12.5.3. Extreme Predicates in Dafny</h4>

<p>The previous subsection explained that a <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code> declaration introduces a
well-founded predicate.  The declarations for introducing extreme predicates are
<code class="language-dafny highlighter-rouge"><span class="kr">least</span> <span class="kr">predicate</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span> <span class="kr">predicate</span></code>.  Here is the definition of the least and
greatest solutions of $g$ from above; lets call them <code class="language-dafny highlighter-rouge"><span class="n">g</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">G</span></code>:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">least</span> <span class="kr">predicate</span> <span class="n">g</span><span class="p">[</span><span class="kt">nat</span><span class="p">](</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">greatest</span> <span class="kr">predicate</span> <span class="n">G</span><span class="p">[</span><span class="kt">nat</span><span class="p">](</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>When Dafny receives either of these definitions, it automatically declares the corresponding
prefix predicates.  Instead of the names ${ {}^{\flat}\kern-1mm g}_k$ and ${ {}^{\sharp}\kern-1mm g}_k$ that I used above, Dafny
names the prefix predicates <code class="language-dafny highlighter-rouge"><span class="n">g</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">G</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></code>, respectively, that is, the name of
the extreme predicate appended with <code class="language-dafny highlighter-rouge"><span class="err">#</span></code>, and the subscript is given as an argument in
square brackets.  The definition of the prefix predicate derives from the body of
the extreme predicate and follows the form in <a href="#eq-least-approx">the least approx definition</a> and <a href="#eq-greatest-approx">the greatest approx definition</a>.
Using a faux-syntax for illustrative purposes, here are the prefix
predicates that Dafny defines automatically from the extreme
predicates <code class="language-dafny highlighter-rouge"><span class="n">g</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">G</span></code>:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">predicate</span> <span class="n">g</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">:</span> <span class="kt">nat</span><span class="p">](</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="err">_</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">g</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="p">}</span>
<span class="kr">predicate</span> <span class="n">G</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">:</span> <span class="kt">nat</span><span class="p">](</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="err">_</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">==&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">G</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="p">}</span>
</code></pre></div></div>

<p>The Dafny verifier is aware of the connection between extreme predicates and their
prefix predicates, <a href="#eq-least-is-exists">the least exists definition</a> and <a href="#eq-greatest-is-forall">the greatest forall definition</a>.</p>

<p>Remember that to be well defined, the defining functor of an extreme predicate
must be monotonic, and for <a href="#eq-least-is-exists">the least exists definition</a> and <a href="#eq-greatest-is-forall">the greatest forall definition</a> to hold,
the functor must be continuous.  Dafny enforces the former of these by checking that
recursive calls of extreme predicates are in positive positions.  The continuity
requirement comes down to checking that they are also in <em>continuous positions</em>:
that recursive calls to least predicates are
not inside unbounded universal quantifiers and that recursive calls to greatest predicates
are not inside unbounded existential quantifiers [@Milner:CCS; @LeinoMoskal:Coinduction].</p>

<h4 id="1254-proofs-about-extreme-predicates">12.5.4. Proofs about Extreme Predicates</h4>

<p>From what has been presented so far, we can do the formal proofs for
<a href="#sec-example-least-solution">the example about the least solution</a> and <a href="#sec-example-greatest-solution">the example about the greatest solution</a>.  Here is the
former:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">least</span> <span class="kr">predicate</span> <span class="n">g</span><span class="p">[</span><span class="kt">nat</span><span class="p">](</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">greatest</span> <span class="kr">predicate</span> <span class="n">G</span><span class="p">[</span><span class="kt">nat</span><span class="p">](</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">lemma</span> <span class="n">EvenNat</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">k</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">:|</span> <span class="n">g</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">x</span><span class="p">);</span>
  <span class="n">EvenNatAux</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="kr">lemma</span> <span class="n">EvenNatAux</span><span class="p">(</span><span class="n">k</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">g</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">x</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span> <span class="n">EvenNatAux</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lemma <code class="language-dafny highlighter-rouge"><span class="n">EvenNat</span></code> states the property we wish to prove.  From its
precondition (keyword <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code>) and
<a href="#eq-least-is-exists">the least exists definition</a>, we know there is some <code class="language-dafny highlighter-rouge"><span class="n">k</span></code> that will make the condition in the
assign-such-that statement true.  Such a value is then assigned to <code class="language-dafny highlighter-rouge"><span class="n">k</span></code> and passed to
the auxiliary lemma, which promises to establish the proof goal.  Given the condition
<code class="language-dafny highlighter-rouge"><span class="n">g</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">x</span><span class="p">)</span></code>, the definition of <code class="language-dafny highlighter-rouge"><span class="n">g</span><span class="err">#</span></code> lets us conclude <code class="language-dafny highlighter-rouge"><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span></code> as well as the disjunction
<code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">g</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span></code>.  The then branch considers the case of the first disjunct,
from which the proof goal follows automatically.  The else branch can then assume
<code class="language-dafny highlighter-rouge"><span class="n">g</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span></code> and calls the induction hypothesis with those parameters.  The proof
glue that shows the proof goal for <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> to follow from the proof goal with <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">-</span><span class="mi">2</span></code> is
done automatically.</p>

<p>Because Dafny automatically inserts the statement</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">k'</span><span class="p">,</span> <span class="n">x'</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">k'</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="err">#</span><span class="p">[</span><span class="n">k'</span><span class="p">](</span><span class="n">x'</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EvenNatAux</span><span class="p">(</span><span class="n">k'</span><span class="p">,</span> <span class="n">x'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>at the beginning of the body of <code class="language-dafny highlighter-rouge"><span class="n">EvenNatAux</span></code>, the body can be left empty and Dafny
completes the proof automatically.</p>

<p>Here is the Dafny program that gives the proof from <a href="#sec-example-greatest-solution">the example of the greatest solution</a>:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">least</span> <span class="kr">predicate</span> <span class="n">g</span><span class="p">[</span><span class="kt">nat</span><span class="p">](</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">greatest</span> <span class="kr">predicate</span> <span class="n">G</span><span class="p">[</span><span class="kt">nat</span><span class="p">](</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">lemma</span> <span class="n">Always</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="kr">forall</span> <span class="n">k</span><span class="o">:</span> <span class="kt">nat</span> <span class="p">{</span> <span class="n">AlwaysAux</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span>
<span class="kr">lemma</span> <span class="n">AlwaysAux</span><span class="p">(</span><span class="n">k</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">G</span><span class="err">#</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
</code></pre></div></div>

<p>While each of these proofs involves only basic proof rules, the setup feels a bit clumsy,
even with the empty body of the auxiliary lemmas.  Moreover,
the proofs do not reflect the intuitive proofs described in
<a href="#sec-example-least-solution">the example of the least solution</a> and <a href="#sec-example-greatest-solution">the example of the greatest solution</a>.
These shortcomings are addressed in the next subsection.</p>

<h4 id="sec-nicer-proofs-of-extremes">12.5.5. Nicer Proofs of Extreme Predicates</h4>

<p>The proofs we just saw follow standard forms:
use Skolemization to convert the least predicate into a prefix predicate for some <code class="language-dafny highlighter-rouge"><span class="n">k</span></code>
and then do the proof inductively over <code class="language-dafny highlighter-rouge"><span class="n">k</span></code>; respectively,
by induction over <code class="language-dafny highlighter-rouge"><span class="n">k</span></code>, prove the prefix predicate for every <code class="language-dafny highlighter-rouge"><span class="n">k</span></code>, then use
universal introduction to convert to the greatest predicate.
With the declarations <code class="language-dafny highlighter-rouge"><span class="kr">least</span> <span class="kr">lemma</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span> <span class="kr">lemma</span></code>, Dafny offers to
set up the proofs
in these standard forms.  What is gained is not just fewer characters in the program
text, but also a possible intuitive reading of the proofs.  (Okay, to be fair, the
reading is intuitive for simpler proofs; complicated proofs may or may not be intuitive.)</p>

<p>Somewhat analogous to the creation of prefix predicates from extreme predicates, Dafny
automatically creates a <em>prefix lemma</em> <code class="language-dafny highlighter-rouge"><span class="n">L</span><span class="err">#</span></code> from each extreme lemma <code class="language-dafny highlighter-rouge"><span class="n">L</span></code>.  The pre-
and postconditions of a prefix lemma are copied from those of the extreme lemma,
except for the following replacements:</p>
<ul>
  <li>for a least lemma, Dafny looks in the precondition to find calls (in positive, continuous
positions) to least predicates <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> and replaces these with <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="p">](</span><span class="n">x</span><span class="p">)</span></code>;</li>
  <li>for a greatest lemma,
Dafny looks in the postcondition to find calls (in positive, continuous positions)
to greatest predicates <code class="language-dafny highlighter-rouge"><span class="n">P</span></code> (including equality among coinductive datatypes, which is a built-in
greatest predicate) and replaces these with <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="p">](</span><span class="n">x</span><span class="p">)</span></code>.
In each case, these predicates <code class="language-dafny highlighter-rouge"><span class="n">P</span></code> are the lemmas <em>focal predicates</em>.</li>
</ul>

<p>The body of the extreme lemma is moved to the prefix lemma, but with
replacing each recursive
call <code class="language-dafny highlighter-rouge"><span class="n">L</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> with <code class="language-dafny highlighter-rouge"><span class="n">L</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="p">)</span></code> and replacing each occurrence of a call
to a focal predicate
<code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> with <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="p">)</span></code>.  The bodies of the extreme lemmas are then replaced as shown
in the previous subsection.  By construction, this new body correctly leads to the
extreme lemmas postcondition.</p>

<p>Let us see what effect these rewrites have on how one can write proofs.  Here are the proofs
of our running example:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">least</span> <span class="kr">predicate</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">greatest</span> <span class="kr">predicate</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
<span class="kr">least</span> <span class="kr">lemma</span> <span class="n">EvenNat</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">{</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span> <span class="n">EvenNat</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span>
<span class="kr">greatest</span> <span class="kr">lemma</span> <span class="n">Always</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span> <span class="n">Always</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div></div>

<p>Both of these proofs follow the intuitive proofs given in
<a href="#sec-example-least-solution">the example of the least solution</a> and <a href="#sec-example-greatest-solution">the example of the greatest solution</a>.  Note that in these
simple examples, the user is never bothered with either prefix predicates nor
prefix lemmasthe proofs just look like what youd expect.</p>

<p>Since Dafny automatically inserts calls to the induction hypothesis at the beginning of
each lemma, the bodies of the given extreme lemmas <code class="language-dafny highlighter-rouge"><span class="n">EvenNat</span></code> and
<code class="language-dafny highlighter-rouge"><span class="n">Always</span></code> can be empty and Dafny still completes the proofs.
Folks, it doesnt get any simpler than that!</p>

<h3 id="sec-definite-assignment">12.6. Variable Initialization and Definite Assignment</h3>

<p>The Dafny language semantics ensures that any use (read) of a variable (or constant,
parameter, object field, or array element) gives a value of the variables type.
It is easy to see that this property holds for any variable that is declared with
an initializing assignment. However, for many useful programs, it would be too strict
to require an initializing assignment at the time a variable is declared.
Instead, Dafny ensures the property through <em>auto-initialization</em> and rules for <em>definite assignment</em>.</p>

<p>As explained in <a href="#sec-type-characteristics">section 5.3.1</a>, each type in Dafny is one of the following:</p>

<ul>
  <li><em>auto-init type</em>: the type is nonempty and the compiler has some way to emit code that constructs a value</li>
  <li><em>nonempty type</em>: the type is nonempty, but the compiler does not know how perform automatic initialization</li>
  <li><em>possibly empty type</em>: the type is not known for sure to have a value</li>
</ul>

<p>For a variable of an auto-init type, the compiler can initialize the variable automatically.
This means that the variable can be used immediately after declaration, even if the program does not
explicitly provide an initializing assignment.</p>

<p>In a ghost context, one can an imagine a ghost that initializes variables. Unlike the compiler, such
a ghost does not need to emit code that constructs an initializing value; it suffices for the ghost to
know that a value exists. Therefore, in a ghost context, a variable of a nonempty type can be used immediately
after declaration.</p>

<p>Before a variable of a possibly empty type can be used, the program must initialize it.
The variable need not be given a value when it is declared,
but it must have a value by the time it is first used. Dafny uses the precision of the verifier to
reason about the control flow between assignments and uses of variables, and it reports an error
if it cannot assure itself that the variable has been given a value.</p>

<p>The elements of an array must be assured to have values already in the statement that allocates the array.
This is achieved in any of the following four ways:</p>
<ul>
  <li>If the array is allocated to be empty (that is, one of its dimensions is requested to be 0), then
the array allocation trivially satisfies the requirement.</li>
  <li>If the element type of the array is an auto-init type, then nothing further is required by the program.</li>
  <li>If the array allocation occurs in a ghost context and the element type is a nonempty type, then nothing
further is required by the program.</li>
  <li>Otherwise, the array allocation must provide an initialization display or an initialization function.
See <a href="#sec-array-type">section 5.10</a> for information about array initialization.</li>
</ul>

<p>The fields of a class must have values by the end of the first phase of each constructor (that is, at
the explicit or implicit <code class="language-dafny highlighter-rouge"><span class="kr">new</span><span class="p">;</span></code> statement in the constructor). If a class has a compiled field that is
not of an auto-init type, or if it has a ghost field of a possibly empty type, then the class is required
to declare a(t least one) constructor.</p>

<p>The yield-parameters of an <code class="language-dafny highlighter-rouge"><span class="kr">iterator</span></code> turn into fields of the corresponding iterator class, but there
is no syntactic place to give these initial values. Therefore, every compiled yield-parameter must be of
auto-init types and every ghost yield-parameter must be of an auto-init or nonempty type.</p>

<p>For local variables and out-parameters, Dafny supports two definite-assignment modes:</p>
<ul>
  <li>A strict mode (the default, which is <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">relax</span><span class="o">-</span><span class="n">definite</span><span class="o">-</span><span class="n">assignment</span><span class="o">=</span><span class="kc">false</span></code>; or <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">definiteAssignment</span><span class="o">:</span><span class="mi">4</span></code>
in the legacy CLI), in which local variables and out-parameters are always subject
to definite-assignment rules, even for auto-initializable types.</li>
  <li>A relaxed mode (enabled by the option <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">relax</span><span class="o">-</span><span class="n">definite</span><span class="o">-</span><span class="n">assignment</span></code>; or <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">definiteAssignment</span><span class="o">:</span><span class="mi">1</span></code>
in the legacy CLI), in which the auto-initialization (or, for ghost variables and parametes, nonemptiness)
is sufficient to satisfy the definite assignment rules.</li>
</ul>

<p>A program using the strict mode can still indicate that it is okay with an arbitrary value of a variable <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>
by using an assignment statement <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:=</span> <span class="o">*</span><span class="p">;</span></code>, provided the type of <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is an auto-init type (or, if <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is
ghost, a nonempty type). (If <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is of a possibly nonempty type, then <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:=</span> <span class="o">*</span><span class="p">;</span></code> is still allowed, but it
sets <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> to a value of its type only if the type actually contains a value. Therefore, when <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is of
a possibly empty type, <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:=</span> <span class="o">*</span><span class="p">;</span></code> does not count as a definite assignment to <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>.)</p>

<p>Note that auto-initialization is nondeterministic. Dafny only guarantees that each value it assigns to
a variable of an auto-init type is <em>some</em> value of the type. Indeed, a variable may be auto-initialized
to different values in different runs of the program or even at different times during the same run of
the program. In other words, Dafny does not guarantee the zero-equivalent value initialization that
some languages do. Along these lines, also note that the <code class="language-dafny highlighter-rouge"><span class="kr">witness</span></code> value provided in some subset-type
declarations is not necessarily the value chosen by auto-initialization, though it does esstablish that
the type is an auto-init type.</p>

<p>In some programs (for example, in some test programs), it is desirable to avoid nondeterminism.
For that purpose, Dafny provides an <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">enforce</span><span class="o">-</span><span class="n">determinism</span></code> option. It forbids use of any program
statement that may have nondeterministic behavior and it disables auto-initialization.
This mode enforces definite assignments everywhere, going beyond what the strict mode does by enforcing
definite assignment also for fields and array elements. It also forbids the use of <code class="language-dafny highlighter-rouge"><span class="kr">iterator</span></code> declarations
and <code class="language-dafny highlighter-rouge"><span class="kr">constructor</span></code>-less <code class="language-dafny highlighter-rouge"><span class="kr">class</span></code> declarations. It is up to a users build process to ensure that
<code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">enforce</span><span class="o">-</span><span class="n">determinism</span></code> is used consistently throughout the program. (In the legacy CLI, this
mode is enabled by <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">definiteAssignment</span><span class="o">:</span><span class="mi">3</span></code>.)</p>

<p><a href="../Compilation/AutoInitialization">This document</a>, which is intended for developers of the
Dafny tool itself, has more detail on auto-initialization and how it is implemented.</p>

<p>Finally, note that <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">relax</span><span class="o">-</span><span class="n">definite</span><span class="o">-</span><span class="n">assignment</span><span class="o">=</span><span class="kc">false</span></code> is the default in the command-based CLI,
but, for backwards compatibility, the relaxed rules (`/definiteAssignment:1) are still the default
in the legacy CLI.</p>

<h3 id="sec-well-founded-orders">12.7. Well-founded Orders</h3>

<p>The well-founded order relations for a variety of built-in types in Dafny
are given in the following table:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">type of <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">x</span></code></th>
      <th style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">x</span></code> strictly below <code class="language-dafny highlighter-rouge"><span class="n">X</span></code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code></td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">X</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">x</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kt">int</span></code></td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">X</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kt">real</span></code></td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">X</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">&amp;&amp;</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">X</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kt">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is a proper subset of <code class="language-dafny highlighter-rouge"><span class="n">X</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kt">multiset</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is a proper multiset-subset of <code class="language-dafny highlighter-rouge"><span class="n">X</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></code></td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is a consecutive proper sub-sequence of <code class="language-dafny highlighter-rouge"><span class="n">X</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kt">map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span></code></td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">.</span><span class="n">Keys</span></code> is a proper subset of <code class="language-dafny highlighter-rouge"><span class="n">X</span><span class="o">.</span><span class="n">Keys</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left">inductive datatypes</td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is structurally included in <code class="language-dafny highlighter-rouge"><span class="n">X</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left">reference types</td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">X</span> <span class="o">!=</span> <span class="kc">null</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left">coinductive datatypes</td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kc">false</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left">type parameter</td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kc">false</span></code></td>
    </tr>
    <tr>
      <td style="text-align: left">arrow types</td>
      <td style="text-align: left"><code class="language-dafny highlighter-rouge"><span class="kc">false</span></code></td>
    </tr>
  </tbody>
</table>

<p>Also, there are a few relations between the rows in the table above. For example, a datatype value <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> sitting inside a set that sits inside another datatype value <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> is considered to be strictly below <code class="language-dafny highlighter-rouge"><span class="n">X</span></code>. Heres an illustration of that order, in a program that verifies:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">datatype</span> <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="kt">set</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">)</span>

<span class="kr">method</span> <span class="n">TestD</span><span class="p">(</span><span class="n">dd</span><span class="o">:</span> <span class="n">D</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">dd</span><span class="p">;</span>
  <span class="kr">while</span> <span class="n">d</span> <span class="o">!=</span> <span class="n">D</span><span class="p">({})</span>
    <span class="kr">decreases</span> <span class="n">d</span>
  <span class="p">{</span>
    <span class="kr">var</span> <span class="n">x</span> <span class="o">:|</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">s</span><span class="p">;</span>
    <span class="n">d</span> <span class="o">:=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="sec-quantifier-triggers">12.8. Quantifier instantiation rules</h3>
<p>During verification, when Dafny knows that a universal quantifier is true, such as when verifying the body of a function that has the requires clause <code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span></code>, it may instantiate the quantifier. Instantiation means Dafny will pick a value for all the variables of the quantifier, leading to a new expression, which it hopes to use to prove an assertion. In the above example, instantiating using <code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> for <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> will lead to the expression <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span></code>.</p>

<p>For each universal quantifier, Dafny generates rules to determine which instantiations are worthwhile doing. We call these rules triggers, a term that originates from SMT solvers. If Dafny can not generate triggers for a specific quantifier, it falls back to a set of generic rules. However, this is likely to be problematic, since the generic rules can cause many useless instantiations, leading to verification timing out or failing to proof a valid assertion. When the generic rules are used, Dafny emits a warning telling the user no triggers were found for the quantifier, indicating the Dafny program should be changed so Dafny can find triggers for this quantifier.</p>

<p>Here follows the approach Dafny uses to generate triggers based on a quantifier. Dafny finds terms in the quantifier body where a quantified variable is used in an operation, such as in a function application <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>, array access <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">]</span></code>, member accesses <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">.</span><span class="n">someField</span></code>, or set membership tests <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">in</span> <span class="n">S</span></code>. To find a trigger, Dafny must find a set of such terms so that each quantified variable is used. You can investigate which triggers Dafny finds by hovering over quantifiers in the IDE and looking for Selected triggers, or by using the options <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">tooltips</span></code> when using the LCI.</p>

<p>There are particular expressions which, for technical reasons, Dafny can not use as part of a trigger. Among others, these expression include: <a href="#sec-match-expression">match</a>, <a href="#sec-let-expression">let</a>, <a href="#sec-expressions">arithmetic operations and logical connectives</a>. For example, in the quantifier <code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span> <span class="err"></span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></code>, Dafny will use <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">in</span> <span class="n">S</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> as trigger terms, but will not use <code class="language-dafny highlighter-rouge"><span class="n">x</span><span class="o">+</span><span class="mi">1</span></code> or any terms that contain it. You can investigate which triggers Dafny can not use by hovering over quantifiers in the IDE and looking for Rejected triggers, or by using the options <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">tooltips</span></code> when using the LCI.</p>

<p>Besides not finding triggers, another problematic situation is when Dafny was able to generate triggers, but believes the triggers it found may still cause useless instantiations because they create matching loops. Dafny emits a warning when this happens, indicating the Dafny program should be changed so Dafny can find triggers for this quantifier that do not cause matching loops.</p>

<p>To understand matching loops, one needs to understand how triggers are used. During a single verification run, such as verifying a method or function, Dafny maintains a set of expressions which it believes to be true, which we call the ground terms. For example, in the body of a method, Dafny knows the requires clauses of that method hold, so the expressions in those will be ground terms. When Dafny steps through the statements of the body, the set of ground terms grows. For example, when an assignment <code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">3</span></code> is evaluated, a ground term <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">==</span> <span class="mi">3</span></code> will be added. Given a universal quantifier thats a ground term, Dafny will try to pattern match its triggers on sub-expressions of other ground terms. If the pattern matches, that sub-expression is used to instantiate the quantifier.</p>

<p>Dafny makes sure not to perform the exact same instantiation twice. However, if an instantiation leads to a new term that also matches the trigger, but is different from the term used for the instantiation, the quantifier may be instantiated too often, an event we call a matching loop. For example, given the ground terms <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">x</span> <span class="p">{</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span> <span class="o">::</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></code>, where <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span></code> indicates the trigger for the quantifier, Dafny may instantiate the quantifier using <code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> for <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>. This creates a new ground term <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span></code>, of which the right hand side again matches the trigger, allowing Dafny to instantiate the quantifier again using <code class="language-dafny highlighter-rouge"><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></code> for <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>, and again and again, leading to an unbounded amount of instantiations.</p>

<p>Even existential quantifiers need triggers. This is because when Dafny determines an existential quantifier is false, for example in the body of a method that has <code class="language-dafny highlighter-rouge"><span class="kr">requires</span> <span class="o">!</span><span class="kr">exists</span> <span class="n">x</span> <span class="o">::</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span></code>, Dafny will use a logical rewrite rule to change this existential into a universal quantifier, so it becomes <code class="language-dafny highlighter-rouge"><span class="kr">requires</span> <span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span></code>. Before verification, Dafny can not determine whether quantifiers will be determined to be true or false, so it must assume any quantifier may turn into a universal quantifier, and thus they all need triggers. Besides quantifiers, comprehensions such as set and map comprehensions also need triggers, since these are modeled using universal quantifiers.</p>

<p>Dafny may report Quantifier was split into X parts. This occurs when Dafny determines it can only generate good triggers for a quantifier by splitting it into multiple smaller quantifiers, whose aggregation is logically equivalent to the original one. To maintain logical equivalence, Dafny may have to generate more triggers than if the split had been done manually in the Dafny source file. An example is the expression <code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span><span class="err"></span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span></code>, which Dafny will split into
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">forall</span> <span class="n">x</span> <span class="p">{</span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span> <span class="p">{</span><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="kr">forall</span> <span class="n">x</span> <span class="p">{(</span><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span> <span class="o">::</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span><span class="err"></span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Note the trigger <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span></code> in the first quantifier, which was added to maintain equivalence with the original quantifier. If the quantifier had been split in source, only the trigger <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span></code> would have been added for <code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>.</p>

<!--PDF NEWPAGE-->
<h2 id="sec-user-guide">13. Dafny Users Guide</h2>

<p>Most of this document describes the Dafny programming language.
This section describes the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool, a combined verifier and compiler
that implements the Dafny language.</p>

<p>The development of the Dafny language and tool is a GitHub project at <a href="https://github.com/dafny-lang/dafny">https://github.com/dafny-lang/dafny</a>.
The project is open source, with collaborators from various organizations; additional contributors are welcome.
The software itself is licensed under the <a href="https://github.com/dafny-lang/dafny/blob/master/LICENSE.txt">MIT license</a>.</p>

<h3 id="131-introduction">13.1. Introduction</h3>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool implements the following primary capabilities, implemented as various <a href="#sec-dafny-commands"><em>commands</em></a> within the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool:</p>

<ul>
  <li>checking that the input files represent a valid Dafny program (i.e., syntax, grammar and name and type resolution);</li>
  <li>verifying that the program meets its specifications, by translating the program to verification conditions
and checking those with Boogie and an SMT solver, typically Z3;</li>
  <li>compiling the program to a target language, such as C#, Java, Javascript, Go (and others in development);</li>
  <li>running the executable produced by the compiler.</li>
</ul>

<p>In addition there are a variety of other capabilities, such as formatting files, also implemented as commands;
more such commands are expected in the future.</p>

<h3 id="132-installing-dafny">13.2. Installing Dafny</h3>

<h4 id="1321-command-line-tools">13.2.1. Command-line tools</h4>

<p>The instructions for installing <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> and the required dependencies and environment
are described on the Dafny wiki:
<a href="https://github.com/dafny-lang/dafny/wiki/INSTALL">https://github.com/dafny-lang/dafny/wiki/INSTALL</a>.
They are not repeated here to avoid replicating information that
easily becomes inconsistent and out of date.
The dafny tool can also be installed using <code class="language-dafny highlighter-rouge"><span class="n">dotnet</span> <span class="n">tool</span> <span class="n">install</span> <span class="o">--</span><span class="n">global</span> <span class="n">dafny</span></code>
(presuming that <code class="language-dafny highlighter-rouge"><span class="n">dotnet</span></code> is already installed on your system).</p>

<p>Most users will find it most convenient to install the pre-built Dafny binaries available on the project release site or using the <code class="language-dafny highlighter-rouge"><span class="n">dotnet</span></code> CLI.
As is typical for Open Source projects, dafny can also be built directly from the source files maintained in the github project.</p>

<p>Current and past Dafny binary releases can be found at
<a href="https://github.com/dafny-lang/dafny/releases">https://github.com/dafny-lang/dafny/releases</a> for each supported platform.
Each release is a .zip file with a name combining the release name and the
platform. Current platforms are Windows 11, Ubuntu 20 and later, and MacOS 10.14 and later.</p>

<p>The dafny tool is distributed as a standalone executable. 
A compatible version of the required Z3 solver is included in the release.
There are additional dependencies that are needed to compile dafny to particular target languages,
as described in the release instructions.
A development environment to <em>build</em> dafny from source requires additional dependencies, 
described <a href="https://github.com/dafny-lang/dafny/wiki/INSTALL#building-and-developing-from-source-code">here</a>.</p>

<h4 id="sec-ides">13.2.2. IDEs for Dafny</h4>

<p>Dafny source files are text files and can of course be edited with any
text editor. However, some tools provide syntax-aware features:</p>

<ul>
  <li>VSCode, a cross-platform editor for many programming languages has an extension for Dafny. 
VSCode is available <a href="http://code.visualstudio.com">here</a> and the Dafny extension can be installed from within VSCode.
The <a href="#sec-dafny-language-server-vscode">extension</a> provides syntax highlighting, in-line parser,
type and verification errors, code navigation, counter-example display and gutter highlights.</li>
  <li>There is a <a href="https://github.com/boogie-org/boogie-friends">Dafny mode for
  Emacs</a>.</li>
  <li>An old Visual Studio plugin is no longer supported</li>
</ul>

<p>Information about installing IDE extensions for Dafny is found
on the <a href="https://github.com/dafny-lang/dafny/wiki/INSTALL">Dafny INSTALL page in the wiki</a>.</p>

<p>More information about using VSCode IDE is <a href="#sec-dafny-language-server-vscode">here</a>.</p>

<h3 id="133-dafny-programs-and-files">13.3. Dafny Programs and Files</h3>

<p>A Dafny program is a set of modules.
Modules can refer to other modules, such as through <code class="language-dafny highlighter-rouge"><span class="kr">import</span></code> declarations
or <code class="language-dafny highlighter-rouge"><span class="kr">refines</span></code> clauses.
A Dafny program consists of all the modules needed so that all module
references are resolved.
Dafny programs are contained in files that have a <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> suffix.
Such files each hold
some number of top-level declarations. Thus a full program may be
distributed among multiple files.
To apply the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool to a Dafny program, the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool must be
given all the files making up a complete program (or, possibly, more than
one program at a time). This can be effected either by listing all of the files
by name on the command-line or by using <code class="language-dafny highlighter-rouge"><span class="kr">include</span></code> directives within a file
to stipulate what other files contain modules that the given files need.
Thus the complete set of modules are all the modules in all the files listed
on the command-line or referenced, recursively, by <code class="language-dafny highlighter-rouge"><span class="kr">include</span></code> directives
within those files. It does not matter if files are repeated either as
includes or on the command-line.<sup id="fnref:fn-duplicate-files" role="doc-noteref"><a href="#fn:fn-duplicate-files" class="footnote" rel="footnote">15</a></sup></p>

<p>Note however that although the complete set of files, command-line plus
included files, make up the program, by default, only those files listed on
the command-line are verified. To do a complete verification, each file
must be verified; it may well happen that a verification failure in one
file (which is not on the command-line and thus not checked) may hide a
verification failure in a file that is being checked.
Thus it is important to eventually check all files, preferably in an order
in which the files without dependencies are checked first, then those that
depend on them, etc., until all files are checked.
The <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verify</span><span class="o">-</span><span class="n">included</span><span class="o">-</span><span class="n">files</span></code> option (<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">verifyAllModules</span></code> in legacy mode) will cause all modules, whether the result of include directives or not,
to be verified.</p>

<h4 id="sec-doo-files">13.3.1. Dafny Verification Artifacts: the Library Backend and .doo Files</h4>

<p>As of Dafny 4.1, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> now supports outputting a single file containing
a fully-verified program along with metadata about how it was verified.
Such files use the extension <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">doo</span></code>, for Dafny Output Object,
and can be used as input anywhere a <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> file can be.</p>

<p><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">doo</span></code> files are produced by an additional backend called the Dafny Library backend,
identified with the name <code class="language-dafny highlighter-rouge"><span class="n">lib</span></code> on the command line. For example, to build multiple
Dafny files into a single build artifact for shared reuse, the command would look something like:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>dafny build <span class="nt">-t</span>:lib A.dfy B.dfy C.dfy <span class="nt">--output</span>:MyLib.doo
</code></pre></div></div>

<p>The Dafny code contained in a <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">doo</span></code> file is not re-verified when passed back to the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool,
just as included files and those passed with the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">library</span></code> option are not.
Using <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">doo</span></code> files provides a guarantee that the Dafny code was in fact verified,
however, and therefore offers protection against build system mistakes.
<code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">doo</span></code> files are therefore ideal for sharing Dafny libraries between projects.</p>

<p><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">doo</span></code> files also contain metadata about the version of Dafny used to verify them
and the values of relevant options that affect the sound separate verification and
compilation of Dafny code, such as <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span></code>.
This means attempting to use a library that was built with options
that are not compatible with the currently executing command options
will lead to errors.
This also includes attempting to use a <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">doo</span></code> file built with a different version of Dafny,
although this restriction may be lifted in the future.</p>

<p>A <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">doo</span></code> file is a compressed archive of multiple files, similar to the <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">jar</span></code> file format for Java packages.
The exact file format is internal and may evolve over time to support additional features.</p>

<p>Note that the library backend only supports the <a href="#sec-dafny-commands">newer command-style CLI interface</a>.</p>

<h4 id="sec-dtr-files">13.3.2. Dafny Translation Artifacts: .dtr Files</h4>

<p>Some options, such as <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">outer</span><span class="o">-</span><span class="kr">module</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">optimize</span><span class="o">-</span><span class="n">erasable</span><span class="o">-</span><span class="kr">datatype</span><span class="o">-</span><span class="n">wrapper</span></code>,
affect what target language code the same Dafny code is translated to.
In order to translate Dafny libraries separately from their consuming codebases,
the translation process for consuming code needs to be aware
of what options were used when translating the library.</p>

<p>For example, if a library defines a <code class="language-dafny highlighter-rouge"><span class="n">Foo</span><span class="p">()</span></code> function in an <code class="language-dafny highlighter-rouge"><span class="n">A</span></code> module,
but <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">outer</span><span class="o">-</span><span class="kr">module</span> <span class="n">org</span><span class="o">.</span><span class="n">coolstuff</span><span class="o">.</span><span class="n">foolibrary</span><span class="o">.</span><span class="n">dafnyinternal</span></code> is specified when translating the library to Java,
then a reference to <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">Foo</span><span class="p">()</span></code> in a consuming Dafny project
needs to be translated to <code class="language-dafny highlighter-rouge"><span class="n">org</span><span class="o">.</span><span class="n">coolstuff</span><span class="o">.</span><span class="n">foolibrary</span><span class="o">.</span><span class="n">dafnyinternal</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">Foo</span><span class="p">()</span></code>,
independently of what value of <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">outer</span><span class="o">-</span><span class="kr">module</span></code> is used for the consuming project.</p>

<p>To meet this need,
<code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code> also outputs a <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">program</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;-&lt;</span><span class="n">target</span> <span class="n">id</span><span class="o">&gt;.</span><span class="n">dtr</span></code> Dafny Translation Record file.
Like <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">doo</span></code> files, <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dtr</span></code> files record all the relevant options that were used,
in this case relevant to translation rather than verification.
These files can be provided to future calls to <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code> using the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">translation</span><span class="o">-</span><span class="n">record</span></code> option,
in order to provide the details of how various libraries provided with the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">library</span></code> flag were translated.</p>

<p>Currently <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">outer</span><span class="o">-</span><span class="kr">module</span></code> is the only option recorded in <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dtr</span></code> files,
but more relevant options will be added in the future.
A later version of Dafny will also require <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dtr</span></code> files that cover all modules
that are defined in <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">library</span></code> options,
to support checking that all relevant options are compatible.</p>

<h3 id="sec-dafny-standard-libraries">13.4. Dafny Standard Libraries</h3>

<p>As of Dafny 4.4, the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool includes standard libraries that any Dafny code base can depend on.
For now they are only available when the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">standard</span><span class="o">-</span><span class="n">libraries</span></code> option is provided,
but they will likely be available by default in the next major version of Dafny.</p>

<p>See https://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/README.md for details.</p>

<h3 id="135-dafny-code-style">13.5. Dafny Code Style</h3>

<p>There are coding style conventions for Dafny code, recorded <a href="https://dafny-lang.github.io/dafny/StyleGuide/Style-Guide">here</a>.
Most significantly, code is written without tabs and with a 2 space indentation. Following code style conventions 
improves readability but does not alter program semantics.</p>

<h3 id="command-line">13.6. Using Dafny From the Command Line</h3>

<p><code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> is a conventional command-line tool, operating just like other
command-line tools in Windows and Unix-like systems.
In general, the format of a command-line is determined by the shell program that is executing the command-line 
(.e.g., bash, the windows shell, COMMAND, etc.), 
but is expected to be a series of space-separated words, each representing a command, option, option argument, file, or folder.</p>

<h4 id="sec-dafny-commands">13.6.1. dafny commands</h4>

<p>As of v3.9.0, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> uses a command-style command-line (like <code class="language-dafny highlighter-rouge"><span class="n">git</span></code> for example); prior to v3.9.0, the 
command line consisted only of options and files.
It is expected that additional commands will be added in the future.
Each command may have its own subcommands and its own options, in addition to generally applicable options. 
Thus the format of the command-line is
a command name, followed by options and files:
<code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">options</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">files</span><span class="o">&gt;</span></code>;
the command-name must be the first command-line argument.</p>

<p>The command-line <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">--</span><span class="n">help</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">-</span><span class="n">h</span></code> lists all the available commands.</p>

<p>The command-line <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">help</span></code> (or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">h</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">?</span></code>) gives help information for that particular &lt;command&gt;, including the list of options.
Some options for a particular command are intended only for internal tool development; those are shown using the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">help</span><span class="o">-</span><span class="n">internal</span></code> option instead of <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">help</span></code>.</p>

<p>Also, the command-style command-line has modernized the syntax of options; they are now POSIX-compliant.
Like many other tools, options now typically begin with a double hyphen, 
with some options having a single-hyphen short form, such as <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">help</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">h</span></code>.</p>

<p>If no &lt;command&gt; is given, then the command-line is presumed to use old-style syntax, so any previously 
written command-line will still be valid.</p>

<p><code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> recognizes the commands described in the following subsections. The most commonly used
are <a href="#sec-dafny-verify"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">verify</span></code></a>, <a href="#sec-dafny-build"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code></a>, and <a href="#sec-dafny-run"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code></a>.</p>

<p>The command-line also expects the following:</p>
<ul>
  <li>Files are designated by absolute paths or paths relative to the current
working directory. A command-line argument not matching a known option is considered a filepath, and likely one
with an unsupported suffix, provoking an error message.</li>
  <li>Files containing dafny code must have a <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> suffix.</li>
  <li>There must be at least one <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> file (except when using <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">stdin</span></code> or in the case of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">format</span></code>, see the <a href="#sec-dafny-format">Dafny format section</a>)</li>
  <li>The command-line may contain other kinds of files appropriate to
the language that the Dafny files are being compiled to. The kind of file is determined by its suffix.</li>
  <li>Escape characters are determined by the shell executing the command-line.</li>
  <li>Per POSIX convention, the option <code class="language-dafny highlighter-rouge"><span class="o">--</span></code> means that all subsequent command-line arguments are not options to the dafny tool; they are either files or arguments to the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> command.</li>
  <li>If an option is repeated (e.g., with a different argument), then the later instance on the command-line supersedes the earlier instance, with just a few options accumulating arguments.</li>
  <li>If an option takes an argument, the option name is followed by a <code class="language-dafny highlighter-rouge"><span class="o">:</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">=</span></code> or whitespace and then by the argument value; if the argument itself contains white space, the argument must be enclosed in quotes. It is recommended to use the <code class="language-dafny highlighter-rouge"><span class="o">:</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">=</span></code> style to avoid misinterpretation or separation of a value from its option.</li>
  <li>Boolean options can take the values <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code> and <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> (or any case-insensitive version of those words). For example, the value of <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code> is by default <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> (that is, do verification). 
It can be explicitly set to true (no verification) using <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span><span class="o">:</span><span class="kc">true</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span><span class="o">=</span><span class="kc">true</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">noverify</span> <span class="kc">true</span></code>; 
it can be explicitly set false (do verification) using <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span><span class="o">:</span><span class="kc">false</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span><span class="o">=</span><span class="kc">false</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span> <span class="kc">false</span></code>.</li>
  <li>There is a potential ambiguity when the form <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">option</span> <span class="n">value</span></code> is used if the value is optional (such as for boolean values). In such a case an argument after an option (that does not have an argument given with <code class="language-dafny highlighter-rouge"><span class="o">:</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">=</span></code>) is interpreted as the value if it is indeed a valid value for that option. However, better style advises always using a : or = to set option values.
No valid option values in dafny look like filenames or begin with <code class="language-dafny highlighter-rouge"><span class="o">--</span></code>.</li>
</ul>

<h5 id="13611-options-that-are-not-associated-with-a-command">13.6.1.1. Options that are not associated with a command</h5>

<p>A few options are not part of a command. In these cases any single-hyphen spelling also permits a spelling beginning with /.</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">--</span><span class="n">help</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">-</span><span class="n">h</span></code> lists all the available commands</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">-</span><span class="n">?</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">-</span><span class="n">help</span></code> list all legacy options</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">--</span><span class="n">version</span></code> (or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">version</span></code>) prints out the number of the version this build of dafny implements</li>
</ul>

<h5 id="sec-dafny-resolve">13.6.1.2. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">resolve</span></code></h5>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">resolve</span></code> command checks the command-line and then parses and typechecks the given files and any included files.</p>

<p>The set of files considered by <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> are those listed on the command-line,
including those named in a <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">library</span></code> option, and all files that are
named, recursively, in <code class="language-dafny highlighter-rouge"><span class="kr">include</span></code> directives in files in the set being considered by the tool.</p>

<p>The set of files presented to an invocation of the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool must 
contain all the declarations needed to resolve all names and types, 
else name or type resolution errors will be emitted.</p>

<p><code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> can parse and verify sets of files that do not form a 
complete program because they are missing the implementations of 
some constructs such as functions, lemmas, and loop bodies.<sup id="fnref:incomplete" role="doc-noteref"><a href="#fn:incomplete" class="footnote" rel="footnote">16</a></sup>
However, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> will need all implementations in order to compile a working executable.</p>

<p>declaration and implementation of methods, functions and types in separate files, nor, for that matter,
separation of specification and declaration. Implementations can be 
omitted simply by leaving them out of the declaration (or a lemma, for example).
However, a combination of <a href="#sec-trait-types"><code class="language-dafny highlighter-rouge"><span class="n">traits</span></code></a> and
<a href="#sec-class-types"><code class="language-dafny highlighter-rouge"><span class="n">classes</span></code></a> can achieve a separation of interface
and specification from
implementation.</p>

<p>The options relevant to this command are</p>
<ul>
  <li>those relevant to the command-line itself
    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">warnings</span></code>  return a success <a href="#sec-exit-codes">exit code</a>, even when there are warnings</li>
    </ul>
  </li>
  <li>those that affect dafny` as a whole, such as
    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">cores</span></code>  set the number of cores dafny should use</li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">snippets</span></code>  emit a line or so of source code along with an error message</li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">library</span></code>  include this file in the program, but do not verify or compile it (multiple such library files can be listed using multiple instances of the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">library</span></code> option)</li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">stdin</span></code>  read from standard input</li>
    </ul>
  </li>
  <li>those that affect the syntax of Dafny, such as
    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">prelude</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="kr">function</span><span class="o">-</span><span class="n">syntax</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">quantifier</span><span class="o">-</span><span class="n">syntax</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">track</span><span class="o">-</span><span class="kr">print</span><span class="o">-</span><span class="n">effects</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">warn</span><span class="o">-</span><span class="n">shadowing</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">warn</span><span class="o">-</span><span class="n">missing</span><span class="o">-</span><span class="kr">constructor</span><span class="o">-</span><span class="n">parentheses</span></code></li>
    </ul>
  </li>
</ul>

<h5 id="sec-dafny-verify">13.6.1.3. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">verify</span></code></h5>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">verify</span></code> command performs the <a href="#sec-dafny-resolve"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">resolve</span></code></a> checks and then attempts to verify each method in the files listed on the command line. Although the Dafny program being considered
consists of the listed files and any included files (recursively), by default only listed files are verified.</p>

<p>A guide to controlling and aiding the verification process is given in <a href="#sec-verification">a later section</a>.</p>

<p>To be considered <em>verified</em> all the methods in all the files in a program must be verified, with consistent sets of options,
and with no unproven assumptions (see <a href="#sec-dafny-audit"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">audit</span></code></a> for a tool to help identify such assumptions).</p>

<p>Dafny works <em>modularly</em>, meaning that each method is considered by itself, using only the specifications of other methods.
So, when using the dafny tool, you can verify the program all at once or one file at a time or groups of files at a time.
On a large program, verifying all files at once can take quite a while, with little feedback as to progress, though it does
save a small amount of work by parsing all files just once. But, one way or another, to have a complete verification, all 
implementations of all methods and functions must eventually be verified.</p>

<ul>
  <li>By default, only those files listed on the command-line are verified in a given invocation of the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool.</li>
  <li>The option <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verify</span><span class="o">-</span><span class="n">included</span><span class="o">-</span><span class="n">files</span></code> (<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">verifyAllModules</span></code> in legacy mode) forces the contents of all non-library files to be verified, whether they are listed on the command-line or recursively included by files on the command-line.</li>
  <li>The <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">library</span></code> option marks files that are excluded from <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verify</span><span class="o">-</span><span class="n">included</span><span class="o">-</span><span class="n">files</span></code>. Such a file may also, but need not, be the target of an <code class="language-dafny highlighter-rouge"><span class="kr">include</span></code> directive in some file of the program; in any case, such files are included in the program but not in the set of files verified (or compiled). The intent of this option is to mark files that
should be considered as libraries that are independently verified prior to being released for shared use.</li>
  <li>Verifying files individually is equivalent to verifying them in groups, presuming no other changes.
It is also permitted to verify completely disjoint files or
programs together in a single run of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code>.</li>
</ul>

<p>Various options control the verification process, in addition to all those described for <a href="#sec-dafny-resolve"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">resolve</span></code></a>.</p>

<ul>
  <li>What is verified
    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verify</span><span class="o">-</span><span class="n">included</span><span class="o">-</span><span class="n">files</span></code> (when enabled, all included files are verified, except library files, otherwise just those files on the command-line)</li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">relax</span><span class="o">-</span><span class="n">definite</span><span class="o">-</span><span class="n">assignment</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">track</span><span class="o">-</span><span class="kr">print</span><span class="o">-</span><span class="n">effects</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">disable</span><span class="o">-</span><span class="n">nonlinear</span><span class="o">-</span><span class="n">arithmetic</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">filter</span><span class="o">-</span><span class="n">symbol</span></code></li>
    </ul>
  </li>
  <li>Control of the proof engine
    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verification</span><span class="o">-</span><span class="n">time</span><span class="o">-</span><span class="n">limit</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">boogie</span></code></li>
    </ul>
  </li>
</ul>

<h5 id="sec-dafny-translate">13.6.1.4. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span> <span class="o">&lt;</span><span class="n">language</span><span class="o">&gt;</span></code></h5>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code> command translates Dafny source code to source code for another target programming language.
The command always performs the actions of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">resolve</span></code> and, unless the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code> option is specified, does the actions of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">verify</span></code>.
The language is designated by a subcommand argument, rather than an option, and is required.
The current set of supported target languages is</p>
<ul>
  <li>cs (C#)</li>
  <li>java (Java)</li>
  <li>js (JavaScript)</li>
  <li>py (Python)</li>
  <li>go (Go)</li>
  <li>cpp (C++  but only limited support)</li>
</ul>

<p>In addition to generating the target source code, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> may generate build artifacts to assist in compiling the generated code.
The specific files generated depend on the target programming language.
More detail is given in <a href="#sec-compilation">the section on compilation</a>.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool intends that the compiled program in the target language be a semantically faithful rendering of the 
(verified) Dafny program. However, resource and language limitations make this not always possible. 
For example, though Dafny can express and reason about arrays of unbounded size, 
not all target programming languages can represent arrays larger than the maximum signed 32-bit integer.</p>

<p>Various options control the translation process, in addition to all those described for <a href="#sec-dafny-resolve"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">resolve</span></code></a> and <a href="#sec-dafny-verify"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">verify</span></code></a>.</p>

<ul>
  <li>General options:
    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code>  turns off all attempts to verify the program</li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verbose</span></code>  print information about generated files</li>
    </ul>
  </li>
  <li>The translation results
    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">output</span></code> (or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">o</span></code>)  location of the generated file(s) (this specifies a file path and name; a folder location for artifacts is derived from this name)</li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="kr">include</span><span class="o">-</span><span class="n">runtime</span></code>  include the Dafny runtime for the target language in the generated artifacts</li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">optimize</span><span class="o">-</span><span class="n">erasable</span><span class="o">-</span><span class="kr">datatype</span><span class="o">-</span><span class="n">wrapper</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">enforce</span><span class="o">-</span><span class="n">determinism</span></code></li>
      <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">test</span><span class="o">-</span><span class="n">assumptions</span></code>  (experimental) inserts runtime checks for unverified assumptions when they are compilable</li>
    </ul>
  </li>
</ul>

<h5 id="sec-dafny-build">13.6.1.5. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code></h5>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> command runs <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code> and then compiles the result into an executable artifact for the target platform,
such as a <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">exe</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dll</span></code> or executable <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">jar</span></code>, or just the source code for an interpreted language.
If the Dafny program does not have a Main entry point, then the build command creates a library, such as a <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dll</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">jar</span></code>.
As with <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code>, all the previous phases are also executed, including verification (unless <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code> is a command-line option).
By default, the generated file is in the same directory and has the same name with a different extension as the first
.dfy file on the command line. This location and name can be set by the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">output</span></code> option.</p>

<p>The location of the <code class="language-dafny highlighter-rouge"><span class="n">Main</span></code> entry point is described [here](#sec-user-guide-main}.</p>

<p>There are no additional options for <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> beyond those for <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code> and the previous compiler phases.</p>

<p>Note that <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> may do optimizations that <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> does not.</p>

<p>Details for specific target platforms are described <a href="#sec-compilation">in Section 25.7</a>.</p>

<h5 id="sec-dafny-run">13.6.1.6. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code></h5>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> command compiles the Dafny program and then runs the resulting executable.
Note that <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> is engineered to quickly compile and launch the program; 
<code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> may take more time to do optimizations of the build artifacts.</p>

<p>The form of the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> command-line is slightly different than for other commands.</p>
<ul>
  <li>It permits just one <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> file, which must be the file containing the <code class="language-dafny highlighter-rouge"><span class="n">Main</span></code> entry point;
the location of the <code class="language-dafny highlighter-rouge"><span class="n">Main</span></code> entry point is described [here](#sec-user-guide-main}.</li>
  <li>Other files are included in the program either by <code class="language-dafny highlighter-rouge"><span class="kr">include</span></code> directives within that one file or by 
the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">input</span></code> option on the command-line.</li>
  <li>Anything that is not an option and is not that one dfy file
is an argument to the program being run (and not to dafny itself).</li>
  <li>If the <code class="language-dafny highlighter-rouge"><span class="o">--</span></code> option is used, then anything after that option is a command-line argument to the program being run.</li>
</ul>

<p>During development, users must use <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">warnings</span></code> if they want to run their Dafny code when it contains warnings.</p>

<p>Here are some examples:</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code>  builds and runs the Main program in <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code> with no command-line arguments</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code>  builds the Main program in <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code> using the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code> option, and then runs the program with no command-line arguments</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span> <span class="o">--</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code>  builds the Main program in <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code> (<em>not</em> using the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code> option), and then runs the program with one command-line argument, namely <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="n">B</span><span class="o">.</span><span class="n">dfy</span></code>  builds the Main program in <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code> and
then runs it with the four command-line arguments <code class="language-dafny highlighter-rouge"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="n">B</span><span class="o">.</span><span class="n">dfy</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="o">--</span><span class="n">input</span> <span class="n">B</span><span class="o">.</span><span class="n">dfy</span></code>  builds the Main program in <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">B</span><span class="o">.</span><span class="n">dfy</span></code>, and
then runs it with the three command-line arguments <code class="language-dafny highlighter-rouge"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">--</span> <span class="mi">3</span> <span class="o">-</span><span class="n">quiet</span></code>  builds the Main program in <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code> and then runs it with the four command-line arguments <code class="language-dafny highlighter-rouge"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="o">-</span><span class="n">quiet</span></code></li>
</ul>

<p>Each time <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> is invoked, the input Dafny program is compiled before it is executed.
If a Dafny program should be run more than once, it can be faster to use <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code>,
which enables compiling a Dafny program once and then running it multiple times.</p>

<p><strong>Note:</strong> <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> will typically produce the same results as the executables produced by <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code>.  The only expected differences are these:</p>
<ul>
  <li>performance  <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> may not optimize as much as <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code></li>
  <li>target-language-specific configuration issues   e.g. encoding issues: <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> sets language-specific flags to request UTF-8 output for the <a href="#print-encoding"><code class="language-dafny highlighter-rouge"><span class="kr">print</span></code></a> statement in all languages, whereas <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> leaves language-specific runtime configuration to the user.</li>
</ul>

<h5 id="sec-dafny-server">13.6.1.7. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">server</span></code></h5>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">server</span></code> command starts the Dafny Language Server, which is an <a href="https://microsoft.github.io/language-server-protocol/">LSP-compliant</a> implementation of Dafny.
The <a href="">Dafny VSCode extension</a> uses this LSP implementation, which in turn uses the same core Dafny implementation as the command-line tool.</p>

<p>The Dafny Language Server is described in more detail <a href="#sec-dafny-language-server-vscode">here</a>.</p>

<h5 id="sec-dafny-audit">13.6.1.8. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">audit</span></code></h5>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">audit</span></code> command reports issues in the Dafny code that might limit the soundness claims of verification.</p>

<p><em>This command is under development.</em></p>

<p>The command executes the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">resolve</span></code> phase (accepting its options) and has the following additional options:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">report</span><span class="o">-</span><span class="n">file</span><span class="o">:&lt;</span><span class="n">report</span><span class="o">-</span><span class="n">file</span><span class="o">&gt;</span></code>  specifies the path where the audit
 report file will be stored. Without this option, the report
  will be issued as standard warnings, written to standard-out.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">report</span><span class="o">-</span><span class="n">format</span><span class="o">:&lt;</span><span class="n">format</span><span class="o">&gt;</span></code>  specifies the file format to use for
 the audit report. Supported options include:
    <ul>
      <li>txt, text: plain text in the format of warnings</li>
      <li>html: standalone HTML (html)</li>
      <li>md, markdown, md-table, markdown-table: a Markdown table</li>
      <li>md-ietf, markdown-ietf: an IETF-language document in Markdown format</li>
      <li>The default is to infer the format from the filename extension</li>
    </ul>
  </li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">compare</span><span class="o">-</span><span class="n">report</span></code>  compare the report that would have
 been generated with the existing file given by report-file, and fail if
 they differ.</li>
</ul>

<p>The command emits exit codes of</p>
<ul>
  <li>1 for command-line errors</li>
  <li>2 for parsing, type-checking or serious errors in running the auditor (e.g. failure to write a report or when report comparison fails)</li>
  <li>0 for normal operation, including operation that identifies audit findings</li>
</ul>

<p>It also takes the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verbose</span></code> option, which then gives information about the files being formatted.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">audit</span></code> command currently reports the following:</p>

<ul>
  <li>
    <p>Any declaration marked with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code> attribute.
This is typically used to mark that a lemma with no body (and is therefore assumed to always be true) is intended as an axiom.
The key purpose of the <code class="language-dafny highlighter-rouge"><span class="n">audit</span></code> command is to ensure that all assumptions are intentional and acknowledged.
To improve assurance, however, try to provide a proof.</p>
  </li>
  <li>
    <p>Any declaration marked with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">verify</span> <span class="kc">false</span><span class="p">}</span></code> attribute, which tells the verifier to skip verifying this declaration.
Removing the attribute and providing a proof will improve assurance.</p>
  </li>
  <li>
    <p>Any declaration marked with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> attribute that has at least one <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause.
If code implemented externally, and called from Dafny, has an <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause, Dafny assumes that it satisfies that clause.
Since Dafny cannot prove properties about code written in other languages,
adding tests to provide evidence that any <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses do hold can improve assurance.
The same considerations apply to <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses on Dafny code intended to be called from external code.</p>
  </li>
  <li>
    <p>Any definition with an <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> statement in its body.
To improve assurance, attempt to convert it to an <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statement and prove that it holds.
Such a definition will not be compilable unless the statement is also marked with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code>.
Alternatively, converting it to an <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statement will cause it to be checked at runtime.</p>
  </li>
  <li>
    <p>Any method marked with <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span> <span class="o">*</span></code>.
Such a method may not terminate.
Although this cannot cause an unsound proof, in the logic of Dafny,
its generally important that any non-termination be intentional.</p>
  </li>
  <li>
    <p>Any <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement without a body.
This is equivalent to an assumption of its conclusion.
To improve assurance, provide a body that proves the conclusion.</p>
  </li>
  <li>
    <p>Any loop without a body.
This is equivalent to an assumption of any loop invariants in the code after the loop.
To improve assurance, provide a body that establishes any stated invariants.</p>
  </li>
  <li>
    <p>Any declaration with no body and at least one <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause.
Any code that calls this declaration will assume that all <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses are true after it returns.
To improve assurance, provide a body that proves that any <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses hold.</p>
  </li>
</ul>

<h5 id="sec-dafny-format">13.6.1.9. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">format</span></code></h5>

<p>Dafny supports a formatter, which for now only changes the indentation of lines in a Dafny file, so that it conforms
to the idiomatic Dafny code formatting style.
For the formatter to work, the file should be parsed correctly by Dafny.</p>

<p>There are four ways to use the formatter:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">format</span> <span class="o">&lt;</span><span class="n">one</span> <span class="n">or</span> <span class="n">more</span> <span class="o">.</span><span class="n">dfy</span> <span class="n">files</span> <span class="n">or</span> <span class="n">folders</span><span class="o">&gt;</span></code> formats the given Dafny files and the Dafny files in the folders, recursively, altering the files in place. For example, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">format</span> <span class="o">.</span></code> formats all the Dafny files recursively in the current folder.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">format</span> <span class="o">--</span><span class="kr">print</span> <span class="o">&lt;</span><span class="n">files</span> <span class="n">and</span><span class="o">/</span><span class="n">or</span> <span class="n">folders</span><span class="o">&gt;</span></code> formats each file but instead of altering the files, output the formatted content to stdout</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">format</span> <span class="o">--</span><span class="n">check</span> <span class="o">&lt;</span><span class="n">files</span> <span class="n">and</span><span class="o">/</span><span class="n">or</span> <span class="n">folders</span><span class="o">&gt;</span></code> does not alter files. It will print a message concerning which files need formatting and return a non-zero exit code if any files would be changed by formatting.</li>
</ul>

<p>You can also use <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">stdin</span></code> instead of providing a file, to format a full Dafny file from the standard input.
Input files can be named along with <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">stdin</span></code>, in which case both the files and the content of the stdin are formatted.</p>

<p>Each version of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">format</span></code> returns a non-zero return code if there are any command-line or parsing
errors or if check is stipulated and at least one file is not the same as its formatted version.<br />
<code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">format</span></code> does not necessarily report name or type resolution errors and does not attempt verification.</p>

<h5 id="sec-dafny-test">13.6.1.10. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">test</span></code></h5>

<p>This command (verifies and compiles the program and) runs every method in the program that is annotated with the <a href="#sec-test-attribute"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span></code> attribute</a>.
Verification can be disabled using the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code> option. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">test</span></code> also accepts all other options of the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> command. 
In particular, it accepts the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">target</span></code> option that specifies the programming language used in the build and execution phases.</p>

<p><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">test</span></code> also accepts these options:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">spill</span><span class="o">-</span><span class="n">translation</span></code> - (default disabled) when enabled the compilation artifacts are retained</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">output</span></code> - gives the folder and filename root for compilation artifacts</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">methods</span><span class="o">-</span><span class="kr">to</span><span class="o">-</span><span class="n">test</span></code> - the value is a (.NET) regular expression that is matched against the fully
qualified name of the method; only those methods that match are tested</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">coverage</span><span class="o">-</span><span class="n">report</span></code> - the value is a directory in which Dafny will save an html coverage report highlighting parts of
the program that execution of the tests covered.</li>
</ul>

<p>The order in which the tests are run is not specified.</p>

<p>For example, this code (as the file <code class="language-dafny highlighter-rouge"><span class="n">t</span><span class="o">.</span><span class="n">dfy</span></code>)
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">mm</span><span class="p">();</span>
  <span class="kr">print</span> <span class="s2">"Hi!\n"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">mm</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">print</span> <span class="s2">"mm\n"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span> <span class="n">q</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">print</span> <span class="mi">42</span><span class="p">,</span> <span class="s2">"\n"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span> <span class="n">t</span><span class="p">()</span> <span class="p">{</span> <span class="kr">print</span> <span class="s2">"T\n"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>and this command-line</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>dafny <span class="nb">test</span> <span class="nt">--no-verify</span> t.dfy
</code></pre></div></div>
<p>produce this output text:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code>M.q: 42
PASSED
A.t: T
PASSED
m: mm
Hi!
PASSED
</code></pre></div></div>

<p>and this command-line</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>dafny <span class="nb">test</span> <span class="nt">--no-verify</span> <span class="nt">--methods-to-test</span><span class="o">=</span><span class="s1">'m'</span> t.dfy
</code></pre></div></div>
<p>produces this output text:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code>m: mm
Hi!
PASSED
</code></pre></div></div>

<h5 id="sec-dafny-doc">13.6.1.11. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">doc</span></code> [Experimental]</h5>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">doc</span></code> command generates HTML documentation pages describing the contents of each
module in a set of files, using the documentation comments in the source files.
This command is experimental; user feedback and contributor PRs on the layout of information and the navigation are welcome.</p>

<ul>
  <li>The format of the documentation comments is described <a href="#sec-documentation-comments">here</a>.</li>
  <li>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">doc</span></code> command accepts either files or folders as command-line arguments. A folder
represents all the <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> files contained recursively in that folder. A file that is a <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">toml</span></code>
<a href="#sec-project-files">project file</a> represents all the files and options listed in the project file.</li>
  <li>The command first parses and resolves the given files; it only proceeds to produce documentation
if type resolution is successful (on all files). All the command-line options relevant to 
<code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">resolve</span></code> are available for <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">doc</span></code>.</li>
  <li>The value of the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">output</span></code> option is a folder in which all the generated files will be placed.
The default location is <code class="language-dafny highlighter-rouge"><span class="o">./</span><span class="n">docs</span></code>. The folder is created if it does not already exist.
Any existing content of the folder is overwritten.</li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verbose</span></code> is enabled, a list of the generated files is emitted to stdout.</li>
  <li>The output files contain information stating the source .dfy file in which the module is
declared. The <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">file</span><span class="o">-</span><span class="n">name</span></code> option controls the form of the filename in that information:
    <ul>
      <li>file-name:none  no source file information is emitted</li>
      <li>file-name:name  (default) just the file name is emitted (e.g., <code class="language-dafny highlighter-rouge"><span class="n">Test</span><span class="o">.</span><span class="n">dfy</span></code>)</li>
      <li>file-name:absolute  an absolute full path is emitted</li>
      <li>file-name:relative=<prefix> -- a file name relative to the given prefix is emitted</prefix></li>
    </ul>
  </li>
  <li>If <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="kr">modify</span><span class="o">-</span><span class="n">time</span></code> is enabled, then the generated files contain information stating the
last modified time of the source of the module being documented.</li>
  <li>The <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">program</span><span class="o">-</span><span class="n">name</span></code> option states text that will be included in the heading of the TOC and index pages</li>
</ul>

<p>The output files are HTML files, all contained in the given folder, one per module plus an 
<code class="language-dafny highlighter-rouge"><span class="n">index</span><span class="o">.</span><span class="n">html</span></code> file giving an overall table of contents and a <code class="language-dafny highlighter-rouge"><span class="n">nameindex</span><span class="o">.</span><span class="n">html</span></code> file containing
an alphabetical by name list of all the declarations in all the modules.
The documentation for the root module is in <code class="language-dafny highlighter-rouge"><span class="n">_</span><span class="o">.</span><span class="n">html</span></code>.</p>

<h5 id="sec-dafny-generate-tests">13.6.1.12. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">generate</span><span class="o">-</span><span class="n">tests</span></code></h5>

<p>This <em>experimental</em> command allows generating tests from Dafny programs.
The tests provide complete coverage of the implementation and one can execute them using the <a href="#sec-dafny-test"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">test</span></code></a> command.
Dafny can target different notions of coverage while generating tests, with basic-block coverage being the recommended setting.
Basic blocks are extracted from the Boogie representation of the Dafny program, with one basic block corresponding
to a statement or a non-short-circuiting subexpression in the Dafny code. The underlying implementation uses the 
verifier to reason about the reachability of different basic blocks in the program and infers necessary test inputs 
from counterexamples.</p>

<p>For example, this code (as the file <code class="language-dafny highlighter-rouge"><span class="n">program</span><span class="o">.</span><span class="n">dfy</span></code>)
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">testEntry</span><span class="p">}</span> <span class="n">Min</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">a</span> <span class="kr">else</span> <span class="n">b</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>and this command-line</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>dafny generate-tests Block program.dfy
</code></pre></div></div>
<p>produce two tests:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">include</span> <span class="s2">"program.dfy"</span>
<span class="kr">module</span> <span class="n">UnitTests</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="n">M</span>
  <span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span> <span class="n">Test0</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">M</span><span class="o">.</span><span class="n">Min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span> <span class="n">Test1</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">M</span><span class="o">.</span><span class="n">Min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The two tests together cover every basic block within the <code class="language-dafny highlighter-rouge"><span class="n">Min</span></code> function in the input program. 
Note that the <code class="language-dafny highlighter-rouge"><span class="n">Min</span></code> function is annotated with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">testEntry</span><span class="p">}</span></code> attribute. This attribute marks <code class="language-dafny highlighter-rouge"><span class="n">Min</span></code> as 
the entry point for all generated tests, and there must always be at least one method or function so annotated.
Another requirement is that any top-level declaration that is not itself a module (such as class, method, function, 
etc.) must be a member of an explicitly named module, which is called <code class="language-dafny highlighter-rouge"><span class="n">M</span></code> in the example above.</p>

<p><em>This command is under development and not yet fully functional.</em></p>

<h5 id="sec-dafny-generate-tests-inlining">13.6.1.13. <code class="language-dafny highlighter-rouge"><span class="n">Inlining</span></code></h5>

<p>By default, when asked to generate tests, Dafny will produce <em>unit tests</em>, which guarantee coverage of basic blocks
within the method they call but not within any of its callees. By contrast, system-level tests can
guarantee coverage of a large part of the program while at the same time using a single method as an entry point. 
In order to prompt Dafny to generate system-level tests, one must use the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">testInline</span><span class="p">}</span></code> attribute.</p>

<p>For example, this code (as the file <code class="language-dafny highlighter-rouge"><span class="n">program</span><span class="o">.</span><span class="n">dfy</span></code>)
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">testInline</span><span class="p">}</span> <span class="n">Min</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">a</span> <span class="kr">else</span> <span class="n">b</span>
  <span class="p">}</span>
  <span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">testEntry</span><span class="p">}</span> <span class="n">Max</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">c</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
    <span class="c1">// the tests convert the postcondition below into runtime check:</span>
    <span class="kr">ensures</span> <span class="n">c</span> <span class="o">==</span> <span class="kr">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">a</span> <span class="kr">else</span> <span class="n">b</span>
  <span class="p">{</span>
    <span class="kr">return</span> <span class="o">-</span><span class="n">Min</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>and this command-line</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>dafny generate-tests Block program.dfy
</code></pre></div></div>
<p>produce two tests:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">include</span> <span class="s2">"program.dfy"</span>
<span class="kr">module</span> <span class="n">UnitTests</span> <span class="p">{</span>
  <span class="kr">import</span> <span class="n">M</span>
  <span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span> <span class="n">Test0</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">M</span><span class="o">.</span><span class="n">Max</span><span class="p">(</span><span class="mi">7719</span><span class="p">,</span> <span class="mi">7720</span><span class="p">);</span>
    <span class="kr">expect</span> <span class="n">r0</span> <span class="o">==</span> <span class="kr">if</span> <span class="mi">7719</span> <span class="o">&gt;</span> <span class="mi">7720</span> <span class="kr">then</span> <span class="mi">7719</span> <span class="kr">else</span> <span class="mi">7720</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span> <span class="n">Test1</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">var</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">M</span><span class="o">.</span><span class="n">Max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kr">expect</span> <span class="n">r0</span> <span class="o">==</span> <span class="kr">if</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Without the use of the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">testInline</span><span class="p">}</span></code> attribute in the example above, Dafny will only generate a single test 
because there is only one basic-block within the <code class="language-dafny highlighter-rouge"><span class="n">Max</span></code> method itself  all the branching occurs within the <code class="language-dafny highlighter-rouge"><span class="n">Min</span></code> function.
Note also that Dafny automatically converts all non-ghost postconditions on the method under tests into <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statements,
which the compiler translates to runtime checks in the target language of choice.</p>

<p>When the inlined method or function is recursive, it might be necessary to unroll the recursion several times to 
get adequate code coverage. The depth of recursion unrolling should be provided as an integer argument to the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">testInline</span><span class="p">}</span></code>
attribute. For example, in the program below, the function <code class="language-dafny highlighter-rouge"><span class="n">Mod3</span></code> is annotated with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">testInline</span> <span class="mi">2</span><span class="p">}</span></code> and 
will, therefore, be unrolled twice during test generation. The function naively implements division by repeatedly and
recursively subtracting <code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> from its argument, and it returns the remainder of the division, which is one of 
the three base cases. Because the <code class="language-dafny highlighter-rouge"><span class="n">TestEntry</span></code> method calls <code class="language-dafny highlighter-rouge"><span class="n">Mod3</span></code> with an argument that is guaranteed to be at least <code class="language-dafny highlighter-rouge"><span class="mi">3</span></code>,
the base case will never occur on first iteration, and the function must be unrolled at least twice for Dafny to generate
tests covering any of the base cases:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">testInline</span> <span class="mi">2</span><span class="p">}</span> <span class="n">Mod3</span> <span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span><span class="o">:</span> <span class="kt">nat</span>
    <span class="kr">decreases</span> <span class="n">n</span>
  <span class="p">{</span>
    <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span>
    <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span>
    <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="kr">then</span> <span class="mi">2</span> <span class="kr">else</span>
    <span class="n">Mod3</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kr">method</span> <span class="p">{</span><span class="o">:</span><span class="n">testEntry</span><span class="p">}</span> <span class="n">TestEntry</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span> <span class="kt">nat</span><span class="p">)</span>
    <span class="kr">requires</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">3</span>
  <span class="p">{</span>
    <span class="n">r</span> <span class="o">:=</span> <span class="n">Mod3</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="sec-dafny-generate-tests-clo">13.6.1.14. <code class="language-dafny highlighter-rouge"><span class="n">Command</span> <span class="n">Line</span> <span class="n">Options</span></code></h5>

<p>Test generation supports a number of command-line options that control its behavior.</p>

<p>The first argument to appear after the <code class="language-dafny highlighter-rouge"><span class="n">generate</span><span class="o">-</span><span class="n">test</span></code> command specifies the coverage criteria Dafny will attempt to satisfy. 
Of these, we recommend basic-block coverage (specified with keyword <code class="language-dafny highlighter-rouge"><span class="n">Block</span></code>), which is also the coverage criteria used
throughout the relevant parts of this reference manual. The alternatives are path coverage (<code class="language-dafny highlighter-rouge"><span class="n">Path</span></code>) and block coverage 
after inlining (<code class="language-dafny highlighter-rouge"><span class="n">InlinedBlock</span></code>). Path coverage provides the most diverse set of tests but it is also the most expensive 
in terms of time it takes to produce these tests. Block coverage after inlining is a call-graph sensitive version of 
block coverage - it takes into account every block in a given method for every path through the call-graph to that method.</p>

<p>The following is a list of command-line-options supported by Dafny during test generation:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verification</span><span class="o">-</span><span class="n">time</span><span class="o">-</span><span class="n">limit</span></code> - the value is an integer that sets a timeout for generating a single test. 
The default is 20 seconds.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">length</span><span class="o">-</span><span class="n">limit</span></code> - the value is an integer that is used to limit the lengths or all sequences and sizes of all 
maps and sets that test generation will consider as valid test inputs. This can sometimes be necessary to 
prevent test generation from creating unwieldy tests with excessively long strings or large maps. This option is
disabled by default</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">coverage</span><span class="o">-</span><span class="n">report</span></code> - the value is a directory in which Dafny will save an html coverage report highlighting parts of
the program that the generated tests are expected to cover.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="kr">print</span><span class="o">-</span><span class="n">bpl</span></code> - the value is the name of the file to which Dafny will save the Boogie code used for generating tests.
This options is mostly useful for debugging test generation functionality itself.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">force</span><span class="o">-</span><span class="n">prune</span></code> - this flag enables axiom pruning, a feature which might significantly speed up test generation but 
can also reduce coverage or cause Dafny to produce tests that do not satisfy the preconditions.</li>
</ul>

<p>Dafny will also automatically enforce the following options during test generation: <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">enforce</span><span class="o">-</span><span class="n">determinism</span></code>, 
<code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">typeEncoding</span><span class="o">:</span><span class="n">p</span></code> (an option passed on to Boogie).</p>

<h5 id="sec-dafny-find-dead-code">13.6.1.15. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">find</span><span class="o">-</span><span class="n">dead</span><span class="o">-</span><span class="n">code</span></code></h5>

<p>This <em>experimental</em> command finds dead code in a program, that is, basic-blocks within a method that are not reachable 
by any inputs that satisfy the methods preconditions. The underlying implementation is identical to that of
<a href="#sec-dafny-test"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">generate</span><span class="o">-</span><span class="n">tests</span></code></a> command and can be controlled by the same command line options and method 
attributes.</p>

<p>For example, this code (as the file <code class="language-dafny highlighter-rouge"><span class="n">program</span><span class="o">.</span><span class="n">dfy</span></code>)
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">module</span> <span class="n">M</span> <span class="p">{</span>
  <span class="kr">function</span> <span class="p">{</span><span class="o">:</span><span class="n">testEntry</span><span class="p">}</span> <span class="n">DescribeProduct</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> 
    <span class="kr">then</span> <span class="s2">"Product is negative"</span>
    <span class="kr">else</span> <span class="s2">"Product is nonnegative"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>and this command-line</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>dafny find-dead-code program.dfy
</code></pre></div></div>
<p>produce this output:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code>program.dfy(5,9) is reachable.
program.dfy(3,4):initialstate is reachable.
program.dfy.dfy(5,9)#elseBranch is reachable.
program.dfy.dfy(4,9)#thenBranch is potentially unreachable.
Out of 4 basic blocks, 3 are reachable.
</code></pre></div></div>

<p>Dafny reports that the then branch of the condition is potentially unreachable because the verifier proves that no
input can reach it. In this case, this is to be expected, since the product of two numbers can never be negative. In
practice, <code class="language-dafny highlighter-rouge"><span class="n">find</span><span class="o">-</span><span class="n">dead</span><span class="o">-</span><span class="n">code</span></code> command can produce both false positives (if the reachability query times out) and false
negatives (if the verifier cannot prove true unreachability), so the results of such a report should always be
reviewed.</p>

<p><em>This command is under development and not yet fully functional.</em></p>

<h5 id="sec-dafny-measure-complexity">13.6.1.16. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">measure</span><span class="o">-</span><span class="n">complexity</span></code></h5>

<p>This <em>experimental</em> command reports complexity metrics of a program.</p>

<p><em>This command is under development and not yet functional.</em></p>

<h5 id="136117-plugins">13.6.1.17. Plugins</h5>

<p>This execution mode is not a command, per se, but rather a command-line option that enables executing plugins to the dafny tool.</p>

<p>The form of the command-line is <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">--</span><span class="n">plugin</span><span class="o">:&lt;</span><span class="n">path</span><span class="o">-</span><span class="kr">to</span><span class="o">-</span><span class="n">one</span><span class="o">-</span><span class="n">assembly</span><span class="p">[,</span><span class="n">argument</span><span class="p">]</span><span class="o">*&gt;</span></code>
where the argument to <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">plugin</span></code> gives the path to the compiled assembly of the plugin and the arguments to be provided to the plugin.</p>

<p>More on writing and building plugins can be found <a href="#sec-plugins">in this section</a>.</p>

<h5 id="136118-legacy-operation">13.6.1.18. Legacy operation</h5>

<p>Prior to implementing the command-based CLI, the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> command-line simply took files and options and the arguments to options.
That legacy mode of operation is still supported, though discouraged. The command <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">-</span><span class="n">?</span></code> produces the list of legacy options.
In particular, the common commands like <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">verify</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> are accomplished with combinations of 
options like <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">compile</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">compileTarget</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">spillTargetCode</span></code>.</p>

<p>Users are encouraged to migrate to the command-based style of command-lines and the double-hyphen options.</p>

<h4 id="1362-in-tool-help">13.6.2. In-tool help</h4>

<p>As is typical for command-line tools, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> provides in-tool help through the <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">h</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">help</span></code> options:</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">-</span><span class="n">h</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">--</span><span class="n">help</span></code> list the commands available in the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">-</span><span class="n">?</span></code> lists all the (legacy) options implemented in <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">h</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span> <span class="o">--</span><span class="n">help</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">?</span></code> list the options available for that command</li>
</ul>

<h4 id="sec-exit-codes">13.6.3. dafny exit codes</h4>

<p>The basic resolve, verify, translate, build, run and commands of dafny terminate with these exit codes.</p>

<ul>
  <li>0  success</li>
  <li>1  invalid command-line arguments</li>
  <li>2  syntax, parse, or name or type resolution errors</li>
  <li>3  compilation errors</li>
  <li>4  verification errors</li>
</ul>

<p>Errors in earlier phases of processing typically hide later errors.
For example, if a program has parsing errors, verification or compilation will
not be attempted.</p>

<p>Other dafny commands may have their own conventions for exit codes. 
However in all cases, an exit code of 0 indicates successful completion of the commands
task and small positive integer values indicate errors of some sort.</p>

<h4 id="1364-dafny-output">13.6.4. dafny output</h4>

<p>Most output from <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> is directed to the standard output of the shell invoking the tool, though some goes to standard error.</p>
<ul>
  <li>Command-line errors: these are produced by the dotnet CommandLineOptions package are directed to <strong>standard-error</strong></li>
  <li>Other errors: parsing, typechecking, verification and compilation errors are directed to <strong>standard-out</strong></li>
  <li>Non-error progress information also is output to <strong>standard-out</strong></li>
  <li>Dafny <code class="language-dafny highlighter-rouge"><span class="kr">print</span></code> statements, when executed, send output to <strong>standard-out</strong></li>
  <li>Dafny <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statements (when they fail) send a message to <strong>standard-out</strong>.</li>
  <li>Dafny I/O libraries send output explicitly to either <strong>standard-out or standard-error</strong></li>
</ul>

<h4 id="sec-project-files">13.6.5. Project files</h4>

<p>Commands on the Dafny CLI that can be passed a Dafny file can also be passed a Dafny project file. Such a project file may define which Dafny files the project contains and which Dafny options it uses. The project file must be a <a href="https://toml.io/en/">TOML</a> file named <code class="language-dafny highlighter-rouge"><span class="n">dfyconfig</span><span class="o">.</span><span class="n">toml</span></code> for it to work on both the CLI and in the Dafny IDE, although the CLI will accept any <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">toml</span></code> file. 
Heres an example of a Dafny project file:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="py">includes</span> <span class="p">=</span> <span class="p">[</span><span class="s">"src/**/*.dfy"</span><span class="p">]</span>
<span class="py">excludes</span> <span class="p">=</span> <span class="p">[</span><span class="s">"**/ignore.dfy"</span><span class="p">]</span>

<span class="py">base</span> <span class="p">=</span> <span class="p">[</span><span class="s">"../commonOptions.dfyconfig.toml"</span><span class="p">]</span>

<span class="nn">[options]</span>
<span class="py">enforce-determinism</span> <span class="p">=</span> <span class="kc">true</span>
<span class="py">warn-shadowing</span> <span class="p">=</span> <span class="kc">true</span>
</code></pre></div></div>

<ul>
  <li>At most one <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">toml</span></code> file may be named on the command-line; when using the command-line no <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">toml</span></code> file is used by default.</li>
  <li>In the <code class="language-dafny highlighter-rouge"><span class="n">includes</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">excludes</span></code> lists, the file paths may have wildcards, including <code class="language-dafny highlighter-rouge"><span class="o">**</span></code> to mean any number of directory levels; filepaths are relative to the location of the <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">toml</span></code> file in which they are named.</li>
  <li>Dafny will process the union of (a) the files on the command-line and (b) the files designated in the <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">toml</span></code> file, which are those specified by the <code class="language-dafny highlighter-rouge"><span class="n">includes</span></code>, omitting those specified by the <code class="language-dafny highlighter-rouge"><span class="n">excludes</span></code>.
The <code class="language-dafny highlighter-rouge"><span class="n">excludes</span></code> does not remove any files that are listed explicitly on the command-line.</li>
  <li>Under the section <code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="n">options</span><span class="p">]</span></code>, any options from the Dafny CLI can be specified using the options name without the <code class="language-dafny highlighter-rouge"><span class="o">--</span></code> prefix.</li>
  <li>When executing a <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> command using a project file, any options specified in the file that can be applied to the command, will be. Options that cant be applied are ignored; options that are invalid for any dafny command trigger warnings.</li>
  <li>Options specified on the command-line take precedence over any specified in the project file, no matter the order of items on the command-line.</li>
  <li>
    <p>When using a Dafny IDE based on the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">server</span></code> command, the IDE will search for project files by traversing up the file tree looking for the closest <code class="language-dafny highlighter-rouge"><span class="n">dfyconfig</span><span class="o">.</span><span class="n">toml</span></code> file to the dfy being parsed that it can find. Options from the project file will override options passed to <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">server</span></code>.</p>
  </li>
  <li>The field base can be used to let one project file inherit options from another. If an option is specified in both, then the value specified in the inheriting project is used. Includes from the inheritor override excludes from the base.</li>
</ul>

<p>Its not possible to use Dafny project files in combination with the legacy CLI UI.</p>

<h3 id="sec-verification">13.7. Verification</h3>

<p>In this section, we suggest a methodology to figure out <a href="#sec-verification-debugging">why Dafny cannot prove a single assertion</a>, we propose techniques to deal with <a href="#sec-verification-debugging-slow">assertions that slow a proof down</a>, we explain how to <a href="#sec-assertion-batches">verify assertions in parallel or in a focused way</a>, and we also give some more examples of <a href="#sec-command-line-options-and-attributes-for-verification">useful options and attributes to control verification</a>.</p>

<h4 id="sec-verification-debugging">13.7.1. Verification debugging when verification fails</h4>

<p>Lets assume one assertion is failing (assertion could not be proved or postcondition could not be proved). What should you do next?
First, its good to know that if an assertion is failing, it means that the assertion might not hold or that Dafny would requires more proof hints, which can be found in a mechanical way.</p>

<p>The following section is textual description of the animation below, which illustrates the principle of debugging an assertion by computing the weakest precondition:<br />
<img src="https://user-images.githubusercontent.com/3601079/157976402-83fe4d37-8042-40fc-940f-bcfc235c7d2b.gif" alt="weakestpreconditionDemo" /></p>

<h5 id="sec-failing-postconditions">13.7.1.1. Failing postconditions</h5>
<p>Lets look at an example of a failing postcondition.
<!-- %check-verify UserGuide.1.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">FailingPostcondition</span><span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">j</span> <span class="o">:=</span> <span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
    <span class="kr">return</span> <span class="n">j</span><span class="p">;</span>
  <span class="p">}</span><span class="c1">//^^^^^^^ a postcondition could not be proved on this return path</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>One first thing you can do is replace the statement <code class="language-dafny highlighter-rouge"><span class="kr">return</span> <span class="n">j</span><span class="p">;</span></code> by two statements <code class="language-dafny highlighter-rouge"><span class="n">i</span> <span class="o">:=</span> <span class="n">j</span><span class="p">;</span> <span class="kr">return</span><span class="p">;</span></code> to better understand what is wrong:
<!-- %check-verify UserGuide.2.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">FailingPostcondition</span><span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">j</span> <span class="o">:=</span> <span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">j</span><span class="p">;</span>
    <span class="kr">return</span><span class="p">;</span>
  <span class="p">}</span><span class="c1">//^^^^^^^ a postcondition could not be proved on this return path</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now, you can assert the postcondition just before the return:
<!-- %check-verify UserGuide.3.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">FailingPostcondition</span><span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">j</span> <span class="o">:=</span> <span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">j</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// could not prove this assertion</span>
    <span class="kr">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Thats it! Now the postcondition is not failing anymore, but the <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> contains the error!
you can now move to the next section to find out how to debug this <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code>.</p>

<h5 id="sec-failing-asserts">13.7.1.2. Failing asserts</h5>
<p>In the <a href="#sec-failing-postconditions">previous section</a>, we arrived at the point where we have a failing assertion:
<!-- %check-verify UserGuide.4.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">FailingPostcondition</span><span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">j</span> <span class="o">:=</span> <span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">j</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// could not prove this assertion</span>
    <span class="kr">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To debug why Dafny cannot prove this assert, we need to <em>move this assert up</em>, which is similar to <a href="https://en.wikipedia.org/wiki/Predicate_transformer_semantics#Weakest_preconditions"><em>computing the weakest precondition</em></a>.
For example, if we have <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:=</span> <span class="n">Y</span><span class="p">;</span> <span class="kr">assert</span> <span class="n">F</span><span class="p">;</span></code> and Dafny cannot prove <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">F</span><span class="p">;</span></code>, the weakest precondition for it to hold before <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:=</span> <span class="n">Y</span><span class="p">;</span></code> can be written as the assertion <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">F</span><span class="p">[</span><span class="n">x</span><span class="o">:=</span> <span class="n">Y</span><span class="p">];</span></code>, where we replace every occurrence of <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> in <code class="language-dafny highlighter-rouge"><span class="n">F</span></code> into <code class="language-dafny highlighter-rouge"><span class="n">Y</span></code>.
Lets do it in our example:
<!-- %check-verify UserGuide.5.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">FailingPostcondition</span><span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">j</span> <span class="o">:=</span> <span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// could not prove this assertion</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">j</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span>
    <span class="kr">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Yay! The assertion <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span></code> is not proven wrong, which means that if we manage to prove <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span></code>, it will work.
Now, this assert should hold only if we are in this branch, so to <em>move the assert up</em>, we need to guard it.
Just before the <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code>, we can add the weakest precondition <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">b</span> <span class="o">==&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span></code>:
<!-- %check-verify UserGuide.6.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">FailingPostcondition</span><span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span>
<span class="p">{</span>
  <span class="kr">var</span> <span class="n">j</span> <span class="o">:=</span> <span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">b</span>  <span class="o">==&gt;</span>  <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span>  <span class="c1">// could not prove this assertion</span>
  <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">j</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span>
    <span class="kr">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Again, now the error is only on the topmost assert, which means that we are making progress.
Now, either the error is obvious, or we can one more time replace <code class="language-dafny highlighter-rouge"><span class="n">j</span></code> by its value and create the assert <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">b</span> <span class="o">==&gt;</span> <span class="p">((</span><span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span></code>
<!-- %check-verify UserGuide.7.expect --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">FailingPostcondition</span><span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">ensures</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span>
<span class="p">{</span>
  <span class="kr">assert</span> <span class="n">b</span>  <span class="o">==&gt;</span>  <span class="mi">2</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// could not prove this assertion</span>
  <span class="kr">var</span> <span class="n">j</span> <span class="o">:=</span> <span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">assert</span> <span class="n">b</span>  <span class="o">==&gt;</span>  <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span>
  <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">j</span><span class="p">;</span>
    <span class="kr">assert</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span>
    <span class="kr">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>At this point, this is pure logic. We can simplify the assumption:
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">b</span> <span class="o">==&gt;</span>  <span class="mi">2</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">!</span><span class="n">b</span> <span class="o">||</span>  <span class="p">(</span><span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">!</span><span class="n">b</span> <span class="o">||</span>  <span class="p">(</span><span class="kr">if</span> <span class="o">!</span><span class="n">b</span> <span class="kr">then</span> <span class="kc">true</span> <span class="kr">else</span> <span class="kc">false</span><span class="p">)</span>
<span class="o">!</span><span class="n">b</span> <span class="o">||</span> <span class="o">!</span><span class="n">b</span><span class="p">;</span>
<span class="o">!</span><span class="n">b</span><span class="p">;</span>
</code></pre></div></div>
<p>Now we can understand what went wrong: When b is true, all of these formulas above are false, this is why the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> verifier was not able to prove them.
In the next section, we will explain how to move asserts up in certain useful patterns.</p>

<h5 id="sec-failing-asserts-special-cases">13.7.1.3. Failing asserts cases</h5>

<p>This list is not exhaustive but can definitely be useful to provide the next step to figure out why Dafny could not prove an assertion.</p>

<table>
  <thead>
    <tr>
      <th>Failing assert</th>
      <th>Suggested rewriting</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><br /><code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:=</span> <span class="n">Y</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">;</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">[</span><span class="n">x</span> <span class="o">:=</span> <span class="n">Y</span><span class="p">];</span></code><br /><code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:=</span> <span class="n">Y</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">;</span></code></td>
    </tr>
    <tr>
      <td><br /><code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="n">B</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">B</span> <span class="o">==&gt;</span> <span class="n">P</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="n">B</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code></td>
    </tr>
    <tr>
      <td><br /><code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="n">B</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span> <span class="kr">else</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="o">!</span><span class="n">B</span> <span class="o">==&gt;</span> <span class="n">P</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="n">B</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span> <span class="kr">else</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code></td>
    </tr>
    <tr>
      <td><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="n">X</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span> <span class="kr">else</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span><span class="p">;</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="n">X</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">A</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span> <span class="kr">else</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">A</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span><span class="p">;</span></code></td>
    </tr>
    <tr>
      <td><br /><br /><br /><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code></td>
      <td><a href="#sec-forall-statement"><code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">x</span></code></a><br /><code class="language-dafny highlighter-rouge">  <span class="kr">ensures</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">};</span></code><br /><code class="language-dafny highlighter-rouge"> <span class="kr">assert</span> <span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code></td>
    </tr>
    <tr>
      <td><br /><br /><br /><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code></td>
      <td><a href="#sec-forall-statement"><code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">x</span> <span class="o">|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></a><br /><code class="language-dafny highlighter-rouge">  <span class="kr">ensures</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">};</span></code><br /><code class="language-dafny highlighter-rouge"> <span class="kr">assert</span> <span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code></td>
    </tr>
    <tr>
      <td><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">exists</span> <span class="n">x</span> <span class="o">|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">::</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">exists</span> <span class="n">x</span> <span class="o">|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">::</span> <span class="n">Q'</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="n">x</span> <span class="o">:|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">Q'</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span> <span class="kr">else</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="kc">false</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code></td>
    </tr>
    <tr>
      <td><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">exists</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code><br /></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">x0</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">exists</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code><br />for a given expression <code class="language-dafny highlighter-rouge"><span class="n">x0</span></code>.</td>
    </tr>
    <tr>
      <td><br /><code class="language-dafny highlighter-rouge"><span class="kr">ensures</span> <span class="kr">exists</span> <span class="n">i</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code><br /></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">returns</span> <span class="p">(</span><span class="n">j</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">ensures</span> <span class="n">P</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="kr">ensures</span> <span class="kr">exists</span> <span class="n">i</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></code><br />in a lemma, so that the <code class="language-dafny highlighter-rouge"><span class="n">j</span></code> can be computed explicitly.</td>
    </tr>
    <tr>
      <td><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="n">callLemma</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">B</span> <span class="o">==</span> <span class="n">C</span><span class="p">;</span></code><br /></td>
      <td><a href="#sec-calc-statement"><code class="language-dafny highlighter-rouge"><span class="kr">calc</span> <span class="o">==</span> <span class="p">{</span></code></a><br /><code class="language-dafny highlighter-rouge">  <span class="n">A</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="n">B</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="p">{</span> <span class="n">callLemma</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="n">C</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">};</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">;</span></code><br />where the <a href="#sec-calc-statement"><code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code></a> statement can be used to make intermediate computation steps explicit. Works with <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&gt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&lt;=</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&gt;=</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">==&gt;</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">&lt;==</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">&lt;==&gt;</span></code> for example.</td>
    </tr>
    <tr>
      <td><br /><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span> <span class="o">==&gt;</span> <span class="n">B</span><span class="p">;</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">if</span> <span class="n">A</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">B</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">};</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span> <span class="o">==&gt;</span> <span class="n">B</span><span class="p">;</span></code></td>
    </tr>
    <tr>
      <td><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span><span class="p">;</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">B</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span><span class="p">;</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">ensures</span> <span class="n">P</span> <span class="o">==&gt;</span> <span class="n">Q</span></code> on a lemma<br /></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">requires</span> <span class="n">P</span> <span class="kr">ensures</span> <span class="n">Q</span></code> to avoid accidentally calling the lemma on inputs that do not satisfy <code class="language-dafny highlighter-rouge"><span class="n">P</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">i</span> <span class="o">=&gt;</span> <span class="n">P</span><span class="p">)</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">i</span> <span class="kr">requires</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">=&gt;</span> <span class="n">P</span><span class="p">);</span></code></td>
    </tr>
    <tr>
      <td><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">G</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">R</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">G</span><span class="p">(</span><span class="n">i0</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">R</span><span class="p">(</span><span class="n">i0</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">::</span> <span class="n">G</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">R</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code> with a guess of the <code class="language-dafny highlighter-rouge"><span class="n">i0</span></code> that makes the second assert to fail.</td>
    </tr>
    <tr>
      <td><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code><br /><br /></td>
    </tr>
    <tr>
      <td><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">m</span><span class="p">);</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">m</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kr">forall</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">);</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">j</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">requires</span> <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">ensures</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">method</span> <span class="n">n</span><span class="p">()</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><br /><br /><code class="language-dafny highlighter-rouge">  <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">m</span><span class="p">(</span><span class="n">a</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">method</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">j</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">requires</span> <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">ensures</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">method</span> <span class="n">n</span><span class="p">()</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">A</span><span class="p">(</span><span class="n">k</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="kr">forall</span> <span class="n">x</span> <span class="o">::</span> <span class="n">B</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">m</span><span class="p">(</span><span class="n">k</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code></td>
    </tr>
    <tr>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">method</span> <span class="n">m_mod</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">j</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">requires</span> <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">modifies</span> <span class="kr">this</span><span class="p">,</span> <span class="n">i</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">ensures</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">method</span> <span class="n">n_mod</span><span class="p">()</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><br /><br /><br /><br /><code class="language-dafny highlighter-rouge">  <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">m_mod</span><span class="p">(</span><span class="n">a</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">method</span> <span class="n">m_mod</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">j</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">requires</span> <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">modifies</span> <span class="kr">this</span><span class="p">,</span> <span class="n">i</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">ensures</span> <span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge"><span class="p">}</span></code><br /><br /><code class="language-dafny highlighter-rouge"><span class="kr">method</span> <span class="n">n_mod</span><span class="p">()</span> <span class="p">{</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="o">...</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">A</span><span class="p">(</span><span class="n">k</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">modify</span> <span class="kr">this</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// Temporarily</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="n">T</span><span class="p">;</span>     <span class="c1">// Temporarily</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assume</span> <span class="n">B</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span></code><br /><code class="language-dafny highlighter-rouge"><span class="c1">//  var x := m_mod(k);</span></code><br /><code class="language-dafny highlighter-rouge">  <span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span></code></td>
    </tr>
    <tr>
      <td><br /><code class="language-dafny highlighter-rouge"><span class="kr">modify</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span></code></td>
      <td><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">z</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">z</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">modify</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span></code><br /><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span></code></td>
    </tr>
  </tbody>
</table>

<h5 id="sec-counterexamples">13.7.1.4. Counterexamples</h5>

<p>When verification fails, we can rerun Dafny with <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">extract</span><span class="o">-</span><span class="n">counterexample</span></code> flag to get a counterexample that can potentially explain the proof failure.
Note that Danfy cannot guarantee that the counterexample it reports provably violates the assertion it was generated for (see <sup id="fnref:smt-encoding" role="doc-noteref"><a href="#fn:smt-encoding" class="footnote" rel="footnote">17</a></sup>)
The counterexample takes the form of assumptions that can be inserted into the code to describe the potential conditions under which the given assertion is violated. 
This output should be inspected manually and treated as a hint.</p>

<h4 id="sec-verification-debugging-slow">13.7.2. Verification debugging when verification is slow</h4>

<p>In this section, we describe techniques to apply in the case when verification is slower than expected, does not terminate, or times out.</p>

<p>Additional detail is available in the <a href="../VerificationOptimization/VerificationOptimization">verification optimization guide</a>.</p>

<h5 id="sec-assume-false">13.7.2.1. <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span></code></h5>

<p>Assuming <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> is an empirical way to short-circuit the verifier and usually stop verification at a given point,<sup id="fnref:explainer-assume-false" role="doc-noteref"><a href="#fn:explainer-assume-false" class="footnote" rel="footnote">18</a></sup> and since the final compilation steps do not accept this command, it is safe to use it during development.
Another similar command, <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="kc">false</span><span class="p">;</span></code>, would also short-circuit the verifier, but it would still make the verifier try to prove <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code>, which can also lead to timeouts.</p>

<p>Thus, let us say a program of this shape takes forever to verify.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">NotTerminating</span><span class="p">(</span><span class="n">b</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
   <span class="kr">assert</span> <span class="n">X</span><span class="p">;</span>
   <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Y</span><span class="p">;</span>
   <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Z</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>What we can first do is add an <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span></code> at the beginning of the method:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">NotTerminating</span><span class="p">()</span> <span class="p">{</span>
   <span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// Will never compile, but everything verifies instantly</span>
   <span class="kr">assert</span> <span class="n">X</span><span class="p">;</span>
   <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Y</span><span class="p">;</span>
   <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Z</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kr">assert</span> <span class="n">W</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This verifies instantly. This gives us a strategy to bisect, or do binary search to find the assertion that slows everything down.
Now, we move the <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span></code> below the next assertion:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">NotTerminating</span><span class="p">()</span> <span class="p">{</span>
   <span class="kr">assert</span> <span class="n">X</span><span class="p">;</span>
   <span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span>
   <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Y</span><span class="p">;</span>
   <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Z</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kr">assert</span> <span class="n">W</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If verification is slow again, we can use <a href="#sec-verification-debugging">techniques seen before</a> to decompose the assertion and find which component is slow to prove.</p>

<p>If verification is fast, thats the sign that <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> is probably not the problem,. We now move the <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span></code> after the if/then block:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">NotTerminating</span><span class="p">()</span> <span class="p">{</span>
   <span class="kr">assert</span> <span class="n">X</span><span class="p">;</span>
   <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Y</span><span class="p">;</span>
   <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Z</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span>
   <span class="kr">assert</span> <span class="n">W</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, if verification is fast, we know that <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">W</span><span class="p">;</span></code> is the problem. If it is slow, we know that one of the two branches of the <code class="language-dafny highlighter-rouge"><span class="kr">if</span></code> is the problem.
The next step is to put an <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span></code> at the end of the <code class="language-dafny highlighter-rouge"><span class="kr">then</span></code> branch, and an <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span></code> at the beginning of the else branch:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">NotTerminating</span><span class="p">()</span> <span class="p">{</span>
   <span class="kr">assert</span> <span class="n">X</span><span class="p">;</span>
   <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Y</span><span class="p">;</span>
     <span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span>
   <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
     <span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="n">Z</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kr">assert</span> <span class="n">W</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, if verification is slow, it means that <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">Y</span><span class="p">;</span></code> is the problem.
If verification is fast, it means that the problem lies in the <code class="language-dafny highlighter-rouge"><span class="kr">else</span></code> branch.
One trick to ensure we measure the verification time of the <code class="language-dafny highlighter-rouge"><span class="kr">else</span></code> branch and not the then branch is to move the first <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span></code> to the top of the then branch, along with a comment indicating that we are short-circuiting it for now.
Then, we can move the second <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span></code> down and identify which of the two assertions makes the verifier slow.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">NotTerminating</span><span class="p">()</span> <span class="p">{</span>
   <span class="kr">assert</span> <span class="n">X</span><span class="p">;</span>
   <span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
     <span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// Short-circuit because this branch is verified anyway</span>
     <span class="kr">assert</span> <span class="n">Y</span><span class="p">;</span>
   <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
     <span class="kr">assert</span> <span class="n">Z</span><span class="p">;</span>
     <span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span>
     <span class="kr">assert</span> <span class="n">P</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kr">assert</span> <span class="n">W</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If verification is fast, which of the two assertions <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">Z</span><span class="p">;</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">;</span></code> causes the slowdown?<sup id="fnref:answer-slowdown" role="doc-noteref"><a href="#fn:answer-slowdown" class="footnote" rel="footnote">19</a></sup></p>

<p>We now hope you know enough of <code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span><span class="p">;</span></code> to locate assertions that make verification slow.
Next, we will describe some other strategies at the assertion level to figure out what happens and perhaps fix it.</p>

<h5 id="sec-verification-debugging-assert-by">13.7.2.2. <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="o">...</span> <span class="kr">by</span> <span class="p">{}</span></code></h5>

<p>If an assertion <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">X</span><span class="p">;</span></code> is slow, it is possible that calling a lemma or invoking other assertions can help to prove it: The postcondition of this lemma, or the added assertions, could help the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> verifier figure out faster how to prove the result.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="kr">assert</span> <span class="n">SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION</span><span class="p">;</span>
  <span class="n">LEMMA</span><span class="p">();</span>
  <span class="kr">assert</span> <span class="n">X</span><span class="p">;</span>
<span class="o">...</span>
<span class="kr">lemma</span> <span class="p">()</span> 
  <span class="kr">requires</span> <span class="n">LEMMA_PRECONDITION</span>
  <span class="kr">ensures</span> <span class="n">X</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>However, this approach has the problem that it exposes the asserted expressions and lemma postconditions not only for the assertion we want to prove faster,
but also for every assertion that appears afterwards. This can result in slowdowns<sup id="fnref:verifier-lost" role="doc-noteref"><a href="#fn:verifier-lost" class="footnote" rel="footnote">20</a></sup>.
A good practice consists of wrapping the intermediate verification steps in an <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="o">...</span> <span class="kr">by</span> <span class="p">{}</span></code>, like this:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="kr">assert</span> <span class="n">X</span> <span class="kr">by</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION</span><span class="p">;</span>
    <span class="n">LEMMA</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Now, only <code class="language-dafny highlighter-rouge"><span class="n">X</span></code> is available for the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> verifier to prove the rest of the method.</p>

<h5 id="sec-labeling-revealing-assertions">13.7.2.3. Labeling and revealing assertions</h5>

<p>Another way to prevent assertions or preconditions from cluttering the verifier<sup id="fnref:verifier-lost:1" role="doc-noteref"><a href="#fn:verifier-lost" class="footnote" rel="footnote">20</a></sup> is to label and reveal them.
Labeling an assertion has the effect of hiding its result, until there is a reveal calling that label.</p>

<p>The example of the <a href="#sec-verification-debugging-assert-by">previous section</a> could be written like this.</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="kr">assert</span> <span class="n">p</span><span class="o">:</span> <span class="n">SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION</span><span class="p">;</span>
  <span class="c1">// p is not available here.</span>
  <span class="kr">assert</span> <span class="n">X</span> <span class="kr">by</span> <span class="p">{</span>
    <span class="kr">reveal</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">LEMMA</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Similarly, if a precondition is only needed to prove a specific result in a method, one can label and reveal the precondition, like this:</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">method</span> <span class="n">Slow</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">greater</span><span class="o">:</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span> <span class="p">{</span>
  
  <span class="kr">assert</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span> <span class="kr">by</span> <span class="p">{</span>
    <span class="kr">reveal</span> <span class="n">greater</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Labelled assert statements are available both in expressions and statements.
Assertion labels are not accessible outside of the block which the assert statement is in.
If you need to access an assertion label outside of the enclosing expression or statement,
you need to lift the labelled statement at the right place manually, e.g. rewrite</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ghost</span> <span class="kr">predicate</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>

<span class="kr">method</span> <span class="n">TestMethod</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">r</span><span class="o">:</span> <span class="n">x</span> <span class="o">&lt;==&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">if</span> <span class="n">x</span> <span class="p">{</span>
    <span class="kr">assert</span> <span class="n">a</span><span class="o">:</span> <span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="kr">by</span> <span class="p">{</span> <span class="kr">reveal</span> <span class="n">r</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="n">x</span> <span class="o">==&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="kr">by</span> <span class="p">{</span> <span class="kr">reveal</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Error, a is not accessible</span>
<span class="p">}</span>
</code></pre></div></div>
<p>to</p>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">ghost</span> <span class="kr">predicate</span> <span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>

<span class="kr">method</span> <span class="n">TestMethod</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">bool</span><span class="p">)</span>
  <span class="kr">requires</span> <span class="n">r</span><span class="o">:</span> <span class="n">x</span> <span class="o">&lt;==&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kr">assert</span> <span class="n">a</span><span class="o">:</span> <span class="n">x</span> <span class="o">==&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="kr">by</span> <span class="p">{</span>
    <span class="kr">if</span> <span class="n">x</span> <span class="p">{</span>
      <span class="kr">assert</span> <span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="kr">by</span> <span class="p">{</span> <span class="kr">reveal</span> <span class="n">r</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Proved without revealing the precondition</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kr">assert</span> <span class="n">x</span> <span class="o">==&gt;</span> <span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="kr">by</span> <span class="p">{</span> <span class="kr">reveal</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Now a is accessible</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To lift assertions, please refer to the techniques described in <a href="#sec-verification-debugging">Verification Debugging</a>.</p>

<h5 id="sec-non-opaque-function-method">13.7.2.4. Non-opaque <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">method</span></code></h5>

<p>Functions are normally used for specifications, but their functional syntax is sometimes also desirable to write application code.
However, doing so naively results in the body of a <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">method</span> <span class="n">Fun</span><span class="p">()</span></code> be available for every caller, which can cause the verifier to time out or get extremely slow<sup id="fnref:verifier-lost:2" role="doc-noteref"><a href="#fn:verifier-lost" class="footnote" rel="footnote">20</a></sup>.
A solution for that is to add the attribute <a href="#sec-opaque"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">opaque</span><span class="p">}</span></code></a> right between <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">method</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Fun</span><span class="p">()</span></code>, and use <a href="#sec-reveal-statement"><code class="language-dafny highlighter-rouge"><span class="kr">reveal</span> <span class="n">Fun</span><span class="p">();</span></code></a> in the calling functions or methods when needed.</p>

<h5 id="sec-conversion-to-and-from-bitvectors">13.7.2.5. Conversion to and from bitvectors</h5>

<p>Bitvectors and natural integers are very similar, but they are not treated the same by the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> verifier. As such, conversion from <code class="language-dafny highlighter-rouge"><span class="kt">bv8</span></code> to an <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code> and vice-versa is not straightforward, and can result in slowdowns.</p>

<p>There are two solutions to this for now. First, one can define a <a href="#sec-subset-types">subset type</a> instead of using the built-in type <code class="language-dafny highlighter-rouge"><span class="kt">bv8</span></code>:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">byte</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">256</span>
</code></pre></div></div>

<p>One of the problems of this approach is that additions, subtractions and multiplications do not enforce the result to be in the same bounds, so it would have to be checked, and possibly truncated with modulos. For example:</p>

<!-- %check-resolve -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">type</span> <span class="n">byte</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">256</span>
<span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">a</span><span class="o">:</span> <span class="n">byte</span> <span class="o">:=</span> <span class="mi">250</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">b</span><span class="o">:</span> <span class="n">byte</span> <span class="o">:=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>               <span class="c1">// inferred to be an 'int', its value will be 50.</span>
  <span class="kr">var</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>               <span class="c1">// inferred to be an 'int', its value will be 450.</span>
  <span class="kr">var</span> <span class="n">e</span> <span class="o">:=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>       <span class="c1">// still inferred to be an 'int'...</span>
  <span class="kr">var</span> <span class="n">f</span><span class="o">:</span> <span class="n">byte</span> <span class="o">:=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A better solution consists of creating a <a href="#sec-newtypes">newtype</a> that will have the ability to check bounds of arithmetic expressions, and can actually be compiled to bitvectors as well.</p>

<!-- %check-verify UserGuide.8.expect -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">newtype</span> <span class="p">{</span><span class="o">:</span><span class="n">nativeType</span> <span class="s2">"short"</span><span class="p">}</span> <span class="n">byte</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">256</span>
<span class="kr">method</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">a</span><span class="o">:</span> <span class="n">byte</span> <span class="o">:=</span> <span class="mi">250</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">b</span><span class="o">:</span> <span class="n">byte</span> <span class="o">:=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="kr">var</span> <span class="n">c</span> <span class="o">:=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// OK, inferred to be a byte</span>
  <span class="kr">var</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// Error: cannot prove that the result of a + b is of type `byte`.</span>
  <span class="kr">var</span> <span class="n">f</span> <span class="o">:=</span> <span class="p">((</span><span class="n">a</span> <span class="ow">as</span> <span class="kt">int</span> <span class="o">+</span> <span class="n">b</span> <span class="ow">as</span> <span class="kt">int</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">)</span> <span class="ow">as</span> <span class="n">byte</span><span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</code></pre></div></div>

<p>One might consider refactoring this code into separate functions if used over and over.</p>

<h5 id="sec-nested-loops">13.7.2.6. Nested loops</h5>

<p>In the case of nested loops, the verifier might timeout sometimes because of inadequate or too much available information<sup id="fnref:verifier-lost:3" role="doc-noteref"><a href="#fn:verifier-lost" class="footnote" rel="footnote">20</a></sup>.
One way to mitigate this problem, when it happens, is to isolate the inner loop by refactoring it into a separate method, with suitable pre and postconditions that will usually assume and prove the invariant again.
For example,</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">while</span> <span class="n">X</span>
   <span class="kr">invariant</span> <span class="n">Y</span>
 <span class="p">{</span>
   <span class="kr">while</span> <span class="n">X'</span>
     <span class="kr">invariant</span> <span class="n">Y'</span>
   <span class="p">{</span>
 
   <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>could be refactored as this:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">`</span><span class="kr">while</span> <span class="n">X</span>
   <span class="kr">invariant</span> <span class="n">Y</span>
 <span class="p">{</span>
   <span class="n">innerLoop</span><span class="p">();</span>
 <span class="p">}</span>
<span class="o">...</span>
<span class="kr">method</span> <span class="n">innerLoop</span><span class="p">()</span>
  <span class="n">require</span> <span class="n">Y'</span>
  <span class="kr">ensures</span> <span class="n">Y'</span>
</code></pre></div></div>

<p>In the next section, when everything can be proven in a timely manner, we explain another strategy to decrease proof time by parallelizing it if needed, and making the verifier focus on certain parts.</p>

<h4 id="sec-assertion-batches">13.7.3. Assertion batches, well-formedness, correctness</h4>

<p>To understand how to control verification,
it is first useful to understand how <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> verifies functions and methods.</p>

<p>For every method (or function, constructor, etc.), <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> extracts <em>assertions</em>.
Assertions can roughly be sorted into two kinds: Well-formedness and correctness.</p>

<ul>
  <li>
    <p><em>Well-formedness</em> assertions: All the implicit requirements
of native operation calls (such as indexing and asserting that divisiors are nonzero),
<a href="#sec-requires-clause"><code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses</a> of function calls, explicit
<a href="#sec-statement-in-an-expression">assertion expressions</a> and
<a href="#sec-decreases-clause"><code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> clauses</a> at function call sites
generate well-formedness assertions.<br />
An expression is said to be <em>well-formed</em> in a context if
all well-formedness assertions can be proven in that context.</p>
  </li>
  <li>
    <p><em>Correctness</em> assertions: All remaining assertions and clauses</p>
  </li>
</ul>

<p>For example, given the following statements:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">c</span> <span class="o">:=</span> <span class="p">(</span><span class="kr">assert</span> <span class="n">b</span> <span class="o">==&gt;</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span><span class="o">/</span><span class="n">a</span> <span class="kr">else</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
<span class="kr">assert</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">/</span><span class="n">a</span><span class="p">;</span>
</code></pre></div></div>

<p>Dafny performs the following checks:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="kr">var</span> <span class="n">c</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// Correctness</span>
<span class="p">}</span>
<span class="kr">assert</span> <span class="n">b</span> <span class="o">==&gt;</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Well-formedness</span>
<span class="kr">if</span> <span class="n">b</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// Well-formedness</span>
<span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
  <span class="kr">assert</span> <span class="n">f</span><span class="o">.</span><span class="kr">requires</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// Well-formedness</span>
<span class="p">}</span>
<span class="n">c</span> <span class="o">:=</span> <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span><span class="o">/</span><span class="n">a</span> <span class="kr">else</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="kr">assert</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">// Well-formedness</span>
<span class="kr">assert</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">/</span><span class="n">a</span><span class="p">;</span>     <span class="c1">// Correctness</span>
</code></pre></div></div>

<p>Well-formedness is proved at the same time as correctness, except for
<a href="#sec-well-formedness-specifications">well-formedness of requires and ensures clauses</a>
which is proved separately from the well-formedness and correctness of the rest of the method/function.
For the rest of this section, we dont differentiate between well-formedness assertions and correctness assertions.</p>

<p>We can also classify the assertions extracted by Dafny in a few categories:</p>

<p><strong>Integer assertions:</strong></p>

<ul>
  <li>Every <a href="#sec-numeric-types">division</a> yields an <em>assertion</em> that the divisor is never zero.</li>
  <li>Every <a href="#sec-numeric-types">bounded number operation</a> yields an <em>assertion</em> that the result will be within the same bounds (no overflow, no underflows).</li>
  <li>Every <a href="#sec-as-is-expression">conversion</a> yields an <em>assertion</em> that conversion is compatible.</li>
  <li>Every <a href="#sec-bit-vector-types">bitvector shift</a> yields an <em>assertion</em> that the shift amount is never negative, and that the shift amount is within the width of the value.</li>
</ul>

<p><strong>Object assertions:</strong></p>

<ul>
  <li>Every <a href="#sec-class-types">object property access</a> yields an <em>assertion</em> that the object is not null.</li>
  <li>Every assignment <code class="language-dafny highlighter-rouge"><span class="n">o</span><span class="o">.</span><span class="n">f</span> <span class="o">:=</span> <span class="n">E</span><span class="p">;</span></code> yields an <em>assertion</em> that <code class="language-dafny highlighter-rouge"><span class="n">o</span></code> is among the set of objects of the <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code> clause of the enclosing <a href="#sec-loop-framing">loop</a> or <a href="#sec-modifies-clause">method</a>.</li>
  <li>Every read <code class="language-dafny highlighter-rouge"><span class="n">o</span><span class="o">.</span><span class="n">f</span></code> yields an <em>assertion</em> that <code class="language-dafny highlighter-rouge"><span class="n">o</span></code> is among the set of objects of the <a href="#sec-reads-clause"><code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code></a> clause of the enclosing function or predicate.</li>
  <li>Every <a href="#sec-array-type">array access</a> <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">]</span></code> yields the assertion that <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">Length</span></code>.</li>
  <li>Every <a href="#sec-sequences">sequence access</a> <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="p">[</span><span class="n">x</span><span class="p">]</span></code> yields an <em>assertion</em>, that <code class="language-dafny highlighter-rouge"><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span></code>, because sequences are never null.</li>
  <li>Every <a href="#sec-datatype-update-suffix">datatype update expression</a> and <a href="#sec-algebraic-datatype">datatype destruction</a> yields an <em>assertion</em> that the object has the given property.</li>
  <li>Every method overriding a <a href="#sec-trait-types"><code class="language-dafny highlighter-rouge"><span class="kr">trait</span></code></a> yields an <em>assertion</em> that any postcondition it provides implies the postcondition of its parent trait, and an <em>assertion</em> that any precondition it provides is implied by the precondition of its parent trait.</li>
</ul>

<p><strong>Other assertions:</strong></p>

<ul>
  <li>Every value whose type is assigned to a <a href="#sec-subset-types">subset type</a> yields an <em>assertion</em> that it satisfies the subset type constraint.</li>
  <li>Every non-empty <a href="#sec-subset-types">subset type</a> yields an <em>assertion</em> that its witness satisfies the constraint.</li>
  <li>Every <a href="#sec-update-and-call-statement">Assign-such-that operator</a> <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> yields an <em>assertion</em> that <code class="language-dafny highlighter-rouge"><span class="kr">exists</span> <span class="n">x</span> <span class="o">::</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>. In case <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">:|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">Body</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> appears in an expression and <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> is non-ghost, it also yields <code class="language-dafny highlighter-rouge"><span class="kr">forall</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">|</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">P</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">::</span> <span class="n">Body</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">Body</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></code>.</li>
  <li>Every recursive function yields an <em>assertion</em> that <a href="#sec-loop-termination">it terminates</a>.</li>
  <li>Every <a href="#sec-match-expression">match expression</a> or <a href="#sec-if-statement">alternative if statement</a> yields an <em>assertion</em> that all cases are covered.</li>
  <li>Every call to a function or method with a <a href="#sec-requires-clause"><code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code></a> clause yields <em>one assertion per requires clause</em><sup id="fnref:precision-requires-clause" role="doc-noteref"><a href="#fn:precision-requires-clause" class="footnote" rel="footnote">21</a></sup>
(special cases such as sequence indexing come with a special <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clause that the index is within bounds).</li>
</ul>

<p><strong>Specification assertions:</strong></p>

<ul>
  <li>Any explicit <a href="#sec-assert-statement"><code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code></a> statement is <em>an assertion</em><sup id="fnref:precision-requires-clause:1" role="doc-noteref"><a href="#fn:precision-requires-clause" class="footnote" rel="footnote">21</a></sup>.</li>
  <li>A consecutive pair of lines in a <a href="#sec-calc-statement"><code class="language-dafny highlighter-rouge"><span class="kr">calc</span></code></a> statement forms <em>an assertion</em> that the expressions are related according to the common operator.</li>
  <li>Every <a href="#sec-ensures-clause"><code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code></a> clause yields an <em>assertion</em> at the end of the method and on every return, and on <a href="#sec-forall-statement"><code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code></a> statements.</li>
  <li>Every <a href="#sec-invariant-clause"><code class="language-dafny highlighter-rouge"><span class="kr">invariant</span></code></a> clause yields an <em>assertion</em> that it holds before the loop and an <em>assertion</em> that it holds at the end of the loop.</li>
  <li>Every <a href="#sec-decreases-clause"><code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code></a> clause yields an <em>assertion</em> at either a call site or at the end of a while loop.</li>
  <li>Every <a href="#sec-iterator-specification"><code class="language-dafny highlighter-rouge"><span class="kr">yield</span> <span class="kr">ensures</span></code></a> clause on an <a href="#sec-iterator-types">iterator</a> yields <em>assertions</em> that the clause holds at every yielding point.</li>
  <li>Every <a href="#sec-iterator-specification"><code class="language-dafny highlighter-rouge"><span class="kr">yield</span> <span class="kr">requires</span></code></a> clause on an <a href="#sec-iterator-types">iterator</a> yields <em>assertions</em> that the clause holds at every point when the iterator is called.</li>
</ul>

<p>It is useful to mentally visualize all these assertions as a list that roughly follows the order in the code,
except for <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> or <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> that generate assertions that seem earlier in the code but, for verification purposes, would be placed later.
In this list, each assertion depends on other assertions, statements and expressions that appear earlier in the control flow<sup id="fnref:complexity-path-encoding" role="doc-noteref"><a href="#fn:complexity-path-encoding" class="footnote" rel="footnote">22</a></sup>.</p>

<p>The fundamental unit of verification in <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> is an <em>assertion batch</em>, which consists of one or more assertions from this list, along with all the remaining assertions turned into assumptions. To reduce overhead, by default <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> collects all the assertions in the body of a given method into a single assertion batch that it sends to the verifier, which tries to prove it correct.</p>

<ul>
  <li>If the verifier says it is correct,<sup id="fnref:smt-encoding:1" role="doc-noteref"><a href="#fn:smt-encoding" class="footnote" rel="footnote">17</a></sup> it means that all the assertions hold.</li>
  <li>If the verifier returns a counterexample, this counterexample is used to determine both the failing assertion and the failing path.
In order to retrieve additional failing assertions, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> will again query the verifier after turning previously failed assertions into assumptions.<sup id="fnref:example-assertion-turned-into-assumption" role="doc-noteref"><a href="#fn:example-assertion-turned-into-assumption" class="footnote" rel="footnote">23</a></sup> <sup id="fnref:caveat-about-assertion-and-assumption" role="doc-noteref"><a href="#fn:caveat-about-assertion-and-assumption" class="footnote" rel="footnote">24</a></sup></li>
  <li>If the verifier returns <code class="language-dafny highlighter-rouge"><span class="n">unknown</span></code> or times out, or even preemptively for difficult assertions or to reduce the chance that the verifier will be confused by the many assertions in a large batch, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> may partition the assertions into smaller batches<sup id="fnref:smaller-batches" role="doc-noteref"><a href="#fn:smaller-batches" class="footnote" rel="footnote">25</a></sup>. An extreme case is the use of the <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">vcsSplitOnEveryAssert</span></code> command-line option or the <a href="#sec-isolate_assertions"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code> attribute</a>, which causes <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> to make one batch for each assertion.</li>
</ul>

<h5 id="sec-assertion-batches-control">13.7.3.1. Controlling assertion batches</h5>

<p>When Dafny verifies a symbol, such as a method, a function or a constant with a subset type, that verification may contain multiple assertions. A symbol is generally verified the fastest when all assertions it in are verified together, in what we call a single assertion batch. However, is it possible to split verification of a symbol into multiple batches, and doing so makes the individual batches simpler, which can lead to less brittle verification behavior. Dafny contains several attributes that allow you to customize how verification is split into batches.</p>

<p>Firstly, you can instruct Dafny to verify individual assertions in separate batches. You can place the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate</span><span class="p">}</span></code> attribute on a single assertion to place it in a separate batch, or you can place <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code> on a symbol, such as a function or method declaration, to place all assertions in it into separate batches. The CLI option <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">isolate</span><span class="o">-</span><span class="n">assertions</span></code> will place all assertions into separate batches for all symbols. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate</span><span class="p">}</span></code> can be used on <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">return</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> statements. When placed on a <code class="language-dafny highlighter-rouge"><span class="kr">return</span></code> statement, it will verify the postconditions for all paths leading to that <code class="language-dafny highlighter-rouge"><span class="kr">return</span></code> in a separate batch. When placed on a <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code>, it will verify the loop invariants for all paths leading to that <code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> in a separate batch.</p>

<p>Given an assertion that is placed into a separate batch, you can then further simplify the verification of this assertion by placing each control flow path that leads to this assertion into a separate batch. You can do this using the attribute <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate</span> <span class="s2">"paths"</span><span class="p">}</span></code>.</p>

<h4 id="sec-command-line-options-and-attributes-for-verification">13.7.4. Command-line options and other attributes to control verification</h4>

<p>There are many great options that control various aspects of verifying dafny programs. Here we mention only a few:</p>

<ul>
  <li>Control of output: <a href="#sec-controlling-output"><code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">dprint</span></code></a>, <a href="#sec-controlling-output"><code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">rprint</span></code></a>, <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">stats</span></code>, <a href="#sec-controlling-compilation"><code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">compileVerbose</span></code></a></li>
  <li>Whether to print warnings: <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">proverWarnings</span></code></li>
  <li>Control of time: <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">timeLimit</span></code></li>
  <li>Control of resources: <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">rLimit</span></code> and <a href="#sec-rlimit"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">rlimit</span><span class="p">}</span></code></a></li>
  <li>Control of the prover used: <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">prover</span></code></li>
  <li>Control of how many times to <em>unroll</em> functions: <a href="#sec-fuel"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">fuel</span><span class="p">}</span></code></a></li>
</ul>

<p>You can search for them in <a href="https://dafny-lang.github.io/dafny/DafnyRef/DafnyRef">this file</a> as some of them are still documented in raw text format.</p>

<h4 id="sec-proof-dependencies">13.7.5. Analyzing proof dependencies</h4>

<p>When Dafny successfully verifies a particular definition, it can ask the
solver for information about what parts of the program were actually
used in completing the proof. The program components that can
potentially form part of  a proof include:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statements (and the implicit assumption that they hold in subsequent code),</li>
  <li>implicit assertions (such as array or sequence bounds checks),</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> statements,</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clauses,</li>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses,</li>
  <li>function definitions,</li>
  <li>method calls, and</li>
  <li>assignment statements.</li>
</ul>

<p>Understanding what portions of the program the proof depended on can
help identify mistakes, and to better understand the structure of your
proof (which can help when optimizing it, among other things). In
particular, there are two key dependency structures that tend to
indicate mistakes, both focused on what parts of the program were <em>not</em>
included in the proof.</p>

<ul>
  <li>
    <p>Redundant assumptions. In some cases, a proof can be completed without
the need of certain <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> statements or <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses. This
situation might represent a mistake, and when the mistake is corrected
those program elements may become required. However, they may also
simply be redundant, and the program will become simpler if theyre
removed. Dafny will report assumptions of this form when verifying
with the flag <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">warn</span><span class="o">-</span><span class="n">redundant</span><span class="o">-</span><span class="n">assumptions</span></code>. Note that <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code>
statements may be warned about, as well, indicating that the fact
proved by the assertion wasnt needed to prove anything else in the
program.</p>
  </li>
  <li>
    <p>Contradictory assumptions. If the combination of all assumptions in
scope at a particular program point is contradictory, anything can be
proved at that point. This indicates the serious situation that,
unless done on purpose in a proof by contradiction, your proof may be
entirely vacuous. It therefore may not say what you intended, giving
you a false sense of confidence. The
<code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">warn</span><span class="o">-</span><span class="n">contradictory</span><span class="o">-</span><span class="n">assumptions</span></code> flag instructs Dafny to warn about
any assertion that was proved through the use of contradictions
between assumptions. If a particular <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statement is part of an
intentional proof by contradiction, annotating it with the
<code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">contradiction</span><span class="p">}</span></code> attribute will silence this warning.</p>
  </li>
</ul>

<p>These options can be specified in <code class="language-dafny highlighter-rouge"><span class="n">dfyconfig</span><span class="o">.</span><span class="n">toml</span></code>, and this is typically the most convenient way to use them with the IDE.</p>

<p>More detailed information is available using either the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">log</span><span class="o">-</span><span class="n">format</span>
<span class="n">text</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verification</span><span class="o">-</span><span class="n">coverage</span><span class="o">-</span><span class="n">report</span></code> option to <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">verify</span></code>. The former will
include a list of proof dependencies (including source location and
description) alongside every assertion batch in the generated log
whenever one of the two warning options above is also included. The
latter will produce a highlighted HTML version of your source code, in
the same format used by <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">test</span> <span class="o">--</span><span class="n">coverage</span><span class="o">-</span><span class="n">report</span></code>
and <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">generate</span><span class="o">-</span><span class="n">tests</span> <span class="o">--</span><span class="n">verification</span><span class="o">-</span><span class="n">coverage</span><span class="o">-</span><span class="n">report</span></code>,
indicating which parts of the program were used, not used, or partly
used in the verification of the entire program.</p>

<h4 id="sec-brittle-verification">13.7.6. Debugging brittle verification</h4>

<p>When evolving a Dafny codebase, it can sometimes occur that a proof
obligation succeeds at first only for the prover to time out or report a
potential error after minor, valid changes. We refer to such a proof
obligation as <em>brittle</em>. This is ultimately due to decidability
limitations in the form of automated reasoning that Dafny uses. The Z3
SMT solver that Dafny depends on attempts to efficiently search for
proofs, but does so using both incomplete heuristics and a degree of
randomness, with the result that it can sometimes fail to find a proof
even when one exists (or continue searching forever).</p>

<p>Dafny provides some features to mitigate this issue, primarily focused
on early detection. The philosophy is that, if Dafny programmers are
alerted to proofs that show early signs of brittleness, before they are
obviously so, they can refactor the proofs to make them less brittle
before further development becomes difficult.</p>

<p>The mechanism for early detection focuses on measuring the resources
used to discharge a proof obligation (either using duration or a more
deterministic resource count metric available from Z3). Dafny can
re-run a given proof attempt multiple times after automatically making
minor changes to the structure of the input or to the random choices
made by the solver.  If the resources used during these attempts (or the
ability to find a proof at all) vary widely, we use this as a proxy
metric indicating that the proof may be brittle.</p>

<h5 id="13761-measuring-proof-brittleness">13.7.6.1. Measuring proof brittleness</h5>

<p>To measure the brittleness of your proofs, start by using the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span>
<span class="n">measure</span><span class="o">-</span><span class="n">complexity</span></code> command with the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">iterations</span> <span class="n">N</span></code> flag to instruct
Dafny to attempt each proof goal <code class="language-dafny highlighter-rouge"><span class="n">N</span></code> times, using a different random
seed each time. The random seed used for each attempt is derived from
the global random seed <code class="language-dafny highlighter-rouge"><span class="n">S</span></code> specified with <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">randomSeed</span><span class="o">:</span><span class="n">S</span></code>, which
defaults to <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code>. The random seed affects the structure of the SMT
queries sent to the solver, changing the ordering of SMT commands, the
variable names used, and the random seed the solver itself uses when
making decisions that can be arbitrary.</p>

<p>For most use cases, it also makes sense to specify the
<code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">log</span><span class="o">-</span><span class="n">format</span> <span class="n">csv</span></code> flag, to log verification cost statistics to a
CSV file. By default, the resulting CSV files will be created in the
<code class="language-dafny highlighter-rouge"><span class="n">TestResults</span></code> folder of the current directory.</p>

<p>Once Dafny has completed, the
<a href="https://github.com/dafny-lang/dafny-reportgenerator/"><code class="language-dafny highlighter-rouge"><span class="n">dafny</span><span class="o">-</span><span class="n">reportgenerator</span></code></a>
tool is a convenient way to process the output. It allows you to specify
several limits on statistics computed from the elapsed time or solver
resource use of each proof goal, returning an error code when it detects
violations of these limits. You can find documentation on the full set
of options for <code class="language-dafny highlighter-rouge"><span class="n">dafny</span><span class="o">-</span><span class="n">reportgenerator</span></code> in its
<a href="https://github.com/dafny-lang/dafny-reportgenerator/blob/main/README.md"><code class="language-dafny highlighter-rouge"><span class="n">README</span><span class="o">.</span><span class="n">md</span></code></a>
file.</p>

<p>In general, we recommend something like the following:</p>

<!-- %no-check -->
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>dafny-reportgenerator <span class="nt">--max-resource-cv-pct</span> 10 TestResults/<span class="k">*</span>.csv
</code></pre></div></div>

<p>This bounds the <a href="https://en.wikipedia.org/wiki/Coefficient_of_variation">coefficient of
variation</a> of
the solver resource count at 10% (0.10). We recommend a limit of less
than 20%, perhaps even as low as 5%. However, when beginning to analyze
a new project, it may be necessary to set limits as high as a few
hundred percent and incrementally ratchet down the limit over time.</p>

<p>When first analyzing proof brittleness, you may also find that certain proof
goals succeed on some iterations and fail on others. If your aim is
first to ensure that brittleness doesnt worsen and then to start
reducing it, integrating <code class="language-dafny highlighter-rouge"><span class="n">dafny</span><span class="o">-</span><span class="n">reportgenerator</span></code> into CI and using the
<code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">different</span><span class="o">-</span><span class="n">outcomes</span></code> flag may be appropriate. Then, once youve
improved brittleness sufficiently, you can likely remove that flag (and
likely have significantly lower limits on other metrics).</p>

<h5 id="13762-improving-proof-brittleness">13.7.6.2. Improving proof brittleness</h5>

<p>Reducing proof brittleness is typically closely related to improving
performance overall. As such, <a href="#sec-verification-debugging-slow">techniques for debugging slow
verification</a> are typically useful for
debugging brittle proofs, as well. See also the
<a href="../VerificationOptimization/VerificationOptimization">verification optimization
guide</a>.</p>

<h3 id="sec-compilation">13.8. Compilation</h3>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool can compile a Dafny program to one of several target languages. Details and idiosyncrasies of each
of these are described in the following subsections. In general note the following:</p>

<ul>
  <li>The compiled code originating from <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> can be combined with other source and binary code, but only the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code>-originated code is verified.</li>
  <li>Output file or folder names can be set using <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">output</span></code>.</li>
  <li>Code generated by <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> requires a Dafny-specific runtime library.  By default the runtime is included in the generated code. However for <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code> it is not
included by default and must be explicitly requested using <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="kr">include</span><span class="o">-</span><span class="n">runtime</span></code>.  All runtime libraries are part of the Binary (<code class="language-dafny highlighter-rouge"><span class="o">./</span><span class="n">DafnyRuntime</span><span class="o">.*</span></code>) and Source (<code class="language-dafny highlighter-rouge"><span class="o">./</span><span class="n">Source</span><span class="o">/</span><span class="n">DafnyRuntime</span><span class="o">/</span><span class="n">DafnyRuntime</span><span class="o">.*</span></code>) releases.</li>
  <li>Names in Dafny are written out as names in the target language. In some cases this can result in naming conflicts. Thus if a Dafny program is intended to be compiled to a target language X, you should avoid using Dafny identifiers that are not legal identifiers in X or that conflict with reserved words in X.</li>
</ul>

<p>To be compilable to an executable program, a Dafny program must contain a <code class="language-dafny highlighter-rouge"><span class="n">Main</span></code> entry point, as described <a href="#sec-user-guide-main">here</a>.</p>

<h4 id="sec-compilation-built-ins">13.8.1.1 Built-in declarations</h4>

<p>Dafny includes several built-in types such as tuples, arrays, arrows (functions), and the <code class="language-dafny highlighter-rouge"><span class="kt">nat</span></code> subset type.
The supporting target language code for these declarations could be emitted on-demand,
but these could then become multiple definitions of the same symbols when compiling multiple components separately. 
Instead, all such built-ins up to a pre-configured maximum size are included in most of the runtime libraries.
This means that when compiling to certain target languages, the use of such built-ins above these maximum sizes,
such as tuples with more than 20 elements, is not supported.
See the <a href="#sec-supported-features-by-target-language">Supported features by target language</a> table
for the details on these limits.</p>

<h4 id="sec-extern-decls">13.8.2. <code class="language-dafny highlighter-rouge"><span class="n">extern</span></code> declarations</h4>

<p>A Dafny declaration can be marked with the <a href="#sec-extern"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code></a> attribute to
indicate that it refers to an external definition that is already
present in the language that the Dafny code will be compiled to (or will
be present by the time the final target-language program is compiled or
run).</p>

<p>Because the <a href="#sec-extern"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code></a> attribute controls interaction with code written
in one of many languages, it has some language-specific behavior,
documented in the following sections. However, some aspects are
target-language independent and documented here.</p>

<p>The attribute can also take several forms, each defining a different
relationship between a Dafny name and a target language name. In the
form <a href="#sec-extern"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code></a>, the name of the external definition is
assumed to be the name of the Dafny declaration after some
target-specific name mangling. However, because naming conventions (and
the set of allowed identifiers) vary between languages, Dafny allows
additional forms for the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> attribute.</p>

<p>The form <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span> <span class="o">&lt;</span><span class="n">s1</span><span class="o">&gt;</span><span class="p">}</span></code> instructs <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> to compile references to most
declarations using the name <code class="language-dafny highlighter-rouge"><span class="n">s1</span></code> instead of the Dafny name. For <a href="#sec-abstract-types">abstract
types</a>, however, <code class="language-dafny highlighter-rouge"><span class="n">s1</span></code> is sometimes used as a hint as
to how to declare that type when compiling. This hint is interpreted
differently by each compiler.</p>

<p>Finally, the form <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span> <span class="o">&lt;</span><span class="n">s1</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">s2</span><span class="o">&gt;</span><span class="p">}</span></code> instructs <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> to use <code class="language-dafny highlighter-rouge"><span class="n">s2</span></code> as
the direct name of the declaration. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> will typically use a
combination of <code class="language-dafny highlighter-rouge"><span class="n">s1</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">s2</span></code>, such as <code class="language-dafny highlighter-rouge"><span class="n">s1</span><span class="o">.</span><span class="n">s2</span></code>, to reference the
declaration. It may also be the case that one of the arguments is simply
ignored, depending on the target language.</p>

<p>The recommended style is to prefer <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> when possible, and use
similar names across languages. This is usually feasible because
existing external code is expected to have the same interface as the
code that <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> would generate for a declaration of that form. Because
many Dafny types compile down to custom types defined in the Dafny
runtime library, its typically necessary to write wrappers by hand that
encapsulate existing external code using a compatible interface, and
those wrappers can have names chosen for compatibility. For example,
retrieving the list of command line arguments when compiling to C#
requires a wrapper such as the following:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">using</span> <span class="nn">icharseq</span> <span class="p">=</span> <span class="n">Dafny</span><span class="p">.</span><span class="n">ISequence</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;;</span>
<span class="k">using</span> <span class="nn">charseq</span> <span class="p">=</span> <span class="n">Dafny</span><span class="p">.</span><span class="n">Sequence</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;;</span>

<span class="k">namespace</span> <span class="nn">Externs_Compile</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">__default</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">Dafny</span><span class="p">.</span><span class="n">ISequence</span><span class="p">&lt;</span><span class="n">icharseq</span><span class="p">&gt;</span> <span class="nf">GetCommandLineArgs</span><span class="p">()</span> <span class="p">{</span>
      <span class="kt">var</span> <span class="n">dafnyArgs</span> <span class="p">=</span> <span class="n">Environment</span>
                      <span class="p">.</span><span class="nf">GetCommandLineArgs</span><span class="p">()</span>
                      <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">charseq</span><span class="p">.</span><span class="n">FromString</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Dafny</span><span class="p">.</span><span class="n">Sequence</span><span class="p">&lt;</span><span class="n">icharseq</span><span class="p">&gt;.</span><span class="nf">FromArray</span><span class="p">(</span><span class="n">dafnyArgs</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This serves as an example of implementing an extern,
but was only necessary to retrieve command line arguments historically,
as <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> now supports capturing these arguments via a main method
that accepts a <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span></code> (see the section on the <a href="#sec-user-guide-main">Main method</a>).</p>

<p>Note that <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> does not check the arguments to <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code>, so it is
the users responsibility to ensure that the provided names result in
code that is well-formed in the target language.</p>

<p>Also note that the interface the external code needs to implement
may be affected by compilation flags. In this case, if <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span><span class="o">:</span><span class="kc">true</span></code>
is provided, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> will compile its <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> type to the <code class="language-dafny highlighter-rouge"><span class="n">Dafny</span><span class="o">.</span><span class="n">Rune</span></code>
C# type instead, so the references to the C# type <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> above
would need to be changed accordingly. The reference to <code class="language-dafny highlighter-rouge"><span class="n">charseq</span><span class="o">.</span><span class="n">FromString</span></code>
would in turn need to be changed to <code class="language-dafny highlighter-rouge"><span class="n">charseq</span><span class="o">.</span><span class="n">UnicodeFromString</span></code> to
return the correct type.</p>

<p>Most declarations, including those for modules, classes, traits, member
variables, constructors, methods, function methods, and abstract types,
can be marked with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code>.</p>

<p>Marking a module with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> indicates that the declarations
contained within can be found within the given module, namespace, package, or
similar construct within the target language. Some members of the Dafny
module may contain definitions, in which case code for those definitions
will be generated. Whether this results in valid target code may depend
on some target language support for something resembling partial
modules, where different subsets of the contents are defined in
different places.</p>

<p>The story for classes is similar. Code for a class will be generated
if any of its members are not <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code>. Depending on the target
language, making either all or none of the members <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> may be
the only options that result in valid target code. Traits with
<code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> can refer to existing traits or interfaces in the target
language, or can refer to the interfaces of existing classes.</p>

<p>Member variables marked with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> refer to fields or properties
in existing target-language code. Constructors, methods, and functions
refer to the equivalent concepts in the target language. They
can have contracts, which are then assumed to hold for the existing
target-language code. They can also have bodies, but the bodies will not
be compiled in the presence of the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> attribute. Bodies can
still be used for reasoning, however, so may be valuable in some cases,
especially for function methods.</p>

<p>Types marked with <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> must be opaque. The name argument, if any,
usually refers to the type name in the target language, but some
compilers treat it differently.</p>

<p>Detailed description of the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> commands and 
the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">input</span></code> option (needed when <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> has more than one input file)
is contained <a href="#command-line">in the section on command-line structure</a>.</p>

<h4 id="1383-replaceable-modules">13.8.3. Replaceable modules</h4>
<p>To enable easily customising runtime behavior across an entire Dafny program, Dafny has placeholder modules. Here follows an example:</p>

<!-- %check-run -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">replaceable</span> <span class="kr">module</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="kr">method</span> <span class="n">Bar</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> 
    <span class="kr">ensures</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="kr">method</span> <span class="n">Main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">var</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">Foo</span><span class="o">.</span><span class="n">Bar</span><span class="p">();</span>
  <span class="kr">print</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// At this point, the program can be verified but not run.</span>

<span class="kr">module</span> <span class="n">ConcreteFoo</span> <span class="n">replaces</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="kr">method</span> <span class="n">Bar</span><span class="p">()</span> <span class="kr">returns</span> <span class="p">(</span><span class="n">i</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">return</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// Main will print 3.</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// ConcreteFoo can be swapped out for different replacements of Foo, to customize runtime behavior.</span>
</code></pre></div></div>

<p>When replacing a replaceable module, the same rules apply as when refining an abstract module. However, unlike an abstract module, a placeholder module can be used as if it is a concrete module. When executing code, using for example <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code>, any program that contains a placeholder module must also contain a replacement of this placeholder. When using <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">verify</span></code>, placeholder modules do not have to be replaced.</p>

<p>Replaceable modules are particularly useful for defining behavior that depends on which target language Dafny is translated to.</p>

<h4 id="1384-c">13.8.4. C#</h4>

<p>For a simple Dafny-only program, the translation step converts a <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code> file into <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">cs</span></code>;
the build step then produces a <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dll</span></code>, which can be used as a library or as an executable (run using <code class="language-dafny highlighter-rouge"><span class="n">dotnet</span> <span class="n">A</span><span class="o">.</span><span class="n">dll</span></code>).</p>

<p>It is also possible to run the dafny files as part of a <code class="language-dafny highlighter-rouge"><span class="n">csproj</span></code> project, with these steps:</p>
<ul>
  <li>create a dotnet project file with the command <code class="language-dafny highlighter-rouge"><span class="n">dotnet</span> <span class="kr">new</span> <span class="n">console</span></code></li>
  <li>delete the <code class="language-dafny highlighter-rouge"><span class="n">Program</span><span class="o">.</span><span class="n">cs</span></code> file</li>
  <li>build the dafny program: <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code></li>
  <li>run the built program <code class="language-dafny highlighter-rouge"><span class="n">dotnet</span> <span class="n">A</span><span class="o">.</span><span class="n">dll</span></code></li>
</ul>

<p>The last two steps can be combined:
<code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code></p>

<p>Note that all input <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> files and any needed runtime library code are combined into a single <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">cs</span></code> file, 
which is then compiled by <code class="language-dafny highlighter-rouge"><span class="n">dotnet</span></code> to a <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dll</span></code>.</p>

<p>Examples of how to integrate C# libraries and source code with Dafny source code
are contained in <a href="integration-cs/IntegrationCS">this separate document</a>.</p>

<h4 id="1385-java">13.8.5. Java</h4>

<p>The Dafny-to-Java compiler translation phase writes out the translated files of a file <em>A</em><code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code>
to a directory <em>A</em><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">java</span></code>. 
The build phase writes out a library or executable jar file.
The <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">output</span></code> option (<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">out</span></code> in the legacy CLI) can be used to choose a
different jar file path and name and correspondingly different directory for .java and .class files.</p>

<p>The compiler produces a single wrapper method that then calls classes in 
relevant other <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">java</span></code> files. Because Java files must be named consistent
with the class they contain, but Dafny files do not, there may be no relation
between the Java file names and the Dafny file names.
However, the wrapper class that contains the Java <code class="language-dafny highlighter-rouge"><span class="n">main</span></code> method is named for
the first <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> file on the command-line.</p>

<p>The step of compiling Java files (using <code class="language-dafny highlighter-rouge"><span class="n">javac</span></code>) requires the Dafny runtime library. 
That library is automatically included if dafny is doing the compilation,
but not if dafny is only doing translation.</p>

<p>Examples of how to integrate Java source code and libraries with Dafny source
are contained in <a href="integration-java/IntegrationJava">this separate document</a>.</p>

<h4 id="1386-javascript">13.8.6. Javascript</h4>

<p>The Dafny-to-Javascript compiler translates all the given <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> files into a single <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">js</span></code> file, 
which can then be run using <code class="language-dafny highlighter-rouge"><span class="n">node</span></code>. (Javascript has no compilation step). 
The build and run steps are simply</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span> <span class="o">--</span><span class="n">target</span><span class="o">:</span><span class="n">js</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">node</span> <span class="n">A</span><span class="o">.</span><span class="n">js</span></code></li>
</ul>

<p>Or, in one step,</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code></li>
</ul>

<p>Examples of how to integrate Javascript libraries and source code with Dafny source
are contained in <a href="integration-js/IntegrationJS">this separate document</a>.</p>

<h4 id="1387-go">13.8.7. Go</h4>

<p>The Dafny-to-Go compiler translates all the given <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> files into a single
<code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">go</span></code> file in <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">-</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">A</span><span class="o">.</span><span class="n">go</span></code>; the output folder can be specified with the 
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">out</span></code> option. For an input file <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code> the default output folder is <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">-</span><span class="n">go</span></code>. 
Then, Dafny compiles this program and creates an <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">exe</span></code> executable in the same folder as <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code>.
Some system runtime code is also placed in <code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">-</span><span class="n">go</span><span class="o">/</span><span class="n">src</span></code>.
The build and run steps are</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span> <span class="o">--</span><span class="n">target</span><span class="o">:</span><span class="n">go</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">./</span><span class="n">A</span></code></li>
</ul>

<p>The uncompiled code can be compiled and run by <code class="language-dafny highlighter-rouge"><span class="n">go</span></code> itself using</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">cd</span> <span class="n">A</span><span class="o">-</span><span class="n">go</span><span class="p">;</span> <span class="n">GO111MODULE</span><span class="o">=</span><span class="n">auto</span> <span class="n">GOPATH</span><span class="o">=</span><span class="p">`</span><span class="n">pwd</span><span class="p">`</span> <span class="n">go</span> <span class="n">run</span> <span class="n">src</span><span class="o">/</span><span class="n">A</span><span class="o">.</span><span class="n">go</span><span class="p">)</span></code></li>
</ul>

<p>The one-step process is</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="o">--</span><span class="n">target</span><span class="o">:</span><span class="n">go</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code></li>
</ul>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">GO111MODULE</span></code> variable is used because Dafny translates to pre-module Go code.
When the implementation changes to current Go, the above command-line will
change, though the <code class="language-dafny highlighter-rouge"><span class="o">./</span><span class="n">A</span></code> alternative will still be supported.</p>

<p>Examples of how to integrate Go source code and libraries with Dafny source
are contained in <a href="integration-go/IntegrationGo">this separate document</a>.</p>

<h4 id="1388-python">13.8.8. Python</h4>

<p>The Dafny-to-Python compiler is still under development. However, simple
Dafny programs can be built and run as follows. The Dafny-to-Python
compiler translates the <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">dfy</span></code> files into a single <code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">py</span></code> file along with 
supporting runtime library code, all placed in the output location 
(<code class="language-dafny highlighter-rouge"><span class="n">A</span><span class="o">-</span><span class="n">py</span></code> for an input file A.dfy, by default).</p>

<p>The build and run steps are</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span> <span class="o">--</span><span class="n">target</span><span class="o">:</span><span class="n">py</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">python</span> <span class="n">A</span><span class="o">-</span><span class="n">py</span><span class="o">/</span><span class="n">A</span><span class="o">.</span><span class="n">py</span></code></li>
</ul>

<p>In one step:</p>
<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span> <span class="o">--</span><span class="n">target</span><span class="o">:</span><span class="n">py</span> <span class="n">A</span><span class="o">.</span><span class="n">dfy</span></code></li>
</ul>

<p>Examples of how to integrate Python libraries and source code with Dafny source
are contained in <a href="integration-py/IntegrationPython">this separate document</a>.</p>

<h4 id="1389-c">13.8.9. C++</h4>

<p>The C++ backend was written assuming that it would primarily support writing
C/C++ style code in Dafny, which leads to some limitations in the current
implementation.</p>

<ul>
  <li>The C++ compiler does not support BigIntegers, so do not use <code class="language-dafny highlighter-rouge"><span class="kt">int</span></code>, or raw instances of
<code class="language-dafny highlighter-rouge"><span class="n">arr</span><span class="o">.</span><span class="n">Length</span></code>, or sequence length, etc. in executable code.  You can however,
use <code class="language-dafny highlighter-rouge"><span class="n">arr</span><span class="o">.</span><span class="n">Length</span> <span class="ow">as</span> <span class="n">uint64</span></code> if you can prove your array is an appropriate
size.  The compiler will report inappropriate integer use.</li>
  <li>The C++ compiler does not support advanced Dafny features like traits or coinductive
types.</li>
  <li>There is very limited support for higher order functions even for array initialization.  Use
extern definitions like newArrayFill (see 
<a href="https://github.com/dafny-lang/dafny/blob/master/Test/c++/extern.dfy">extern.dfy</a>) or
similar.  See also the example in [<code class="language-dafny highlighter-rouge"><span class="n">functions</span><span class="o">.</span><span class="n">dfy</span></code>]
(https://github.com/dafny-lang/dafny/blob/master/Test/c++/functions.dfy).</li>
  <li>The current backend also assumes the use of C++17 in order to cleanly and
performantly implement datatypes.</li>
</ul>

<h4 id="sec-supported-features-by-target-language">13.8.10. Supported features by target language</h4>

<p>Some Dafny features are not supported by every target language.
The table below shows which features are supported by each backend.
An empty cell indicates that a feature is not supported,
while an X indicates that it is.</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>C#</th>
      <th>JavaScript</th>
      <th>Go</th>
      <th>Java</th>
      <th>Python</th>
      <th>C++</th>
      <th>Dafny Library (.doo)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#sec-numeric-types">Unbounded integers</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-numeric-types">Real numbers</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-ordinals">Ordinals</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-arrow-subset-types">Function values</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-iterator-types">Iterators</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-collection-types">Collections with trait element types</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-extern-decls">External module names with only underscores</a></td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-coinductive-datatypes">Co-inductive datatypes</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-multisets">Multisets</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#">Runtime type descriptors</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-multi-dimensional-arrays">Multi-dimensional arrays</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-map-comprehension-expression">Map comprehensions</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-trait-types">Traits</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-let-expression">Let-such-that expressions</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-newtypes">Non-native numeric newtypes</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-synthesize-attr">Method synthesis</a></td>
      <td>X</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-extern-decls">External classes</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-object-type">Instantiating the <code class="language-dafny highlighter-rouge"><span class="kt">object</span></code> type</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-forall-statement"><code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statements that cannot be sequentialized</a><sup id="fnref:compiler-feature-forall-note" role="doc-noteref"><a href="#fn:compiler-feature-forall-note" class="footnote" rel="footnote">26</a></sup></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-array-type">Taking an arrays length</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-maps"><code class="language-dafny highlighter-rouge"><span class="n">m</span><span class="o">.</span><span class="n">Items</span></code> when <code class="language-dafny highlighter-rouge"><span class="n">m</span></code> is a map</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-test-attribute">The /runAllTests option</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-quantifier-domains">Integer range constraints in quantifiers (e.g. <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">b</span></code>)</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-quantifier-domains">Exact value constraints in quantifiers (<code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="o">==</span> <span class="n">C</span></code>)</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-sequence-displays">Sequence displays of characters</a><sup id="fnref:compiler-sequence-display-of-characters-note" role="doc-noteref"><a href="#fn:compiler-sequence-display-of-characters-note" class="footnote" rel="footnote">27</a></sup></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-as-is-expression">Type test expressions (<code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">is</span> <span class="n">T</span></code>)</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-as-is-expression">Type test expressions on subset types</a></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-quantifier-expression">Quantifiers</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-bit-vector-types">Bitvector RotateLeft/RotateRight functions</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-for-statement"><code class="language-dafny highlighter-rouge"><span class="kr">for</span></code> loops</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-break-continue-statement"><code class="language-dafny highlighter-rouge"><span class="n">continue</span></code> statements</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-update-and-call-statement">Assign-such-that statements with potentially infinite bounds</a><sup id="fnref:compiler-infinite-assign-such-that-note" role="doc-noteref"><a href="#fn:compiler-infinite-assign-such-that-note" class="footnote" rel="footnote">28</a></sup></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-other-sequence-expressions">Sequence update expressions</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-sequence-displays">Sequence constructions with non-lambda initializers</a><sup id="fnref:compiler-sequence-display-nolambda-note" role="doc-noteref"><a href="#fn:compiler-sequence-display-nolambda-note" class="footnote" rel="footnote">29</a></sup></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-extern-decls">Externally-implemented constructors</a></td>
      <td>X</td>
      <td></td>
      <td></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-tuple-types">Auto-initialization of tuple variables</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-quantifier-expression">Subtype constraints in quantifiers</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="##sec-compilation-built-ins">Tuples with more than 20 arguments</a></td>
      <td></td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="##sec-compilation-built-ins">Arrays with more than 16 dimensions</a></td>
      <td></td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="##sec-compilation-built-ins">Arrow types with more than 16 arguments</a></td>
      <td></td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="##sec-characters">Unicode chars</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-print-statement">Converting values to strings</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-dafny-commands">Legacy CLI without commands</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
    </tr>
    <tr>
      <td><a href="#sec-compilation">Separate compilation</a></td>
      <td>X</td>
      <td></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-compilation-built-ins">All built-in types in runtime library</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-dafny-test">Execution coverage report</a></td>
      <td>X</td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td><a href="#sec-dafny-standard-libraries">Standard libraries</a></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#sec-dafny-standard-libraries">Standard library ActionsExterns</a></td>
      <td>X</td>
      <td></td>
      <td></td>
      <td>X</td>
      <td></td>
      <td></td>
      <td>X</td>
    </tr>
  </tbody>
</table>

<h3 id="sec-command-line-options">13.9. Dafny Command Line Options</h3>

<p>There are many command-line options to the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> tool.
The most current documentation of the options is within the tool itself,
using the <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">?</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">help</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">h</span></code> options.</p>

<p>Remember that options are typically stated with either a leading <code class="language-dafny highlighter-rouge"><span class="o">--</span></code>.</p>

<p>Legacy options begin with either - or /; however they are being
migrated to the POSIX-compliant <code class="language-dafny highlighter-rouge"><span class="o">--</span></code> form as needed.</p>

<h4 id="sec-controlling-help">13.9.1. Help and version information</h4>

<p>These options emit general information about commands, options and attributes.
When present, the dafny program will terminates after emitting the requested information
but without processing any files.</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">help</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">h</span></code> - shows the various commands (which have help information under them as <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">&lt;</span><span class="n">command</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">h</span></code></p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">version</span></code> - show the version of the build</p>
  </li>
</ul>

<p>Legacy options:</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">?</span></code> - print out the legacy list of command-line options
and terminate. All of these options are also described in this and
the following sections.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">attrHelp</span></code> - print out the current list of supported attribute
declarations and terminate.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">env</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - print the command-line arguments supplied to the program.
The value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - never print command-line arguments.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> (default) - print them to Boogie (<code class="language-dafny highlighter-rouge"><span class="o">.</span><span class="n">bpl</span></code>) files and prover logs.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">2</span></code> - operate like with option <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> but also print to standard output.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">wait</span></code> - wait for the user to press <code class="language-dafny highlighter-rouge"><span class="n">Enter</span></code> before terminating after a successful execution.</p>
  </li>
</ul>

<h4 id="sec-controlling-input">13.9.2. Controlling input</h4>

<p>These options control how Dafny processes its input.</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">stdin</span></code> - read standard input and treat it as Dafny source code,
instead of reading from a file.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">library</span><span class="o">:&lt;</span><span class="n">files</span><span class="o">&gt;</span></code> - treat the given files as <em>library</em> code, namely, skip
these files (and any files recursively included) during verification;
the value may be a comma-separated-list of files or folders; folders are expanded into
a list of all .dfy files contained, recursively, in those folders</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">prelude</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">dprelude</span></code>) - select an alternative Dafny prelude file. This
file contains Boogie definitions (including many axioms) required by
the translator from Dafny to Boogie. Using an alternative prelude is
primarily useful if youre extending the Dafny language or changing
how Dafny constructs are modeled. The default prelude is 
<a href="https://github.com/dafny-lang/dafny/blob/master/Source/DafnyCore/DafnyPrelude.bpl">here</a>.</p>
  </li>
</ul>

<h4 id="sec-controlling-plugins">13.9.3. Controlling plugins</h4>

<p>Dafny has a plugin capability. 
A plugin has access to an AST of the dafny input files
after all parsing and resolution are performed (but not verification)
and also to the command-line options.</p>

<p>This facility is still <em>experimental</em> and very much in flux, particularly 
the form of the AST. The best guides to writing a new plugin are
(a) the documentation in <a href="#sec-plugins">the section of this manual on plugins</a> 
and (b) example plugins in the
<code class="language-dafny highlighter-rouge"><span class="n">src</span><span class="o">/</span><span class="n">Tools</span></code> folder of the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span><span class="o">-</span><span class="n">lang</span><span class="o">/</span><span class="n">compiler</span><span class="o">-</span><span class="n">bootstrap</span></code> repo.</p>

<p>The value of the option <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">plugin</span></code> is a path to a dotnet dll that contains
the compiled plugin.</p>

<h4 id="sec-controlling-output">13.9.4. Controlling output</h4>

<p>These options instruct Dafny to print various information about your
program during processing, including variations of the original source
code (which can be helpful for debugging).</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">use</span><span class="o">-</span><span class="n">basename</span><span class="o">-</span><span class="kr">for</span><span class="o">-</span><span class="n">filename</span></code> - when enabled, just the filename without the 
directory path is used in error messages; this make error message shorter and 
not tied to the local environment (which is a help in testing)</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">output</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">o</span></code> - location of output files [translate, build]</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">snippets</span></code> - include with an error message some of the source code text
in the neighborhood of the error; the error location (file, line, column) is always given</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">solver</span><span class="o">-</span><span class="n">log</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> - [verification only] the file in which to place the SMT text sent to the solver</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">log</span><span class="o">-</span><span class="n">format</span> <span class="o">&lt;</span><span class="n">configuration</span><span class="o">&gt;</span></code> - [verification only] (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">verificationLogger</span><span class="o">:&lt;</span><span class="n">configuration</span> <span class="kt">string</span><span class="o">&gt;</span></code>)
log verification
results to the given test result logger. The currently supported
loggers are <code class="language-dafny highlighter-rouge"><span class="n">trx</span></code>, <code class="language-dafny highlighter-rouge"><span class="n">csv</span></code>, and <code class="language-dafny highlighter-rouge"><span class="n">text</span></code>. These are the XML-based formats
commonly used for test results for .NET languages, a custom CSV
schema, and a textual format meant for human consumption,
respectively. You can provide configuration using the same string
format as when using the <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">logger</span></code> option for dotnet test, such as:</p>

    <div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="o">-</span><span class="n">verificationLogger</span><span class="o">:</span><span class="n">trx</span><span class="p">;</span><span class="n">LogFileName</span><span class="o">=&lt;...&gt;</span>
</code></pre></div>    </div>

    <p>The exact mapping of verification concepts to these formats is
experimental and subject to change!</p>

    <p>The <code class="language-dafny highlighter-rouge"><span class="n">trx</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">csv</span></code> loggers automatically choose an output file name
by default, and print the name of this file to the console. The <code class="language-dafny highlighter-rouge"><span class="n">text</span></code>
logger prints its output to the console by default, but can send
output to a file given the <code class="language-dafny highlighter-rouge"><span class="n">LogFileName</span></code> option.</p>

    <p>The <code class="language-dafny highlighter-rouge"><span class="n">text</span></code> logger also includes a more detailed breakdown of what
assertions appear in each assertion batch. When combined with the
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">vcsSplitOnEveryAssert</span></code> option, it will provide approximate time and
resource use costs for each assertion, allowing identification of
especially expensive assertions.</p>
  </li>
</ul>

<p>Legacy options:</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">stats</span></code> - print various statistics about the Dafny files supplied on
the command line. The statistics include the number of total
functions, recursive functions, total methods, ghost methods, classes,
and modules. They also include the maximum call graph width and the
maximum module height.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">dprint</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> - print the Dafny program after parsing (use <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> for
<code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> to print to the console).</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">rprint</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> - print the Dafny program after type resolution (use
<code class="language-dafny highlighter-rouge"><span class="o">-</span></code> for <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> to print to the console).</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">printMode</span><span class="o">:&lt;</span><span class="n">Everything</span><span class="o">|</span><span class="n">DllEmbed</span><span class="o">|</span><span class="n">NoIncludes</span><span class="o">|</span><span class="n">NoGhost</span><span class="o">&gt;</span></code> - select what to
include in the output requested by <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">dprint</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">rprint</span></code>. The
argument can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">Everything</span></code> (default) - include everything.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">DllEmbed</span></code>- print the source that will be included in a compiled DLL.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">NoIncludes</span></code> - disable printing of methods incorporated via the
include mechanism that have the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">verify</span> <span class="kc">false</span><span class="p">}</span></code> attribute, as well
as datatypes and fields included from other files.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">NoGhost</span></code> - disables printing of functions, ghost methods, and proof
statements in implementation methods. Also disable anything
<code class="language-dafny highlighter-rouge"><span class="n">NoIncludes</span></code> disables.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">printIncludes</span><span class="o">:&lt;</span><span class="n">None</span><span class="o">|</span><span class="n">Immediate</span><span class="o">|</span><span class="n">Transitive</span><span class="o">&gt;</span></code> - select what information
from included files to incorporate into the output selected by
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">dprint</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">rprint</span></code>. The argument can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">None</span></code> (default) - dont print anything from included files.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">Immediate</span></code> - print files directly included by files specified on
the command line. Exit after printing.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">Transitive</span></code> - print files transitively included by files specified
on the command line. Exit after printing.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">view</span><span class="o">:&lt;</span><span class="n">view1</span><span class="p">,</span> <span class="n">view2</span><span class="o">&gt;</span></code> - this option limits what is printed by /rprint
for a module to the names that are part of the given export set;
the option argument is a comma-separated list of fully-qualified export
set names.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">funcCallGraph</span></code> - print out the function call graph. Each line has
the format <code class="language-dafny highlighter-rouge"><span class="n">func</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">callee</span><span class="o">*</span></code>, where <code class="language-dafny highlighter-rouge"><span class="n">func</span></code> is the name of a function,
<code class="language-dafny highlighter-rouge"><span class="n">mod</span></code> is the name of its containing module, and <code class="language-dafny highlighter-rouge"><span class="n">callee</span><span class="o">*</span></code> is a
space-separated list of the functions that <code class="language-dafny highlighter-rouge"><span class="n">func</span></code> calls.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">snippets</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">showSnippets</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> ) - show a source code snippet for each Dafny
message. The legacy option was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">showSnippets</span></code> with values 0 and 1 for false and true.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">printTooltips</span></code> - dump additional positional information (displayed
as mouse-over tooltips by LSP clients) to standard output as <code class="language-dafny highlighter-rouge"><span class="n">Info</span></code>
messages.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">pmtrace</span></code> - print debugging information from the pattern-match
compiler.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">titrace</span></code> - print debugging information during the type inference
process.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">diagnosticsFormat</span><span class="o">:&lt;</span><span class="n">text</span><span class="o">|</span><span class="n">json</span><span class="o">&gt;</span></code> - control how to report errors, warnings, and info
messages.  <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">fmt</span><span class="o">&gt;</span></code> may be one of the following:</p>

    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="n">text</span></code> (default): Report diagnostics in human-readable format.</li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">json</span></code>: Report diagnostics in JSON format, one object per diagnostic, one
diagnostic per line.  Info-level messages are only included with
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">printTooltips</span></code>.  End positions are only included with <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">showSnippets</span><span class="o">:</span><span class="mi">1</span></code>.
Diagnostics are the following format (but without newlines):</p>

        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"location"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"filename"</span><span class="p">:</span><span class="w"> </span><span class="s2">"xyz.dfy"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"range"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Start</span><span class="w"> </span><span class="err">and</span><span class="w"> </span><span class="err">(optional)</span><span class="w"> </span><span class="err">end</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">diagnostic</span><span class="w">
      </span><span class="nl">"start"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"pos"</span><span class="p">:</span><span class="w"> </span><span class="mi">83</span><span class="p">,</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="mi">0</span><span class="err">-based</span><span class="w"> </span><span class="err">character</span><span class="w"> </span><span class="err">offset</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">input</span><span class="w">
        </span><span class="nl">"line"</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="mi">1</span><span class="err">-based</span><span class="w"> </span><span class="err">line</span><span class="w"> </span><span class="err">number</span><span class="w">
        </span><span class="nl">"character"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="mi">0</span><span class="err">-based</span><span class="w"> </span><span class="err">column</span><span class="w"> </span><span class="err">number</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"end"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"pos"</span><span class="p">:</span><span class="w"> </span><span class="mi">86</span><span class="p">,</span><span class="w"> </span><span class="nl">"line"</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="nl">"character"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"severity"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="err">error;</span><span class="w"> </span><span class="mi">2</span><span class="err">:</span><span class="w"> </span><span class="err">warning;</span><span class="w"> </span><span class="mi">4</span><span class="err">:</span><span class="w"> </span><span class="err">info</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"module-level const declarations are always non-instance ..."</span><span class="p">,</span><span class="w">
  </span><span class="nl">"source"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Parser"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"relatedInformation"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Additional</span><span class="w"> </span><span class="err">messages</span><span class="p">,</span><span class="w"> </span><span class="err">if</span><span class="w"> </span><span class="err">any</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"location"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Like</span><span class="w"> </span><span class="err">above</span><span class="w">
      </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="p">,</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="sec-controlling-language">13.9.5. Controlling language features</h4>

<p>These options allow some Dafny language features to be enabled or
disabled. Some of these options exist for backward compatibility with
older versions of Dafny.</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">default</span><span class="o">-</span><span class="kr">function</span><span class="o">-</span><span class="n">opacity</span><span class="o">:&lt;</span><span class="n">transparent</span><span class="o">|</span><span class="n">autoRevealDependencies</span><span class="o">|</span><span class="n">opaque</span><span class="o">&gt;</span></code> - Change the default opacity of functions.
    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="n">transparent</span></code> (default) means functions are transparent, can be manually made opaque and then revealed.</li>
      <li><code class="language-dafny highlighter-rouge"><span class="n">autoRevealDependencies</span></code> makes all functions not explicitly labelled as opaque to be opaque but reveals them automatically in scopes which do not have <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="kc">false</span><span class="p">}</span></code>.</li>
      <li><code class="language-dafny highlighter-rouge"><span class="n">opaque</span></code> means functions are always opaque so the opaque keyword is not needed, and functions must be revealed everywhere needed for a proof.</li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="kr">function</span><span class="o">-</span><span class="n">syntax</span></code> (value 3 or 4) - permits a choice of using the Dafny 3 syntax (<code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">method</span></code>)
or the Dafny 4 syntax (<code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">function</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code>)</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">quantifier</span><span class="o">-</span><span class="n">syntax</span></code> (value 3 or 4) - permits a choice between the Dafny 3 and Dafny 4 syntax for quantifiers</p>
  </li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span></code> - if false, the <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> type represents any UTF-16 code unit,
that is, any 16-bit value, including surrogate code points and
allows <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">uXXXX</span></code> escapes in string and character literals.
If true, <code class="language-dafny highlighter-rouge"><span class="kt">char</span></code> represents any Unicode scalar value,
that is, any Unicode code point excluding surrogates and
allows <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">U</span><span class="p">{</span><span class="n">X</span><span class="o">..</span><span class="n">X</span><span class="p">}</span></code> escapes in string and character literals. 
The default is false for Dafny version 3 and true for version 4.
The legacy option was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">unicodeChar</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> with values 0 and 1 for
false and true above.</li>
</ul>

<p>Legacy options:</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">noIncludes</span></code> - ignore <code class="language-dafny highlighter-rouge"><span class="kr">include</span></code> directives in the program.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">noExterns</span></code> - ignore <code class="language-dafny highlighter-rouge"><span class="n">extern</span></code> attributes in the program.</p>
  </li>
</ul>

<p><a id="sec-function-syntax"></a></p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="kr">function</span><span class="o">-</span><span class="n">syntax</span><span class="o">:&lt;</span><span class="n">version</span><span class="o">&gt;</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">functionSyntax</span><span class="o">:&lt;</span><span class="n">version</span><span class="o">&gt;</span></code> ) - select what function syntax to
recognize. The syntax for functions is changing from Dafny version 3
to version 4. This switch gives early access to the new syntax, and
also provides a mode to help with migration. The valid arguments
include the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> (default) - compiled functions are written <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">method</span></code> and
<code class="language-dafny highlighter-rouge"><span class="kr">predicate</span> <span class="kr">method</span></code>. Ghost functions are written <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> and
<code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">4</span></code> - compiled functions are written <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code>.
Ghost functions are written <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">function</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">predicate</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">migration3to4</span></code> - compiled functions are written <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">method</span></code>
and <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span> <span class="kr">method</span></code>. Ghost functions are written <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">function</span></code>
and <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">predicate</span></code>. To migrate from version 3 to version 4, use
this flag on your version 3 program to flag all occurrences of
<code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code> as parsing errors. These are ghost
functions, so change those into the new syntax <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">function</span></code> and
<code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">predicate</span></code>. Then, start using <br />
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">functionSyntax</span><span class="o">:</span><span class="mi">4</span></code>. This will
flag all occurrences of <code class="language-dafny highlighter-rouge"><span class="kr">function</span> <span class="kr">method</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span> <span class="kr">method</span></code> as
parsing errors. So, change those to just <code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code>.
As a result, your program will use version 4 syntax and have the
same meaning as your previous version 3 program.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">experimentalDefaultGhost</span></code> - like <code class="language-dafny highlighter-rouge"><span class="n">migration3to4</span></code>, but allow
<code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code> as alternatives to declaring ghost
functions and predicates, respectively</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">experimentalDefaultCompiled</span></code> - like <code class="language-dafny highlighter-rouge"><span class="n">migration3to4</span></code>, but allow
<code class="language-dafny highlighter-rouge"><span class="kr">function</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code> as alternatives to declaring compiled
functions and predicates, respectively</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">experimentalPredicateAlwaysGhost</span></code> - compiled functions are written
<code class="language-dafny highlighter-rouge"><span class="kr">function</span></code>. Ghost functions are written <code class="language-dafny highlighter-rouge"><span class="kr">ghost</span> <span class="kr">function</span></code>. Predicates
are always ghost and are written <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code>.</p>
      </li>
    </ul>

    <p>This option can also be set locally (at the module level) using the <code class="language-dafny highlighter-rouge"><span class="o">:</span><span class="n">options</span></code>
attribute:</p>
  </li>
</ul>

<!-- %check-verify -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="kr">module</span> <span class="p">{</span><span class="o">:</span><span class="n">options</span> <span class="s2">"--function-syntax:4"</span><span class="p">}</span> <span class="n">M</span> <span class="p">{</span>
    <span class="kr">predicate</span> <span class="n">CompiledPredicate</span><span class="p">()</span> <span class="p">{</span> <span class="kc">true</span> <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">quantifier</span><span class="o">-</span><span class="n">syntax</span><span class="o">:&lt;</span><span class="n">version</span><span class="o">&gt;</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">quantifierSyntax</span><span class="o">:&lt;</span><span class="n">version</span><span class="o">&gt;</span></code> ) - select what quantifier syntax to recognize.
  The syntax for quantification domains is changing from Dafny version 3 to version 4,
  more specifically where quantifier ranges (<code class="language-dafny highlighter-rouge"><span class="o">|</span> <span class="o">&lt;</span><span class="n">Range</span><span class="o">&gt;</span></code>) are allowed.
  This switch gives early access to the new syntax.</p>

    <ul>
      <li><code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> (default) - Ranges are only allowed after all quantified variables are declared.
  (e.g. <code class="language-dafny highlighter-rouge"><span class="kt">set</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">::</span> <span class="n">y</span></code>)</li>
      <li><code class="language-dafny highlighter-rouge"><span class="mi">4</span></code> - Ranges are allowed after each quantified variable declaration.
  (e.g. <code class="language-dafny highlighter-rouge"><span class="kt">set</span> <span class="n">x</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">::</span> <span class="n">y</span></code>)</li>
    </ul>

    <p>Note that quantifier variable domains (<code class="language-dafny highlighter-rouge"><span class="o">&lt;-</span> <span class="o">&lt;</span><span class="n">Domain</span><span class="o">&gt;</span></code>) are available
  in both syntax versions.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">disableScopes</span></code> - treat all export sets as <code class="language-dafny highlighter-rouge"><span class="kr">export</span> <span class="kr">reveal</span> <span class="o">*</span></code> to never
  hide function bodies or type definitions during translation.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">allowsGlobals</span></code> - allow the implicit class <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">default</span></code> to contain
fields, instance functions, and instance methods. These class members
are declared at the module scope, outside of explicit classes. This
command-line option is provided to simplify a transition from the
behavior in the language prior to version 1.9.3, from which point
onward all functions and methods declared at the module scope are
implicitly static and field declarations are not allowed at the
module scope.</p>
  </li>
</ul>

<h4 id="sec-controlling-warnings">13.9.6. Controlling warnings</h4>

<p>These options control what warnings Dafny produces, and whether to treat
warnings as errors.</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">warn</span><span class="o">-</span><span class="ow">as</span><span class="o">-</span><span class="n">errors</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">warningsAsErrors</span></code>) - treat warnings as errors.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">warn</span><span class="o">-</span><span class="n">shadowing</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">warnShadowing</span></code>) - emit a warning if the name 
of a declared variable caused another variable to be shadowed.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">warn</span><span class="o">-</span><span class="n">missing</span><span class="o">-</span><span class="kr">constructor</span><span class="o">-</span><span class="n">parentheses</span></code> - warn if a constructor name in a pattern might be misinterpreted</p>
  </li>
</ul>

<p>Legacy options</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">deprecation</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - control warnings about deprecated features. The
value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be any of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - dont issue any warnings.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> (default) - issue warnings.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">2</span></code> - issue warnings and advise about alternate syntax.</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="sec-controlling-verification">13.9.7. Controlling verification</h4>

<p>These options control how Dafny verifies the input program, including
how much it verifies, what techniques it uses to perform verification,
and what information it produces about the verification process.</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">verify</span></code> - turns off verification (for translate, build, run commands)</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verify</span><span class="o">-</span><span class="n">included</span><span class="o">-</span><span class="n">files</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">verifyAllModules</span></code>) - verify modules that come from include directives.</p>

    <p>By default, Dafny only verifies files explicitly listed on the command
line: if <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="o">.</span><span class="n">dfy</span></code> includes <code class="language-dafny highlighter-rouge"><span class="n">b</span><span class="o">.</span><span class="n">dfy</span></code>, a call to <code class="language-dafny highlighter-rouge"><span class="n">Dafny</span> <span class="n">a</span><span class="o">.</span><span class="n">dfy</span></code> will detect
and report verification errors from <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="o">.</span><span class="n">dfy</span></code> but not from <code class="language-dafny highlighter-rouge"><span class="n">b</span><span class="o">.</span><span class="n">dfy</span></code>.</p>

    <p>With this option, Dafny will instead verify everything: all input
modules and all their transitive dependencies. This way <code class="language-dafny highlighter-rouge"><span class="n">Dafny</span> <span class="n">a</span><span class="o">.</span><span class="n">dfy</span></code>
will verify <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="o">.</span><span class="n">dfy</span></code> and all files that it includes (here <code class="language-dafny highlighter-rouge"><span class="n">b</span><span class="o">.</span><span class="n">dfy</span></code>), as
well all files that these files include, etc.</p>

    <p>Running Dafny with this option on the file containing your
main result is a good way to ensure that all its dependencies verify.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">track</span><span class="o">-</span><span class="kr">print</span><span class="o">-</span><span class="n">effects</span></code> - If true, a compiled method, constructor, or 
 iterator is allowed to have print effects only if it is marked with 
 . (default false)
 The legacy option was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">trackPrintEffects</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code>) with values 0 or 1
 for false and true.</p>
  </li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">relax</span><span class="o">-</span><span class="n">definite</span><span class="o">-</span><span class="n">assignment</span></code> - control the rules governing definite
assignment, the property that every variable is eventually assigned a
value before it is used.
    <ul>
      <li>if false (default), enforce definite-assignment for all non-yield-parameter
variables and fields, regardless of their types</li>
      <li>if false and <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">enforce</span><span class="o">-</span><span class="n">determinism</span></code> is true, then also performs 
checks in the compiler that no nondeterministic statements are used</li>
      <li>if true, enforce definite-assignment rules for compiled
variables and fields whose types do not support auto-initialization
and for ghost variables and fields whose type is possibly empty.</li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">disable</span><span class="o">-</span><span class="n">nonlinear</span><span class="o">-</span><span class="n">arithmetic</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">noNLarith</span></code>) - reduce 
Z3s knowledge of non-linear arithmetic (the
operators <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">/</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">%</span></code>). Enabling this option will typically
require more manual work to complete proofs (by explicitly applying
lemmas about non-linear operators), but will also result in more
predictable behavior, since Z3 can sometimes get stuck down an
unproductive path while attempting to prove things about those
operators. (This option will perhaps be replaced by <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">arith</span></code> in the
future. For now, it takes precedence over <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">arith</span></code>.)</p>

    <p>The behavior of <code class="language-dafny highlighter-rouge"><span class="n">disable</span><span class="o">-</span><span class="n">nonlinear</span><span class="o">-</span><span class="n">arithmetic</span></code> can be turned on and off on a per-module basis 
by placing the attribute <a href="#sec-disable-nonlinear-arithmetic"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">disable</span><span class="o">-</span><span class="n">nonlinear</span><span class="o">-</span><span class="n">arithmetic</span><span class="p">}</span></code></a> after the module keyword.
The attribute optionally takes the value <code class="language-dafny highlighter-rouge"><span class="kc">false</span></code> to enable nonlinear arithmetic.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">manual</span><span class="o">-</span><span class="kr">lemma</span><span class="o">-</span><span class="n">induction</span></code> - disables automatic inducntion for lemmas</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">isolate</span><span class="o">-</span><span class="n">assertions</span></code> - verify assertions individually</p>
  </li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">extract</span><span class="o">-</span><span class="n">counterexample</span></code> - if verification fails, report a potential
counterexample as a set of assumptions that can be inserted into the code.
Note that Danfy cannot guarantee that the counterexample
it reports provably violates the assertion or that the assumptions are not
mutually inconsistent (see <sup id="fnref:smt-encoding:2" role="doc-noteref"><a href="#fn:smt-encoding" class="footnote" rel="footnote">17</a></sup>), so this output should be inspected manually and treated as a hint.</li>
</ul>

<p>Controlling the proof engine:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">cores</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - sets the number or percent of the available cores to be used for verification</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verification</span><span class="o">-</span><span class="n">time</span><span class="o">-</span><span class="n">limit</span> <span class="o">&lt;</span><span class="n">seconds</span><span class="o">&gt;</span></code> - imposes a time limit on each verification attempt</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verification</span><span class="o">-</span><span class="n">error</span><span class="o">-</span><span class="n">limit</span> <span class="o">&lt;</span><span class="n">number</span><span class="o">&gt;</span></code> - limits the number of verification errors reported (0 is no limit)</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">resource</span><span class="o">-</span><span class="n">limit</span></code> - states a resource limit (to be used by the backend solver)</li>
</ul>

<p>Legacy options:</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">dafnyVerify</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> [discouraged] - turn verification of the program on or off. The
value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be any of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - stop after type checking.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> - continue on to verification and compilation.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">separateModuleOutput</span></code> - output verification results for each module
separately, rather than aggregating them after they are all finished.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">mimicVerificationOf</span><span class="o">:&lt;</span><span class="n">dafny</span> <span class="n">version</span><span class="o">&gt;</span></code> - let <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> attempt to mimic
the verification behavior of a previous version of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code>. This can be
useful during migration to a newer version of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> when a Dafny
program has proofs, such as methods or lemmas, that are highly variable in
the sense that their verification may become slower or fail altogether
after logically irrelevant changes are made in the verification input.</p>

    <p>Accepted versions are: <code class="language-dafny highlighter-rouge"><span class="mf">3.3</span></code>. Note that falling back on the behavior
of version 3.3 turns off features that prevent certain classes of
verification variability.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">noCheating</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - control whether certain assumptions are allowed.
The value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> (default) - allow <code class="language-dafny highlighter-rouge"><span class="kr">assume</span></code> statements and free invariants.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> - treat all assumptions as <code class="language-dafny highlighter-rouge"><span class="kr">assert</span></code> statements, and drop free
invariants.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">induction</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - control the behavior of induction. The value of
<code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - never do induction, not even when attributes request it.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> - apply induction only when attributes request it.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">2</span></code> - apply induction as requested (by attributes) and also for
heuristically chosen quantifiers.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> - apply induction as requested, and for heuristically chosen
quantifiers and lemmas.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">4</span></code> (default) - apply induction as requested, and for all lemmas.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">inductionHeuristic</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - control the heuristics used for induction.
The value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - use the least discriminating induction heuristic (that is,
lean toward applying induction more often).</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">2</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">3</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">4</span></code>, <code class="language-dafny highlighter-rouge"><span class="mi">5</span></code> - use an intermediate heuristic, ordered as
follows as far as how discriminating they are: 0 &lt; 1 &lt; 2 &lt; (3,4) &lt; 5
&lt; 6.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">6</span></code> (default) - use the most discriminating induction heuristic.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="kr">allocated</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - specify defaults for where Dafny should assert and
assume <code class="language-dafny highlighter-rouge"><span class="kr">allocated</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> for various parameters <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>, local variables <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>,
bound variables <code class="language-dafny highlighter-rouge"><span class="n">x</span></code>, etc. Lower <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> may require more manual
<code class="language-dafny highlighter-rouge"><span class="kr">allocated</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> annotations and thus may be more difficult to use. The
value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - never assume or assert <code class="language-dafny highlighter-rouge"><span class="kr">allocated</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> by default.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> - assume <code class="language-dafny highlighter-rouge"><span class="kr">allocated</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> only for non-ghost variables and fields.
(These assumptions are free, since non-ghost variables always
contain allocated values at run-time.) This option may speed up
verification relative to <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="kr">allocated</span><span class="o">:</span><span class="mi">2</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">2</span></code> - assert/assume <code class="language-dafny highlighter-rouge"><span class="kr">allocated</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> on all variables, even bound
variables in quantifiers. This option is the easiest to use for code
that uses the heap heavily.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> - (default) make frugal use of heap parameters.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">4</span></code> - like <code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> but add <code class="language-dafny highlighter-rouge"><span class="kr">allocated</span></code> antecedents when ranges dont imply
allocatedness.</p>
      </li>
    </ul>

    <p>Warning: this option should be chosen consistently across an entire
project; it would be unsound to use different defaults for different
files or modules within a project. Furthermore, modes <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="kr">allocated</span><span class="o">:</span><span class="mi">0</span></code> and
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="kr">allocated</span><span class="o">:</span><span class="mi">1</span></code> let functions depend on the allocation state, which is
not sound in general.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">noAutoReq</span></code> - ignore <code class="language-dafny highlighter-rouge"><span class="n">autoReq</span></code> attributes, and therefore do not
automatically generate <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">autoReqPrint</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> - print the requires clauses that were
automatically generated by <code class="language-dafny highlighter-rouge"><span class="n">autoReq</span></code> to the given <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span></code>.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">arith</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - control how arithmetic is modeled during verification.
This is an experimental switch, and its options may change. The value
of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - use Boogie/Z3 built-ins for all arithmetic operations.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> (default) - like <code class="language-dafny highlighter-rouge"><span class="mi">0</span></code>, but introduce symbolic synonyms for <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>,
<code class="language-dafny highlighter-rouge"><span class="o">/</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">%</span></code>, and allow these operators to be used in triggers.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">2</span></code> - like <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code>, but also introduce symbolic synonyms for <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> and
<code class="language-dafny highlighter-rouge"><span class="o">-</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> - turn off non-linear arithmetic in the SMT solver. Still use
Boogie/Z3 built-in symbols for all arithmetic operations.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">4</span></code> - like <code class="language-dafny highlighter-rouge"><span class="mi">3</span></code>, but introduce symbolic synonyms for <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>, <code class="language-dafny highlighter-rouge"><span class="o">/</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">%</span></code>,
and allow these operators to be used in triggers.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">5</span></code> - like <code class="language-dafny highlighter-rouge"><span class="mi">4</span></code>, but also introduce symbolic synonyms for <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> and
<code class="language-dafny highlighter-rouge"><span class="o">-</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">6</span></code> - like <code class="language-dafny highlighter-rouge"><span class="mi">5</span></code>, and introduce axioms that distribute <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> over <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">7</span></code> - like <code class="language-dafny highlighter-rouge"><span class="mi">6</span></code>, and introduce facts about the associativity of
literal arguments over <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">8</span></code> - like <code class="language-dafny highlighter-rouge"><span class="mi">7</span></code>, and introduce axioms for the connection between <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>,
<code class="language-dafny highlighter-rouge"><span class="o">/</span></code>, and <code class="language-dafny highlighter-rouge"><span class="o">%</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">9</span></code> - like <code class="language-dafny highlighter-rouge"><span class="mi">8</span></code>, and introduce axioms for sign of multiplication.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">10</span></code> - like <code class="language-dafny highlighter-rouge"><span class="mi">9</span></code>, and introduce axioms for commutativity and
associativity of <code class="language-dafny highlighter-rouge"><span class="o">*</span></code>.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">autoTriggers</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - control automatic generation of <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span><span class="p">}</span></code>
annotations. See <a href="#sec-trigger">triggers</a>. The value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one
of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - do not generate <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span><span class="p">}</span></code> annotations for user-level
quantifiers.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> (default) - add a <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span><span class="p">}</span></code> annotation to each user-level
quantifier. Existing annotations are preserved.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">rewriteFocalPredicates</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - control rewriting of predicates in the
body of prefix lemmas. See <a href="#sec-nicer-proofs-of-extremes">the section about nicer extreme proofs</a>.
The value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - dont rewrite predicates in the body of prefix lemmas.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> (default) - in the body of prefix lemmas, rewrite any use of a
focal predicate <code class="language-dafny highlighter-rouge"><span class="n">P</span></code> to <code class="language-dafny highlighter-rouge"><span class="n">P</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></code>.</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="sec-controlling-compilation">13.9.8. Controlling compilation</h4>

<p>These options control what code gets compiled, what target language is
used, how compilation proceeds, and whether the compiled program is
immediately executed.</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">target</span><span class="o">:&lt;</span><span class="n">s</span><span class="o">&gt;</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">t</span><span class="o">:&lt;</span><span class="n">s</span><span class="o">&gt;</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">compileTarget</span><span class="o">:&lt;</span><span class="n">s</span><span class="o">&gt;</span></code>) - set the target programming language for the
compiler. The value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">s</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">cs</span></code> - C# . Produces a .dll file that can be run using <code class="language-dafny highlighter-rouge"><span class="n">dotnet</span></code>.
 For example, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">Hello</span><span class="o">.</span><span class="n">dfy</span></code> will produce <code class="language-dafny highlighter-rouge"><span class="n">Hello</span><span class="o">.</span><span class="n">dll</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Hello</span><span class="o">.</span><span class="n">runtimeconfig</span><span class="o">.</span><span class="n">json</span></code>.
 The dll can be run using <code class="language-dafny highlighter-rouge"><span class="n">dotnet</span> <span class="n">Hello</span><span class="o">.</span><span class="n">dll</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">go</span></code> - Go. The default output of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">Hello</span><span class="o">.</span><span class="n">dfy</span> <span class="o">-</span><span class="n">compileTarget</span><span class="o">:</span><span class="n">go</span></code> is
 in the <code class="language-dafny highlighter-rouge"><span class="n">Hello</span><span class="o">-</span><span class="n">go</span></code> folder. It is run using
 <code class="language-dafny highlighter-rouge"><span class="n">GOPATH</span><span class="o">=</span><span class="p">`</span><span class="n">pwd</span><span class="p">`</span><span class="o">/</span><span class="n">Hello</span><span class="o">-</span><span class="n">go</span><span class="o">/</span> <span class="n">GO111MODULE</span><span class="o">=</span><span class="n">auto</span> <span class="n">go</span> <span class="n">run</span> <span class="n">Hello</span><span class="o">-</span><span class="n">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">Hello</span><span class="o">.</span><span class="n">go</span></code></p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">js</span></code> - Javascript. The default output of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">Hello</span><span class="o">.</span><span class="n">dfy</span> <span class="o">-</span><span class="n">compileTarget</span><span class="o">:</span><span class="n">js</span></code> is
 the file <code class="language-dafny highlighter-rouge"><span class="n">Hello</span><span class="o">.</span><span class="n">js</span></code>, which can be run using <code class="language-dafny highlighter-rouge"><span class="n">node</span> <span class="n">Hello</span><span class="o">.</span><span class="n">js</span></code>. (You must have 
 <code class="language-dafny highlighter-rouge"><span class="n">bignumber</span><span class="o">.</span><span class="n">js</span></code> installed.)</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">java</span></code> - Java. The default output of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">Hello</span><span class="o">.</span><span class="n">dfy</span> <span class="o">-</span><span class="n">compileTarget</span><span class="o">:</span><span class="n">java</span></code> is
 in the <code class="language-dafny highlighter-rouge"><span class="n">Hello</span><span class="o">-</span><span class="n">java</span></code> folder. The compiled program can be run using
 <code class="language-dafny highlighter-rouge"><span class="n">java</span> <span class="o">-</span><span class="n">cp</span> <span class="n">Hello</span><span class="o">-</span><span class="n">java</span><span class="o">:</span><span class="n">Hello</span><span class="o">-</span><span class="n">java</span><span class="o">/</span><span class="n">DafnyRuntime</span><span class="o">.</span><span class="n">jar</span> <span class="n">Hello</span></code>.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">py</span></code> - Python. The default output of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">Hello</span><span class="o">.</span><span class="n">dfy</span> <span class="o">-</span><span class="n">compileTarget</span><span class="o">:</span><span class="n">py</span></code> is
 in the <code class="language-dafny highlighter-rouge"><span class="n">Hello</span><span class="o">-</span><span class="n">py</span></code> folder. The compiled program can be run using
 <code class="language-dafny highlighter-rouge"><span class="n">python</span> <span class="n">Hello</span><span class="o">-</span><span class="n">py</span><span class="o">/</span><span class="n">Hello</span><span class="o">.</span><span class="n">py</span></code>, where <code class="language-dafny highlighter-rouge"><span class="n">python</span></code> is Python version 3.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">cpp</span></code> - C++. The default output of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">Hello</span><span class="o">.</span><span class="n">dfy</span> <span class="o">-</span><span class="n">compileTarget</span><span class="o">:</span><span class="n">cpp</span></code> is
 <code class="language-dafny highlighter-rouge"><span class="n">Hello</span><span class="o">.</span><span class="n">exe</span></code> and other files written to the current folder. The compiled
 program can be run using <code class="language-dafny highlighter-rouge"><span class="o">./</span><span class="n">Hello</span><span class="o">.</span><span class="n">exe</span></code>.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">input</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> - designates files to be include in the compilation in addition to the main file in
<code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code>; these may be non-.dfy files; this option may be specified more than once</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">output</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> or <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">o</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">out</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code>) - set the name to use for compiled code files.</p>
  </li>
</ul>

<p>By default, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> reuses the name of the Dafny file being compiled.
Compilers that generate a single file use the file name as-is (e.g. the
C# backend will generate <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;.</span><span class="n">dll</span></code> and optionally <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;.</span><span class="n">cs</span></code> with
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">spillTargetCode</span></code>). Compilers that generate multiple files use the file
name as a directory name (e.g. the Java backend will generate files in
directory <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;-</span><span class="n">java</span><span class="o">/</span></code>). Any file extension is ignored, so
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">out</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> is the same as <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">out</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;.&lt;</span><span class="n">ext</span><span class="o">&gt;</span></code> if <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> contains no
periods.</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="kr">include</span><span class="o">-</span><span class="n">runtime</span></code> - include the runtime library for the target language in
the generated artifacts. This is true by default for build and run, 
but false by default for translate. The legacy option <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">useRuntimeLib</span></code> had the 
opposite effect: when enabled, the compiled assembly referred to
the pre-built <code class="language-dafny highlighter-rouge"><span class="n">DafnyRuntime</span><span class="o">.</span><span class="n">dll</span></code> in the
compiled assembly rather than including <code class="language-dafny highlighter-rouge"><span class="n">DafnyRuntime</span><span class="o">.</span><span class="n">cs</span></code> in the build
process.</li>
</ul>

<p>Legacy options:</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">compile</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> -  [obsolete - use <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">build</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">run</span></code>] control whether compilation 
 happens. The value of
<code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following. Note that if the program is 
 compiled, it will be compiled to the target language determined by
 the <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">compileTarget</span></code> option, which is C# by default.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - do not compile the program</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> (default) - upon successful verification, compile the program
to the target language.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">2</span></code> - always compile, regardless of verification success.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> - if verification is successful, compile the program (like
option <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code>), and then if there is a <code class="language-dafny highlighter-rouge"><span class="n">Main</span></code> method, attempt to run the
program.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">4</span></code> - always compile (like option <code class="language-dafny highlighter-rouge"><span class="mi">2</span></code>), and then if there is a
<code class="language-dafny highlighter-rouge"><span class="n">Main</span></code> method, attempt to run the program.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">spillTargetCode</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - [obsolete - use <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="n">translate</span></code>) control whether to write out compiled code in
the target language (instead of just holding it in internal temporary
memory). The value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> (default) - dont make any extra effort to write the textual
target program (but still compile it, if <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">compile</span></code> indicates to do
so).</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> - write it out to the target language, if it is being compiled.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">2</span></code> - write the compiled program if it passes verification,
regardless of the <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">compile</span></code> setting.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">3</span></code> - write the compiled program regardless of verification success
and the <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">compile</span></code> setting.</p>
      </li>
    </ul>
  </li>
</ul>

<p>Note that some compiler targets may (always or in some situations) write
out the textual target program as part of compilation, in which case
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">spillTargetCode</span><span class="o">:</span><span class="mi">0</span></code> behaves the same way as <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">spillTargetCode</span><span class="o">:</span><span class="mi">1</span></code>.</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">Main</span><span class="o">:&lt;</span><span class="n">name</span><span class="o">&gt;</span></code> - specify the (fully-qualified) name of the method to
use as the executable entry point. The default is the method with the
<code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">main</span><span class="p">}</span></code> attribute, or else the method named <code class="language-dafny highlighter-rouge"><span class="n">Main</span></code>.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">compileVerbose</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - control whether to write out compilation
progress information. The value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - do not print any information (silent mode)</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> (default) - print information such as the files being created by
the compiler</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">coverage</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> - emit branch-coverage calls and outputs into
<code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span></code>, including a legend that gives a description of each
source-location identifier used in the branch-coverage calls. (Use <code class="language-dafny highlighter-rouge"><span class="o">-</span></code>
as <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> to print to the console.)</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">optimize</span></code> - produce optimized C# code by passing the <code class="language-dafny highlighter-rouge"><span class="o">/</span><span class="n">optimize</span></code>
flag to the <code class="language-dafny highlighter-rouge"><span class="n">csc</span></code> executable.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">optimizeResolution</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - control optimization of method target
resolution. The value of <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> can be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">0</span></code> - resolve and translate all methods.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">1</span></code> - translate methods only in the call graph of the current
verification target.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="mi">2</span></code> (default) - as in <code class="language-dafny highlighter-rouge"><span class="mi">1</span></code>, but resolve only methods that are defined
in the current verification target file, not in included files.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">testContracts</span><span class="o">:&lt;</span><span class="n">mode</span><span class="o">&gt;</span></code> - test certain function and method contracts
at runtime. This works by generating a wrapper for each function or
method to be tested that includes a sequence of <code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statements
for each requires clause, a call to the original, and sequence of
<code class="language-dafny highlighter-rouge"><span class="kr">expect</span></code> statements for each <code class="language-dafny highlighter-rouge"><span class="kr">ensures</span></code> clause. This is particularly
useful for code marked with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> attribute and implemented
in the target language instead of Dafny. Having runtime checks of the
contracts on such code makes it possible to gather evidence that the
target-language code satisfies the assumptions made of it during Dafny
verification through mechanisms ranging from manual tests through
fuzzing to full verification. For the latter two use cases, having
checks for <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code> clauses can be helpful, even if the Dafny
calling code will never violate them.</p>

    <p>The <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">mode</span><span class="o">&gt;</span></code> parameter can currently be one of the following.</p>

    <ul>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">Externs</span></code> - insert dynamic checks when calling any function or
method marked with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> attribute, wherever the call
occurs.</p>
      </li>
      <li>
        <p><code class="language-dafny highlighter-rouge"><span class="n">TestedExterns</span></code> - insert dynamic checks when calling any function or
method marked with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span></code> attribute directly from a
function or method marked with the <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span></code> attribute.</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="sec-controlling-boogie">13.9.9. Controlling Boogie</h4>

<p>Dafny builds on top of Boogie, a general-purpose intermediate language
for verification. Options supported by Boogie on its own are also
supported by Dafny. Some of the Boogie options most relevant to Dafny
users include the following. We use the term procedure below to refer
to a Dafny function, lemma, method, or predicate, following Boogie
terminology.</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">solver</span><span class="o">-</span><span class="n">path</span></code> - specifies a custom SMT solver to use</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">solver</span><span class="o">-</span><span class="n">plugin</span></code> - specifies a plugin to use as the SMT solver, instead of an external pdafny translaterocess</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">boogie</span></code> - arguments to send to boogie</p>
  </li>
</ul>

<p>Legacy options:</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">proc</span><span class="o">:&lt;</span><span class="n">name</span><span class="o">&gt;</span></code> - verify only the procedure named <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span></code>. The name
can include <code class="language-dafny highlighter-rouge"><span class="o">*</span></code> to indicate arbitrary sequences of characters.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">trace</span></code> - print extra information during verification, including
timing, resource use, and outcome for each procedure incrementally, as
verification finishes.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">randomSeed</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - turn on randomization of the input that Boogie
passes to the SMT solver and turn on randomization in the SMT solver
itself.</p>

    <p>Certain Boogie inputs cause proof variability in the sense that changes to the
input that preserve its meaning may cause the output to change. The
<code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">randomSeed</span></code> option simulates meaning-preserving changes to the
input without requiring the user to actually make those changes.</p>

    <p>The <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">randomSeed</span></code> option is implemented by renaming variables and
reordering declarations in the input, and by setting
solver options that have similar effects.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">randomSeedIterations</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - attempt to prove each VC <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> times
with <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> random seeds. If <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">randomSeed</span></code> has been provided, each
proof attempt will use a new random seed derived from this original
seed. If not, it will implicitly use <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">randomSeed</span><span class="o">:</span><span class="mi">0</span></code> to ensure a
difference between iterations. This option can be very useful for
identifying input programs for which verification is highly variable. If the
verification times or solver resource counts associated with each
proof attempt vary widely for a given procedure, small changes to that
procedure might be more likely to cause proofs to fail in the future.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">vcsSplitOnEveryAssert</span></code> - prove each (explicit or implicit) assertion
in each procedure separately. See also the attribute
<a href="#sec-isolate_assertions"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">isolate_assertions</span><span class="p">}</span></code></a> for
restricting this option on specific procedures. By default, Boogie
attempts to prove that every assertion in a given procedure holds all
at once, in a single query to an SMT solver. This usually performs
well, but sometimes causes the solver to take longer. If a proof that
you believe should succeed is timing out, using this option can
sometimes help.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">timeLimit</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - spend at most <code class="language-dafny highlighter-rouge"><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> seconds attempting to prove any
single SMT query. This setting can also be set per method using the
attribute <a href="#sec-time-limit"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">timeLimit</span> <span class="n">n</span><span class="p">}</span></code></a>.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">rlimit</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - set the maximum solver resource count to use while
proving a single SMT query. This can be a more deterministic approach
than setting a time limit. To choose an appropriate value, please
refer to the documentation of the attribute <a href="#sec-rlimit"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">rlimit</span><span class="p">}</span></code></a>
that can be applied per procedure.</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="kr">print</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span></code> - print the translation of the Dafny file to a Boogie file.</p>
  </li>
</ul>

<p>If you have Boogie installed locally, you can run the printed Boogie file with the following script:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">DOTNET</span><span class="o">=</span><span class="si">$(</span>which dotnet<span class="si">)</span>

<span class="nv">BOOGIE_ROOT</span><span class="o">=</span><span class="s2">"path/to/boogie/Source"</span>
<span class="nv">BOOGIE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$BOOGIE_ROOT</span><span class="s2">/BoogieDriver/bin/Debug/net8.0/BoogieDriver.dll"</span>

<span class="k">if</span> <span class="o">[[</span> <span class="o">!</span> <span class="nt">-x</span> <span class="s2">"</span><span class="nv">$DOTNET</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Error: Dafny requires .NET Core to run on non-Windows systems."</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c">#Uncomment if you prefer to use the executable instead of the DLL</span>
<span class="c">#BOOGIE=$(which boogie)</span>

<span class="nv">BOOGIE_OPTIONS</span><span class="o">=</span><span class="s2">"/infer:j"</span>
<span class="nv">PROVER_OPTIONS</span><span class="o">=</span><span class="s2">"</span><span class="se">\</span><span class="s2">
  /proverOpt:O:auto_config=false </span><span class="se">\</span><span class="s2">
  /proverOpt:O:type_check=true </span><span class="se">\</span><span class="s2">
  /proverOpt:O:smt.case_split=3 </span><span class="se">\</span><span class="s2">
  /proverOpt:O:smt.qi.eager_threshold=100 </span><span class="se">\</span><span class="s2">
  /proverOpt:O:smt.delay_units=true </span><span class="se">\</span><span class="s2">
  /proverOpt:O:smt.arith.solver=2 </span><span class="se">\</span><span class="s2">
  "</span>

<span class="s2">"</span><span class="nv">$DOTNET</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$BOOGIE</span><span class="s2">"</span> <span class="nv">$BOOGIE_OPTIONS</span> <span class="nv">$PROVER_OPTIONS</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="c">#Uncomment if you want to use the executable instead of the DLL</span>
<span class="c">#"$BOOGIE" $BOOGIE_OPTIONS $PROVER_OPTIONS "$@"</span>
</code></pre></div></div>

<h4 id="sec-controlling-prover">13.9.10. Controlling the prover</h4>

<p>Much of controlling the prover is accomplished by controlling 
verification condition generation (<a href="#sec-controlling-verification">25.9.7</a>) or Boogie 
(<a href="#sec-controlling-boogie">Section 13.9.9</a>). 
The following options are also commonly used:</p>

<ul>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verification</span><span class="o">-</span><span class="n">error</span><span class="o">-</span><span class="n">limit</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> - limits the number of verification errors reported per procedure.
Default is 5; 0 means as many as possible; a small positive number runs faster
but a large positive number reports more errors per run</p>
  </li>
  <li>
    <p><code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">verification</span><span class="o">-</span><span class="n">time</span><span class="o">-</span><span class="n">limit</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> (was <code class="language-dafny highlighter-rouge"><span class="o">-</span><span class="n">timeLimit</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span></code>) - limits 
the number of seconds spent trying to verify each assertion batch.</p>
  </li>
</ul>

<h4 id="sec-controlling-test-gen">13.9.11. Controlling test generation</h4>

<p>Dafny is capable of generating unit (runtime) tests. It does so by asking the prover to solve
for values of inputs to a method that cause the program to execute specific blocks or paths.
A detailed description of how to do this is given in
<a href="https://github.com/dafny-lang/dafny/blob/master/Source/DafnyTestGeneration/README.md">a separate document</a>.</p>

<!--PDF NEWPAGE-->
<h2 id="sec-dafny-language-server-vscode">14. Dafny VSCode extension and the Dafny Language Server</h2>

<h3 id="141-dafny-functionality-within-vscode">14.1. Dafny functionality within VSCode</h3>

<p>There is a language server for Dafny, which <a href="https://github.com/dafny-lang/dafny/tree/master/Source/DafnyLanguageServer">implements</a> the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>.
This server is used by the Dafny VSCode Extension; it currently offers the following features:</p>
<ul>
  <li>Quick syntax highlighting</li>
  <li>As-you-type parsing, resolution and verification diagnostics</li>
  <li>Support for <a href="https://github.com/dafny-lang/dafny/tree/master/Source/DafnyLanguageServer#plugins">Dafny plugins</a></li>
  <li>Expanded explanations (in addition to the error message) for selected errors (and more being added), shown by hovering</li>
  <li>Quick fixes for selected errors (and more being added)</li>
  <li>Limited support for symbol completion</li>
  <li>Limited support for code navigation</li>
  <li>Counter-example display</li>
  <li>Highlighting of ghost statements</li>
  <li>Gutter highlights</li>
  <li>A variety of Preference settings</li>
</ul>

<p>Most of the Dafny functionality is simply there when editing a .dfy file with VSCode that has the Dafny extension installed.
Some actions are available through added menu items.
The Dafny functionality within VSCode can be found in these locations:</p>

<ul>
  <li>The preferences are under the menu Code-&gt;Preferences-&gt;Settings-&gt;Dafny extension configuration. There are two sections of settings.</li>
  <li>A hover over an error location will bring up a hover popup, which will show expanded error information and any quick fix options that are available.</li>
  <li>Within a .dfy editor, a right-click brings up a context menu, which has a menu item Dafny. Under it are actions to Build or Run a program,
to turn on or off counterexample display, find definitions, and the like.</li>
</ul>

<h3 id="sec-gutter-highlights">14.2. Gutter highlights</h3>

<p>Feedback on a program is show visually as underlining with squiggles within the text and as various markings in various colors in the <em>gutter</em> down the left side of an editor window.</p>

<p>The first time a file is loaded, the gutter will highlight in a transparent squiggly green line all the methods that need to be verified, like this:</p>

<p><img src="https://user-images.githubusercontent.com/3601079/178058374-a1e5e9ca-2c5e-493a-bb60-d00310962741.png" alt="image" /></p>

<p>When the file is saved (in verification on save), or whenever the Dafny verifier is ready (in verification on change), it will start to verify methods.
That line will turn into a thin green rectangle on methods that have been verified, and display an animated less transparent green squiggly line on methods that are being actively verified:</p>

<p><img src="https://user-images.githubusercontent.com/3601079/178058713-1266a23f-fdb4-4494-844a-488cc214c797.png" alt="image" /></p>

<p>When the verification finishes, if a method, a function, a constant with default initialization or a subset type with a witness has some verification errors in it,
the editor will display two yellow vertical rails indicating an error context.</p>

<p><img src="https://user-images.githubusercontent.com/3601079/178058908-71425938-57a4-454d-805d-2923d7c4de73.png" alt="image" /></p>

<p>Inside this context, if there is a failing assertion on a line,
it will fill the gap between the vertical yellow bars with a red rectangle, even if there might be other assertions that are verified on the line.
If there is no error on a line, but there is at least one assertion that verified, it will display a green disk with a white checkmark on it,
which can be used to check progress in a proof search.</p>

<p>As soon as a line is changed, the gutter icons turn transparent and squiggly, to indicate their obsolescence.</p>

<p><img src="https://user-images.githubusercontent.com/3601079/178063330-dd346ddf-aa60-487e-a368-3a4af572aeac.png" alt="image" /></p>

<p>The red error rectangles occupy only half the horizontal space, to visualise their possible obsolescence.</p>

<p>When the file is saved (in verification on save), or as soon as possible otherwise,
these squiggly icons will be animated while the Dafny verifier inspect the area.</p>

<p><img src="https://user-images.githubusercontent.com/3601079/178063848-d0fb02d9-c743-4ffc-9e34-c5f8731c79d1.png" alt="image" /></p>

<p>If the method was verifying before a change, instead of two yellow vertical bars with a red squiggly line,
the gutter icons display an animated squiggly but more firm green line, thereby indicating that the method used to verify,
but Dafny is still re-verifying it.</p>

<p><img src="https://user-images.githubusercontent.com/3601079/178068281-f15fa83f-6180-4de1-ab63-b65957f6c86b.png" alt="image" /></p>

<p>If there is a parse or resolution error, the previous gutter icons turn gray and a red triangle indicates 
the position of the parse or resolution error.</p>

<p><img src="https://user-images.githubusercontent.com/3601079/178068650-24c14da1-d247-4027-b784-2eb055242e6b.png" alt="image" /></p>

<h3 id="sec-old-dafny-server">14.3. The Dafny Server</h3>

<p>Before Dafny <a href="https://github.com/dafny-lang/dafny/tree/master/Source/DafnyLanguageServer">implemented</a> the official <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>, it implemented its own protocol for <a href="https://github.com/boogie-org/boogie-friends">Emacs</a>, which resulted in a project called <a href="https://github.com/dafny-lang/dafny/tree/master/Source/DafnyServer">DafnyServer</a>. While the latest Dafny releases still contain a working DafnyServer binary, this component has been feature frozen since 2022, and it may not support features that were added to Dafny after that time. We do not recommend using it.</p>

<p>The Dafny Server has <a href="https://github.com/dafny-lang/dafny/tree/master/Test/server">integration tests</a> that serve as the basis of the documentation.</p>

<p>The server is essentially a REPL, which produces output in the same format as the Dafny CLI; clients thus
do not need to understand the internals of Dafnys caching.  A typical editing session proceeds as follows:</p>

<ul>
  <li>When a new Dafny file is opened, the editor starts a new instance of the
Dafny server.  The cache is blank at that point.</li>
  <li>The editor sends a copy of the buffer for initial verification.  This takes
some time, after which the server returns a list of errors.</li>
  <li>The user makes modifications; the editor periodically sends a new copy of
the buffers contents to the Dafny server, which quickly returns an updated
list of errors.</li>
</ul>

<p>The client-server protocol is sequential, uses JSON, and works over ASCII
pipes by base64-encoding utf-8 queries.  It defines one type of query, and two
types of responses:</p>

<p>Queries are of the following form:</p>

<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="n">verify</span>
 <span class="o">&lt;</span><span class="n">base64</span> <span class="n">encoded</span> <span class="n">JSON</span> <span class="n">payload</span><span class="o">&gt;</span>
 <span class="p">[[</span><span class="n">DAFNY</span><span class="o">-</span><span class="n">CLIENT</span><span class="o">:</span> <span class="n">EOM</span><span class="p">]]</span>
</code></pre></div></div>

<p>Responses are of the following form:</p>

<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="o">&lt;</span><span class="n">list</span> <span class="n">of</span> <span class="n">errors</span> <span class="n">and</span> <span class="n">usual</span> <span class="n">output</span><span class="p">,</span> <span class="ow">as</span> <span class="n">produced</span> <span class="kr">by</span> <span class="n">the</span> <span class="n">Dafny</span> <span class="n">CLI</span><span class="o">&gt;</span>
 <span class="p">[</span><span class="n">SUCCESS</span><span class="p">]</span> <span class="p">[[</span><span class="n">DAFNY</span><span class="o">-</span><span class="n">SERVER</span><span class="o">:</span> <span class="n">EOM</span><span class="p">]]</span>
</code></pre></div></div>

<p>or</p>

<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code> <span class="o">&lt;</span><span class="n">error</span> <span class="n">message</span><span class="o">&gt;</span>
 <span class="p">[</span><span class="n">FAILURE</span><span class="p">]</span> <span class="p">[[</span><span class="n">DAFNY</span><span class="o">-</span><span class="n">SERVER</span><span class="o">:</span> <span class="n">EOM</span><span class="p">]]</span>
</code></pre></div></div>

<p>The JSON payload is an utf-8 encoded string resulting of the serialization of
a dictionary with 4 fields:</p>
<ul>
  <li>args:   An array of Dafny arguments, as passed to the Dafny CLI</li>
  <li>source: A Dafny program, or the path to a Dafny source file.</li>
  <li>sourceIsFile: A boolean indicating whether the source argument is a
              Dafny program or the path to one.</li>
  <li>filename:     The name of the original source file, to be used in error
              messages</li>
</ul>

<p>For small files, embedding the Dafny source directly into a message is
convenient; for larger files, however, it is generally better for performance
to write the source snapshot to a separate file, and to pass that to Dafny
by setting the sourceIsFile flag to true.</p>

<p>For example, if you compile and run <code class="language-dafny highlighter-rouge"><span class="n">DafnyServer</span><span class="o">.</span><span class="n">exe</span></code>, you could paste the following command:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">verify</span>
<span class="n">eyJhcmdzIjpbIi9jb21waWxlOjAiLCIvcHJpbnRUb29sdGlwcyIsIi90aW1lTGltaXQ6MjAiXSwi</span>
<span class="n">ZmlsZW5hbWUiOiJ0cmFuc2NyaXB0Iiwic291cmNlIjoibWV0aG9kIEEoYTppbnQpIHJldHVybnMg</span>
<span class="n">KGI6IGludCkge1xuICBiIDo9IGE7XG4gIGFzc2VydCBmYWxzZTtcbn1cbiIsInNvdXJjZUlzRmls</span>
<span class="n">ZSI6ZmFsc2V9</span>
<span class="p">[[</span><span class="n">DAFNY</span><span class="o">-</span><span class="n">CLIENT</span><span class="o">:</span> <span class="n">EOM</span><span class="p">]]</span>
</code></pre></div></div>

<p>The interpreter sees the command <code class="language-dafny highlighter-rouge"><span class="n">verify</span></code>, and then starts reading every line until it sees <code class="language-dafny highlighter-rouge"><span class="p">[[</span><span class="n">DAFNY</span><span class="o">-</span><span class="n">CLIENT</span><span class="o">:</span> <span class="n">EOM</span><span class="p">]]</span></code>
The payload is a base64 encoded string that you could encode or decode using JavaScripts <code class="language-dafny highlighter-rouge"><span class="n">atob</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">btoa</span></code> function.
For example, the payload above was generated using the following code:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nf">btoa</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">({</span>
  <span class="dl">"</span><span class="s2">args</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
    <span class="dl">"</span><span class="s2">/compile:0</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/printTooltips</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">/timeLimit:20</span><span class="dl">"</span>
   <span class="p">],</span>
   <span class="dl">"</span><span class="s2">filename</span><span class="dl">"</span><span class="p">:</span><span class="dl">"</span><span class="s2">transcript</span><span class="dl">"</span><span class="p">,</span>
   <span class="dl">"</span><span class="s2">source</span><span class="dl">"</span><span class="p">:</span>
<span class="s2">`method A(a:int) returns (b: int) {
   b := a;
   assert false;
}
`</span><span class="p">,</span><span class="dl">"</span><span class="s2">sourceIsFile</span><span class="dl">"</span><span class="p">:</span> <span class="kc">false</span><span class="p">}))</span>
<span class="o">===</span> <span class="dl">"</span><span class="s2">eyJhcmdzIjpbIi9jb21waWxlOjAiLCIvcHJpbnRUb29sdGlwcyIsIi90aW1lTGltaXQ6MjAiXSwiZmlsZW5hbWUiOiJ0cmFuc2NyaXB0Iiwic291cmNlIjoibWV0aG9kIEEoYTppbnQpIHJldHVybnMgKGI6IGludCkge1xuICBiIDo9IGE7XG4gIGFzc2VydCBmYWxzZTtcbn1cbiIsInNvdXJjZUlzRmlsZSI6ZmFsc2V9</span><span class="dl">"</span>
</code></pre></div></div>

<p>Thus to decode such output, youd manually use <code class="language-dafny highlighter-rouge"><span class="n">JSON</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">atob</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span></code>.</p>

<!--PDF NEWPAGE-->
<h2 id="sec-plugins">15. Plugins to Dafny</h2>

<p>Dafny has a plugin architecture that permits users to build tools for the Dafny language without having to replicate 
parsing and name/type resolution of Dafny programs. Such a tool might just do some analysis on the Dafny program,
without concern for verifying or compiling the program. Or it might modify the program (actually, modify the programs AST) 
and then continue on with verification and compilation with the core Dafny tool. A user plugin might also be used
in the Language Server and thereby be available in the VSCode (or other) IDE.</p>

<p><em><strong>This is an experimental aspect of Dafny.</strong>
The plugin API directly exposes the Dafny AST, which is constantly evolving.
Hence, always recompile your plugin against the binary of Dafny that will be importing your plugin.</em></p>

<p>Plugins are libraries linked to a <code class="language-dafny highlighter-rouge"><span class="n">Dafny</span><span class="o">.</span><span class="n">dll</span></code> of the same version as the Language Server.
A plugin typically defines:</p>

<ul>
  <li>Zero or one class extending <code class="language-dafny highlighter-rouge"><span class="n">Microsoft</span><span class="o">.</span><span class="n">Dafny</span><span class="o">.</span><span class="n">Plugins</span><span class="o">.</span><span class="n">PluginConfiguration</span></code>, which receives plugins arguments in its method <code class="language-dafny highlighter-rouge"><span class="n">ParseArguments</span></code>, and
    <ol>
      <li>Can return a list of <code class="language-dafny highlighter-rouge"><span class="n">Microsoft</span><span class="o">.</span><span class="n">Dafny</span><span class="o">.</span><span class="n">Plugins</span><span class="o">.</span><span class="n">Rewriter</span></code>s when its method <code class="language-dafny highlighter-rouge"><span class="n">GetRewriters</span><span class="p">()</span></code> is called by Dafny,</li>
      <li>Can return a list of <code class="language-dafny highlighter-rouge"><span class="n">Microsoft</span><span class="o">.</span><span class="n">Dafny</span><span class="o">.</span><span class="n">Plugins</span><span class="o">.</span><span class="n">Compiler</span></code>s when its method <code class="language-dafny highlighter-rouge"><span class="n">GetCompilers</span><span class="p">()</span></code> is called by Dafny,</li>
      <li>If the configuration extends the subclass <code class="language-dafny highlighter-rouge"><span class="n">Microsoft</span><span class="o">.</span><span class="n">Dafny</span><span class="o">.</span><span class="n">LanguageServer</span><span class="o">.</span><span class="n">Plugins</span><span class="o">.</span><span class="n">PluginConfiguration</span></code>:
        <ol>
          <li>Can return a list of <code class="language-dafny highlighter-rouge"><span class="n">Microsoft</span><span class="o">.</span><span class="n">Dafny</span><span class="o">.</span><span class="n">LanguageServer</span><span class="o">.</span><span class="n">Plugins</span><span class="o">.</span><span class="n">DafnyCodeActionProvider</span></code>s when its method <code class="language-dafny highlighter-rouge"><span class="n">GetDafnyCodeActionProviders</span><span class="p">()</span></code> is called by the Dafny Language Server.</li>
          <li>Can return a modified version of <code class="language-dafny highlighter-rouge"><span class="n">OmniSharp</span><span class="o">.</span><span class="n">Extensions</span><span class="o">.</span><span class="n">LanguageServer</span><span class="o">.</span><span class="n">Server</span><span class="o">.</span><span class="n">LanguageServerOptions</span></code> when its method <code class="language-dafny highlighter-rouge"><span class="n">WithPluginHandlers</span><span class="p">()</span></code> is called by the Dafny Language Server.</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Zero or more classes extending <code class="language-dafny highlighter-rouge"><span class="n">Microsoft</span><span class="o">.</span><span class="n">Dafny</span><span class="o">.</span><span class="n">Plugins</span><span class="o">.</span><span class="n">Rewriter</span></code>.
If a configuration class is provided, it is responsible for instantiating them and returning them in <code class="language-dafny highlighter-rouge"><span class="n">GetRewriters</span><span class="p">()</span></code>.
If no configuration class is provided, an automatic configuration will load every defined <code class="language-dafny highlighter-rouge"><span class="n">Rewriter</span></code> automatically.</li>
  <li>Zero or more classes extending <code class="language-dafny highlighter-rouge"><span class="n">Microsoft</span><span class="o">.</span><span class="n">Dafny</span><span class="o">.</span><span class="n">Plugins</span><span class="o">.</span><span class="n">Compiler</span></code>.
If a configuration class is provided, it is responsible for instantiating them and returning them in <code class="language-dafny highlighter-rouge"><span class="n">GetCompilers</span><span class="p">()</span></code>.
If no configuration class is provided, an automatic configuration will load every defined <code class="language-dafny highlighter-rouge"><span class="n">Compiler</span></code> automatically.</li>
  <li>Zero or more classes extending <code class="language-dafny highlighter-rouge"><span class="n">Microsoft</span><span class="o">.</span><span class="n">Dafny</span><span class="o">.</span><span class="n">LanguageServer</span><span class="o">.</span><span class="n">Plugins</span><span class="o">.</span><span class="n">DafnyCodeActionProvider</span></code>.
Only a configuration class of type <code class="language-dafny highlighter-rouge"><span class="n">Microsoft</span><span class="o">.</span><span class="n">Dafny</span><span class="o">.</span><span class="n">LanguageServer</span><span class="o">.</span><span class="n">Plugins</span><span class="o">.</span><span class="n">PluginConfiguration</span></code> can be responsible for instantiating them and returning them in <code class="language-dafny highlighter-rouge"><span class="n">GetDafnyCodeActionProviders</span><span class="p">()</span></code>.</li>
</ul>

<p>The most important methods of the class <code class="language-dafny highlighter-rouge"><span class="n">Rewriter</span></code> that plugins override are</p>

<ul>
  <li>(experimental) <code class="language-dafny highlighter-rouge"><span class="n">PreResolve</span><span class="p">(</span><span class="n">ModuleDefinition</span><span class="p">)</span></code>: Here you can optionally modify the AST before it is resolved.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">PostResolve</span><span class="p">(</span><span class="n">ModuleDefinition</span><span class="p">)</span></code>: This method is repeatedly called with every resolved and type-checked module, before verification.
Plugins override this method typically to report additional diagnostics.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">PostResolve</span><span class="p">(</span><span class="n">Program</span><span class="p">)</span></code>: This method is called once after all <code class="language-dafny highlighter-rouge"><span class="n">PostResolve</span><span class="p">(</span><span class="n">ModuleDefinition</span><span class="p">)</span></code> have been called.</li>
</ul>

<p>Plugins are typically used to report additional diagnostics such as unsupported constructs for specific compilers (through the methods <code class="language-dafny highlighter-rouge"><span class="err"></span><span class="n">rror</span><span class="p">(</span><span class="o">...</span><span class="p">)</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">Warning</span><span class="p">(</span><span class="o">...</span><span class="p">)</span></code> of the field <code class="language-dafny highlighter-rouge"><span class="n">Reporter</span></code> of the class <code class="language-dafny highlighter-rouge"><span class="n">Rewriter</span></code>)</p>

<p>Note that all plugin errors should use the original programs expressions token and NOT <code class="language-dafny highlighter-rouge"><span class="n">Token</span><span class="o">.</span><span class="n">NoToken</span></code>, else no error will be displayed in the IDE.</p>

<h3 id="151-language-server-plugin-tutorial">15.1. Language Server plugin tutorial</h3>

<p>In this section, we will create a plugin that enhances the functionality of the Language Server.
We will start by showing the steps needed to create a plugin, followed by an example implementation that demonstrates how to provide more code actions and add custom request handlers.</p>

<h4 id="1511-create-plugin-project">15.1.1. Create plugin project</h4>

<p>Assuming the Dafny source code is installed in the folder <code class="language-dafny highlighter-rouge"><span class="n">dafny</span><span class="o">/</span></code>
start by creating an empty folder next to it, e.g. <code class="language-dafny highlighter-rouge"><span class="n">PluginTutorial</span><span class="o">/</span></code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">mkdir </span>PluginTutorial
<span class="nb">cd </span>PluginTutorial
</code></pre></div></div>

<p>Then, create a dotnet class project</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>dotnet new classlib
</code></pre></div></div>

<p>It will create a file <code class="language-dafny highlighter-rouge"><span class="n">Class1</span><span class="o">.</span><span class="n">cs</span></code> that you can rename</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">mv </span>Class1.cs MyPlugin.cs
</code></pre></div></div>

<p>Open the newly created file <code class="language-dafny highlighter-rouge"><span class="n">PluginTutorial</span><span class="o">.</span><span class="n">csproj</span></code>, and add the following after <code class="language-dafny highlighter-rouge"><span class="o">&lt;/</span><span class="n">PropertyGroup</span><span class="o">&gt;</span></code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="nt">&lt;ItemGroup&gt;</span>
    <span class="nt">&lt;ProjectReference</span> <span class="na">Include=</span><span class="s">"../dafny/source/DafnyLanguageServer/DafnyLanguageServer.csproj"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/ItemGroup&gt;</span>
</code></pre></div></div>
<h4 id="1512-implement-plugin">15.1.2. Implement plugin</h4>

<h5 id="15121-code-actions-plugin">15.1.2.1. Code actions plugin</h5>

<p>This code action plugin will add a code action that allows you to place a dummy comment in front of the first method name, only if the selection is on the line of the method.</p>

<p>Open the file <code class="language-dafny highlighter-rouge"><span class="n">MyPlugin</span><span class="o">.</span><span class="n">cs</span></code>, remove everything, and write the imports and a namespace:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">using</span> <span class="nn">Microsoft.Dafny</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Microsoft.Dafny.LanguageServer.Plugins</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Microsoft.Boogie</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Microsoft.Dafny.LanguageServer.Language</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Range</span> <span class="p">=</span> <span class="n">OmniSharp</span><span class="p">.</span><span class="n">Extensions</span><span class="p">.</span><span class="n">LanguageServer</span><span class="p">.</span><span class="n">Protocol</span><span class="p">.</span><span class="n">Models</span><span class="p">.</span><span class="n">Range</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">MyPlugin</span><span class="p">;</span>
</code></pre></div></div>

<p>After that, add a <code class="language-dafny highlighter-rouge"><span class="n">PluginConfiguration</span></code> that will expose all the quickfixers of your plugin.
This class will be discovered and instantiated automatically by Dafny.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">TestConfiguration</span> <span class="p">:</span> <span class="n">PluginConfiguration</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="n">DafnyCodeActionProvider</span><span class="p">[]</span> <span class="nf">GetDafnyCodeActionProviders</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">DafnyCodeActionProvider</span><span class="p">[]</span> <span class="p">{</span> <span class="k">new</span> <span class="nf">AddCommentDafnyCodeActionProvider</span><span class="p">()</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that you could also override the methods <code class="language-dafny highlighter-rouge"><span class="n">GetRewriters</span><span class="p">()</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">GetCompilers</span><span class="p">()</span></code> for other purposes, but this is out of scope for this tutorial.</p>

<p>Then, we need to create the quickFixer <code class="language-dafny highlighter-rouge"><span class="n">AddCommentDafnyCodeActionProvider</span></code> itself:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AddCommentDafnyCodeActionProvider</span> <span class="p">:</span> <span class="n">DafnyCodeActionProvider</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">DafnyCodeAction</span><span class="p">&gt;</span> <span class="nf">GetDafnyCodeActions</span><span class="p">(</span><span class="n">IDafnyCodeActionInput</span> <span class="n">input</span><span class="p">,</span> <span class="n">Range</span> <span class="n">selection</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">DafnyCodeAction</span><span class="p">[]</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For now, this quick fixer returns nothing. <code class="language-dafny highlighter-rouge"><span class="n">input</span></code> is the program state, and <code class="language-dafny highlighter-rouge"><span class="n">selection</span></code> is where the caret is.
We replace the return statement with a conditional that tests whether the selection is on the first line:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code>    <span class="kt">var</span> <span class="n">firstTokenRange</span> <span class="p">=</span> <span class="n">input</span><span class="p">.</span><span class="n">Program</span><span class="p">?.</span><span class="nf">GetFirstTopLevelToken</span><span class="p">()?.</span><span class="nf">GetLspRange</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">firstTokenRange</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">firstTokenRange</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">Line</span> <span class="p">==</span> <span class="n">selection</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">Line</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">DafnyCodeAction</span><span class="p">[]</span> <span class="p">{</span>
        <span class="c1">// TODO</span>
      <span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">DafnyCodeAction</span><span class="p">[]</span> <span class="p">{</span> <span class="p">};</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Every quick fix consists of a title (provided immediately), and zero or more <code class="language-dafny highlighter-rouge"><span class="n">DafnyCodeActionEdit</span></code> (computed lazily).
A <code class="language-dafny highlighter-rouge"><span class="n">DafnyCodeActionEdit</span></code> has a <code class="language-dafny highlighter-rouge"><span class="n">Range</span></code> to remove and some <code class="language-dafny highlighter-rouge"><span class="kt">string</span></code> to insert instead. All <code class="language-dafny highlighter-rouge"><span class="n">DafnyCodeActionEdit</span></code>s
of the same <code class="language-dafny highlighter-rouge"><span class="n">DafnyCodeAction</span></code> are applied at the same time if selected.</p>

<p>To create a <code class="language-dafny highlighter-rouge"><span class="n">DafnyCodeAction</span></code>, we can either use the easy-to-use <code class="language-dafny highlighter-rouge"><span class="n">InstantDafnyCodeAction</span></code>, which accepts a title and an array of edits:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="k">return</span> <span class="k">new</span> <span class="n">DafnyCodeAction</span><span class="p">[]</span> <span class="p">{</span>
    <span class="k">new</span> <span class="nf">InstantDafnyCodeAction</span><span class="p">(</span><span class="s">"Insert comment"</span><span class="p">,</span> <span class="k">new</span> <span class="n">DafnyCodeActionEdit</span><span class="p">[]</span> <span class="p">{</span>
      <span class="k">new</span> <span class="nf">DafnyCodeActionEdit</span><span class="p">(</span><span class="n">firstTokenRange</span><span class="p">.</span><span class="nf">GetStartRange</span><span class="p">(),</span> <span class="s">"/*First comment*/"</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">};</span>
</code></pre></div></div>

<p>or we can implement our custom inherited class of <code class="language-dafny highlighter-rouge"><span class="n">DafnyCodeAction</span></code>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">CustomDafnyCodeAction</span><span class="p">:</span> <span class="n">DafnyCodeAction</span> <span class="p">{</span>
  <span class="k">public</span> <span class="n">Range</span> <span class="n">whereToInsert</span><span class="p">;</span>
  
  <span class="k">public</span> <span class="nf">CustomDafnyCodeAction</span><span class="p">(</span><span class="n">Range</span> <span class="n">whereToInsert</span><span class="p">):</span> <span class="k">base</span><span class="p">(</span><span class="s">"Insert comment"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">whereToInsert</span> <span class="p">=</span> <span class="n">whereToInsert</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">public</span> <span class="k">override</span> <span class="n">DafnyCodeActionEdit</span><span class="p">[]</span> <span class="nf">GetEdits</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">DafnyCodeActionEdit</span><span class="p">[]</span> <span class="p">{</span>
      <span class="k">new</span> <span class="nf">DafnyCodeActionEdit</span><span class="p">(</span><span class="n">whereToInsert</span><span class="p">.</span><span class="nf">GetStartRange</span><span class="p">(),</span> <span class="s">"/*A comment*/"</span><span class="p">)</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In that case, we could return:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code>  <span class="k">return</span> <span class="k">new</span> <span class="n">DafnyCodeAction</span><span class="p">[]</span> <span class="p">{</span>
    <span class="k">new</span> <span class="nf">CustomDafnyCodeAction</span><span class="p">(</span><span class="n">firstTokenRange</span><span class="p">)</span>
  <span class="p">};</span>
</code></pre></div></div>

<h5 id="15122-request-handler-plugin">15.1.2.2. Request handler plugin</h5>

<p>This request handler plugin enhances the Language Server to support a request with a <code class="language-dafny highlighter-rouge"><span class="n">TextDocumentIdentifier</span></code> as parameter, which will return a <code class="language-dafny highlighter-rouge"><span class="kt">bool</span></code> value denoting whether the provided <code class="language-dafny highlighter-rouge"><span class="n">DocumentUri</span></code> has any <code class="language-dafny highlighter-rouge"><span class="n">LoopStmt</span></code>s in it.</p>

<p>Open the file <code class="language-dafny highlighter-rouge"><span class="n">MyPlugin</span><span class="o">.</span><span class="n">cs</span></code>, remove everything, and write the imports and a namespace:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">using</span> <span class="nn">OmniSharp.Extensions.JsonRpc</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">OmniSharp.Extensions.LanguageServer.Server</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">OmniSharp.Extensions.LanguageServer.Protocol.Models</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Microsoft.Dafny.LanguageServer.Plugins</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Microsoft.Dafny.LanguageServer.Workspace</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">MediatR</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Microsoft.Dafny</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">MyPlugin</span><span class="p">;</span>
</code></pre></div></div>

<p>After that, add a <code class="language-dafny highlighter-rouge"><span class="n">PluginConfiguration</span></code> that will add all the request handlers of your plugin.
This class will be discovered and instantiated automatically by Dafny.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">TestConfiguration</span> <span class="p">:</span> <span class="n">PluginConfiguration</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="n">LanguageServerOptions</span> <span class="nf">WithPluginHandlers</span><span class="p">(</span><span class="n">LanguageServerOptions</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">options</span><span class="p">.</span><span class="n">WithHandler</span><span class="p">&lt;</span><span class="n">DummyHandler</span><span class="p">&gt;();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, we need to create the request handler <code class="language-dafny highlighter-rouge"><span class="n">DummyHandler</span></code> itself:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">[</span><span class="n">Parallel</span><span class="p">]</span>
<span class="p">[</span><span class="nf">Method</span><span class="p">(</span><span class="s">"dafny/request/dummy"</span><span class="p">,</span> <span class="n">Direction</span><span class="p">.</span><span class="n">ClientToServer</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">record</span> <span class="nc">DummyParams</span> <span class="p">:</span> <span class="n">TextDocumentIdentifier</span><span class="p">,</span> <span class="n">IRequest</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">DummyHandler</span> <span class="p">:</span> <span class="n">IJsonRpcRequestHandler</span><span class="p">&lt;</span><span class="n">DummyParams</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IProjectDatabase</span> <span class="n">projects</span><span class="p">;</span>
  <span class="k">public</span> <span class="nf">DummyHandler</span><span class="p">(</span><span class="n">IProjectDatabase</span> <span class="n">projects</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">projects</span> <span class="p">=</span> <span class="n">projects</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">DummyParams</span> <span class="n">request</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">state</span> <span class="p">=</span> <span class="k">await</span> <span class="n">projects</span><span class="p">.</span><span class="nf">GetParsedDocumentNormalizeUri</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">state</span><span class="p">.</span><span class="n">Program</span><span class="p">.</span><span class="nf">Descendants</span><span class="p">().</span><span class="n">OfType</span><span class="p">&lt;</span><span class="n">LoopStmt</span><span class="p">&gt;().</span><span class="nf">Any</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For more advanced example implementations of request handlers, look at <code class="language-dafny highlighter-rouge"><span class="n">dafny</span><span class="o">/</span><span class="n">Source</span><span class="o">/</span><span class="n">DafnyLanguageServer</span><span class="o">/</span><span class="n">Handlers</span><span class="cm">/*</span></code>.</p>

<h4 id="1513-building-plugin">15.1.3. Building plugin</h4>

<p>Thats it! Now, build your library while inside your folder:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="o">&gt;</span> dotnet build
</code></pre></div></div>

<p>This will create the file <code class="language-dafny highlighter-rouge"><span class="n">PluginTutorial</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">Debug</span><span class="o">/</span><span class="n">net8</span><span class="o">.</span><span class="mi">0</span><span class="o">/</span><span class="n">PluginTutorial</span><span class="o">.</span><span class="n">dll</span></code>.
Now, open VSCode, open Dafny settings, and enter the absolute path to this DLL in the plugins section.
Restart VSCode, and it should work!</p>

<!--PDF NEWPAGE-->
<h2 id="16-full-list-of-legacy-command-line-options-sec-full-command-line-options-">16. Full list of legacy command-line options {#sec-full-command-line-options} <!-- PDFOMIT --></h2>
<p>For the on-line version only, the output of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span> <span class="o">-</span><span class="n">?</span></code> follows. Note that with the advent of <a href="#sec-dafny-commands">dafny commands</a>, many options are only applicable to some (if any) commands, some are renamed, and some are obsolete and will eventually be removed. <!--PDFOMIT--></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">Use</span> <span class="err">'dafny --help'</span> <span class="kr">to</span> <span class="n">see</span> <span class="n">help</span> <span class="kr">for</span> <span class="n">the</span> <span class="kr">new</span> <span class="n">Dafny</span> <span class="n">CLI</span> <span class="n">format</span><span class="o">.</span>
<span class="n">Usage</span><span class="o">:</span> <span class="n">dafny</span> <span class="p">[</span> <span class="n">option</span> <span class="o">...</span> <span class="p">]</span> <span class="p">[</span> <span class="n">filename</span> <span class="o">...</span> <span class="p">]</span>

  <span class="o">----</span> <span class="n">General</span> <span class="n">options</span> <span class="o">-------------------------------------------------------</span>

  <span class="o">/</span><span class="n">version</span>      <span class="kr">print</span> <span class="n">the</span> <span class="n">dafny</span> <span class="n">version</span> <span class="n">number</span>
  <span class="o">/</span><span class="n">help</span>         <span class="kr">print</span> <span class="kr">this</span> <span class="n">message</span>
  <span class="o">/</span><span class="n">attrHelp</span>     <span class="kr">print</span> <span class="n">a</span> <span class="n">message</span> <span class="n">about</span> <span class="n">supported</span> <span class="n">declaration</span> <span class="n">attributes</span>
  <span class="o">/</span><span class="n">env</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>      <span class="kr">print</span> <span class="n">command</span> <span class="n">line</span> <span class="n">arguments</span>
                  <span class="mi">0</span> <span class="o">-</span> <span class="n">never</span><span class="p">,</span> <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">during</span> <span class="n">BPL</span> <span class="kr">print</span> <span class="n">and</span> <span class="n">prover</span> <span class="n">log</span><span class="p">,</span>
                  <span class="mi">2</span> <span class="o">-</span> <span class="n">like</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">also</span> <span class="kr">to</span> <span class="n">standard</span> <span class="n">output</span>
  <span class="o">/</span><span class="n">printVerifiedProceduresCount</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="n">no</span>
                <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">yes</span>
  <span class="o">/</span><span class="n">wait</span>         <span class="n">await</span> <span class="n">Enter</span> <span class="n">from</span> <span class="n">keyboard</span> <span class="n">before</span> <span class="n">terminating</span> <span class="n">program</span>
  <span class="o">/</span><span class="n">xml</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>   <span class="n">also</span> <span class="n">produce</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">XML</span> <span class="n">format</span> <span class="kr">to</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span>

  <span class="n">All</span> <span class="n">the</span> <span class="o">.</span><span class="n">dfy</span> <span class="n">files</span> <span class="n">supplied</span> <span class="n">on</span> <span class="n">the</span> <span class="n">command</span> <span class="n">line</span> <span class="n">along</span> <span class="n">with</span> <span class="n">files</span> <span class="n">recursively</span>
  <span class="n">included</span> <span class="kr">by</span> <span class="err">'include'</span> <span class="n">directives</span> <span class="n">are</span> <span class="n">considered</span> <span class="n">a</span> <span class="n">single</span> <span class="n">Dafny</span> <span class="n">program</span><span class="p">;</span>
  <span class="n">however</span> <span class="n">only</span> <span class="n">those</span> <span class="n">files</span> <span class="n">listed</span> <span class="n">on</span> <span class="n">the</span> <span class="n">command</span> <span class="n">line</span> <span class="n">are</span> <span class="n">verified</span><span class="o">.</span>
  
  <span class="n">Exit</span> <span class="n">code</span><span class="o">:</span> <span class="mi">0</span> <span class="o">--</span> <span class="n">success</span><span class="p">;</span> <span class="mi">1</span> <span class="o">--</span> <span class="n">invalid</span> <span class="n">command</span><span class="o">-</span><span class="n">line</span><span class="p">;</span> <span class="mi">2</span> <span class="o">--</span> <span class="n">parse</span> <span class="n">or</span> <span class="kr">type</span> <span class="n">errors</span><span class="p">;</span>
             <span class="mi">3</span> <span class="o">--</span> <span class="n">compilation</span> <span class="n">errors</span><span class="p">;</span> <span class="mi">4</span> <span class="o">--</span> <span class="n">verification</span> <span class="n">errors</span>
  
  <span class="o">----</span> <span class="n">Input</span> <span class="n">configuration</span> <span class="o">---------------------------------------------------</span>
  
  <span class="o">/</span><span class="n">dprelude</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>
      <span class="n">Choose</span> <span class="n">the</span> <span class="n">Dafny</span> <span class="n">prelude</span> <span class="n">file</span><span class="o">.</span>

  <span class="o">/</span><span class="n">stdin</span>
      <span class="n">Read</span> <span class="n">standard</span> <span class="n">input</span> <span class="n">and</span> <span class="n">treat</span> <span class="n">it</span> <span class="ow">as</span> <span class="n">an</span> <span class="n">input</span> <span class="o">.</span><span class="n">dfy</span> <span class="n">file</span><span class="o">.</span>
  
  <span class="o">----</span> <span class="n">Plugins</span> <span class="o">---------------------------------------------------------------</span>
  
  <span class="o">----</span> <span class="n">Overall</span> <span class="n">reporting</span> <span class="n">and</span> <span class="n">printing</span> <span class="o">----------------------------------------</span>
  
  <span class="o">/</span><span class="n">showSnippets</span><span class="o">:&lt;</span><span class="n">value</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Don't</span> <span class="n">show</span> <span class="n">source</span> <span class="n">code</span> <span class="n">snippets</span> <span class="kr">for</span> <span class="n">Dafny</span> <span class="n">messages</span><span class="o">.</span>
      <span class="mi">1</span> <span class="o">-</span> <span class="n">Show</span> <span class="n">a</span> <span class="n">source</span> <span class="n">code</span> <span class="n">snippet</span> <span class="kr">for</span> <span class="n">each</span> <span class="n">Dafny</span> <span class="n">message</span><span class="o">.</span>

  <span class="o">/</span><span class="n">stats</span>
      <span class="n">Print</span> <span class="n">interesting</span> <span class="n">statistics</span> <span class="n">about</span> <span class="n">the</span> <span class="n">Dafny</span> <span class="n">files</span> <span class="n">supplied</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">printIncludes</span><span class="o">:&lt;</span><span class="n">None</span><span class="o">|</span><span class="n">Immediate</span><span class="o">|</span><span class="n">Transitive</span><span class="o">&gt;</span>
      <span class="n">None</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Print</span> <span class="n">nothing</span><span class="o">.</span>
      <span class="n">Immediate</span> <span class="o">-</span> <span class="n">Print</span> <span class="n">files</span> <span class="n">included</span> <span class="kr">by</span> <span class="n">files</span> <span class="n">listed</span> <span class="n">on</span> <span class="n">the</span> <span class="n">command</span> <span class="n">line</span><span class="o">.</span>
      <span class="n">Transitive</span> <span class="o">-</span> <span class="n">Recurses</span> <span class="n">on</span> <span class="n">the</span> <span class="n">files</span> <span class="n">printed</span> <span class="kr">by</span> <span class="n">Immediate</span><span class="o">.</span>
  
      <span class="n">Immediate</span> <span class="n">and</span> <span class="n">Transitive</span> <span class="n">will</span> <span class="n">exit</span> <span class="n">after</span> <span class="n">printing</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">view</span><span class="o">:&lt;</span><span class="n">view1</span><span class="p">,</span> <span class="n">view2</span><span class="o">&gt;</span>
      <span class="n">Print</span> <span class="n">the</span> <span class="n">filtered</span> <span class="n">views</span> <span class="n">of</span> <span class="n">a</span> <span class="kr">module</span> <span class="n">after</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">resolved</span> <span class="p">(</span><span class="o">/</span><span class="n">rprint</span><span class="p">)</span><span class="o">.</span>
      <span class="n">If</span> <span class="kr">print</span> <span class="n">before</span> <span class="n">the</span> <span class="kr">module</span> <span class="ow">is</span> <span class="n">resolved</span> <span class="p">(</span><span class="o">/</span><span class="n">dprint</span><span class="p">),</span> <span class="kr">then</span> <span class="n">everything</span> <span class="ow">in</span>
      <span class="n">the</span> <span class="kr">module</span> <span class="ow">is</span> <span class="n">printed</span><span class="o">.</span> <span class="n">If</span> <span class="n">no</span> <span class="n">view</span> <span class="ow">is</span> <span class="n">specified</span><span class="p">,</span> <span class="kr">then</span> <span class="n">everything</span> <span class="ow">in</span>
      <span class="n">the</span> <span class="kr">module</span> <span class="ow">is</span> <span class="n">printed</span><span class="o">.</span>
  <span class="o">/</span><span class="n">funcCallGraph</span>
      <span class="n">Print</span> <span class="n">out</span> <span class="n">the</span> <span class="kr">function</span> <span class="n">call</span> <span class="n">graph</span><span class="o">.</span> <span class="n">Format</span> <span class="ow">is</span><span class="o">:</span> <span class="n">func</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">callee</span><span class="o">*</span>
  
  <span class="o">/</span><span class="n">pmtrace</span>
      <span class="n">Print</span> <span class="n">pattern</span><span class="o">-</span><span class="kr">match</span> <span class="n">compiler</span> <span class="n">debug</span> <span class="n">info</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">printTooltips</span>
      <span class="n">Dump</span> <span class="n">additional</span> <span class="n">positional</span> <span class="n">information</span> <span class="p">(</span><span class="n">displayed</span> <span class="ow">as</span> <span class="n">mouse</span><span class="o">-</span><span class="n">over</span>
      <span class="n">tooltips</span> <span class="kr">by</span> <span class="n">the</span> <span class="n">VS</span> <span class="n">Code</span> <span class="n">plugin</span><span class="p">)</span> <span class="kr">to</span> <span class="n">stdout</span> <span class="ow">as</span> <span class="err">'Info'</span> <span class="n">messages</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">diagnosticsFormat</span><span class="o">:&lt;</span><span class="n">text</span><span class="o">|</span><span class="n">json</span><span class="o">&gt;</span>
      <span class="n">Choose</span> <span class="n">how</span> <span class="kr">to</span> <span class="n">report</span> <span class="n">errors</span><span class="p">,</span> <span class="n">warnings</span><span class="p">,</span> <span class="n">and</span> <span class="n">info</span> <span class="n">messages</span><span class="o">.</span>
      <span class="n">text</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Use</span> <span class="n">human</span> <span class="n">readable</span> <span class="n">output</span>
      <span class="n">json</span> <span class="o">-</span> <span class="n">Print</span> <span class="n">each</span> <span class="n">message</span> <span class="ow">as</span> <span class="n">a</span> <span class="n">JSON</span> <span class="kt">object</span><span class="p">,</span> <span class="n">one</span> <span class="n">per</span> <span class="n">line</span><span class="o">.</span>
  
  <span class="o">----</span> <span class="n">Language</span> <span class="n">feature</span> <span class="n">selection</span> <span class="o">--------------------------------------------</span>
  
  <span class="o">/</span><span class="n">defaultFunctionOpacity</span><span class="o">:&lt;</span><span class="n">value</span><span class="o">&gt;</span>
      <span class="n">Change</span> <span class="n">the</span> <span class="n">default</span> <span class="n">opacity</span> <span class="n">of</span> <span class="n">functions</span><span class="o">.</span> 
      <span class="p">`</span><span class="n">transparent</span><span class="p">`</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="n">means</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">transparent</span><span class="p">,</span> <span class="n">can</span> <span class="n">be</span> <span class="n">manually</span> <span class="n">made</span> <span class="n">opaque</span> <span class="n">and</span> <span class="kr">then</span> <span class="n">revealed</span><span class="o">.</span> 
      <span class="p">`</span><span class="n">autoRevealDependencies</span><span class="p">`</span> <span class="n">makes</span> <span class="n">all</span> <span class="n">functions</span> <span class="n">not</span> <span class="n">explicitly</span> <span class="n">labelled</span> <span class="ow">as</span> <span class="n">opaque</span> <span class="kr">to</span> <span class="n">be</span> <span class="n">opaque</span> <span class="n">but</span> <span class="kr">reveals</span> <span class="n">them</span> <span class="n">automatically</span> <span class="ow">in</span> <span class="n">scopes</span> <span class="n">which</span> <span class="n">do</span> <span class="n">not</span> <span class="n">have</span> <span class="p">`{</span><span class="o">:</span><span class="n">autoRevealDependencies</span> <span class="kc">false</span><span class="p">}`</span><span class="o">.</span> 
      <span class="p">`</span><span class="n">opaque</span><span class="p">`</span> <span class="n">means</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">always</span> <span class="n">opaque</span> <span class="n">so</span> <span class="n">the</span> <span class="n">opaque</span> <span class="n">keyword</span> <span class="ow">is</span> <span class="n">not</span> <span class="n">needed</span><span class="p">,</span> <span class="n">and</span> <span class="n">functions</span> <span class="n">must</span> <span class="n">be</span> <span class="n">revealed</span> <span class="n">everywhere</span> <span class="n">needed</span> <span class="kr">for</span> <span class="n">a</span> <span class="n">proof</span><span class="o">.</span>

  <span class="o">/</span><span class="n">readsClausesOnMethods</span><span class="o">:&lt;</span><span class="n">value</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Reads</span> <span class="n">clauses</span> <span class="n">on</span> <span class="n">methods</span> <span class="n">are</span> <span class="n">forbidden</span><span class="o">.</span>
      <span class="mi">1</span> <span class="o">-</span> <span class="n">Reads</span> <span class="n">clauses</span> <span class="n">on</span> <span class="n">methods</span> <span class="n">are</span> <span class="n">permitted</span> <span class="p">(</span><span class="n">with</span> <span class="n">a</span> <span class="n">default</span> <span class="n">of</span> <span class="err">'reads *'</span><span class="p">)</span><span class="o">.</span>

  <span class="o">/</span><span class="n">standardLibraries</span><span class="o">:&lt;</span><span class="n">value</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Do</span> <span class="n">not</span> <span class="n">allow</span> <span class="n">Dafny</span> <span class="n">code</span> <span class="kr">to</span> <span class="n">depend</span> <span class="n">on</span> <span class="n">the</span> <span class="n">standard</span> <span class="n">libraries</span> <span class="n">included</span> <span class="n">with</span> <span class="n">the</span> <span class="n">Dafny</span> <span class="n">distribution</span><span class="o">.</span>
      <span class="mi">1</span> <span class="o">-</span> <span class="n">Allow</span> <span class="n">Dafny</span> <span class="n">code</span> <span class="kr">to</span> <span class="n">depend</span> <span class="n">on</span> <span class="n">the</span> <span class="n">standard</span> <span class="n">libraries</span> <span class="n">included</span> <span class="n">with</span> <span class="n">the</span> <span class="n">Dafny</span> <span class="n">distribution</span><span class="o">.</span>
      <span class="n">See</span> <span class="n">https</span><span class="o">:</span><span class="c1">//github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/README.md for more information.</span>
      <span class="n">Not</span> <span class="n">compatible</span> <span class="n">with</span> <span class="n">the</span> <span class="o">/</span><span class="n">unicodeChar</span><span class="o">:</span><span class="mi">0</span> <span class="n">option</span><span class="o">.</span>

  <span class="o">/</span><span class="n">noIncludes</span>
      <span class="n">Ignore</span> <span class="kr">include</span> <span class="n">directives</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">noExterns</span>
      <span class="n">Ignore</span> <span class="n">extern</span> <span class="n">attributes</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">functionSyntax</span><span class="o">:&lt;</span><span class="n">version</span><span class="o">&gt;</span>
      <span class="n">The</span> <span class="n">syntax</span> <span class="kr">for</span> <span class="n">functions</span> <span class="ow">is</span> <span class="n">changing</span> <span class="n">from</span> <span class="n">Dafny</span> <span class="n">version</span> <span class="mi">3</span> <span class="kr">to</span> <span class="n">version</span>
      <span class="mi">4</span><span class="o">.</span> <span class="n">This</span> <span class="n">switch</span> <span class="n">gives</span> <span class="n">early</span> <span class="n">access</span> <span class="kr">to</span> <span class="n">the</span> <span class="kr">new</span> <span class="n">syntax</span><span class="p">,</span> <span class="n">and</span> <span class="n">also</span>
      <span class="kr">provides</span> <span class="n">a</span> <span class="n">mode</span> <span class="kr">to</span> <span class="n">help</span> <span class="n">with</span> <span class="n">migration</span><span class="o">.</span>
  
      <span class="mi">3</span> <span class="o">-</span> <span class="n">Compiled</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">written</span> <span class="p">`</span><span class="kr">function</span> <span class="kr">method</span><span class="p">`</span> <span class="n">and</span>
          <span class="p">`</span><span class="kr">predicate</span> <span class="kr">method</span><span class="p">`</span><span class="o">.</span> <span class="n">Ghost</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">written</span> <span class="p">`</span><span class="kr">function</span><span class="p">`</span> <span class="n">and</span>
          <span class="p">`</span><span class="kr">predicate</span><span class="p">`</span><span class="o">.</span>
      <span class="mi">4</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Compiled</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">written</span> <span class="p">`</span><span class="kr">function</span><span class="p">`</span> <span class="n">and</span> <span class="p">`</span><span class="kr">predicate</span><span class="p">`</span><span class="o">.</span> <span class="n">Ghost</span>
          <span class="n">functions</span> <span class="n">are</span> <span class="n">written</span> <span class="p">`</span><span class="kr">ghost</span> <span class="kr">function</span><span class="p">`</span> <span class="n">and</span> <span class="p">`</span><span class="kr">ghost</span> <span class="kr">predicate</span><span class="p">`</span><span class="o">.</span>
      <span class="n">migration3to4</span> <span class="o">-</span> <span class="n">Compiled</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">written</span> <span class="p">`</span><span class="kr">function</span> <span class="kr">method</span><span class="p">`</span> <span class="n">and</span>
          <span class="p">`</span><span class="kr">predicate</span> <span class="kr">method</span><span class="p">`</span><span class="o">.</span> <span class="n">Ghost</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">written</span> <span class="p">`</span><span class="kr">ghost</span> <span class="kr">function</span><span class="p">`</span>
          <span class="n">and</span> <span class="p">`</span><span class="kr">ghost</span> <span class="kr">predicate</span><span class="p">`</span><span class="o">.</span> <span class="n">To</span> <span class="n">migrate</span> <span class="n">from</span> <span class="n">version</span> <span class="mi">3</span> <span class="kr">to</span> <span class="n">version</span> <span class="mi">4</span><span class="p">,</span>
          <span class="n">use</span> <span class="kr">this</span> <span class="n">flag</span> <span class="n">on</span> <span class="n">your</span> <span class="n">version</span> <span class="mi">3</span> <span class="n">program</span><span class="o">.</span> <span class="n">This</span> <span class="n">will</span> <span class="n">give</span> <span class="n">flag</span> <span class="n">all</span>
          <span class="n">occurrences</span> <span class="n">of</span> <span class="p">`</span><span class="kr">function</span><span class="p">`</span> <span class="n">and</span> <span class="p">`</span><span class="kr">predicate</span><span class="p">`</span> <span class="ow">as</span> <span class="n">parsing</span> <span class="n">errors</span><span class="o">.</span>
          <span class="n">These</span> <span class="n">are</span> <span class="kr">ghost</span> <span class="n">functions</span><span class="p">,</span> <span class="n">so</span> <span class="n">change</span> <span class="n">those</span> <span class="n">into</span> <span class="n">the</span> <span class="kr">new</span> <span class="n">syntax</span>
          <span class="p">`</span><span class="kr">ghost</span> <span class="kr">function</span><span class="p">`</span> <span class="n">and</span> <span class="p">`</span><span class="kr">ghost</span> <span class="kr">predicate</span><span class="p">`</span><span class="o">.</span> <span class="n">Then</span><span class="p">,</span> <span class="n">start</span> <span class="n">using</span>
          <span class="o">/</span><span class="n">functionSyntax</span><span class="o">:</span><span class="mi">4</span><span class="o">.</span> <span class="n">This</span> <span class="n">will</span> <span class="n">flag</span> <span class="n">all</span> <span class="n">occurrences</span> <span class="n">of</span> <span class="p">`</span><span class="kr">function</span>
          <span class="kr">method</span><span class="p">`</span> <span class="n">and</span> <span class="p">`</span><span class="kr">predicate</span> <span class="kr">method</span><span class="p">`</span> <span class="ow">as</span> <span class="n">parsing</span> <span class="n">errors</span><span class="o">.</span> <span class="n">So</span><span class="p">,</span> <span class="n">change</span>
          <span class="n">those</span> <span class="kr">to</span> <span class="n">just</span> <span class="p">`</span><span class="kr">function</span><span class="p">`</span> <span class="n">and</span> <span class="p">`</span><span class="kr">predicate</span><span class="p">`</span><span class="o">.</span> <span class="n">Now</span><span class="p">,</span> <span class="n">your</span> <span class="n">program</span> <span class="n">uses</span>
          <span class="n">version</span> <span class="mi">4</span> <span class="n">syntax</span> <span class="n">and</span> <span class="n">has</span> <span class="n">the</span> <span class="n">exact</span> <span class="n">same</span> <span class="n">meaning</span> <span class="ow">as</span> <span class="n">your</span> <span class="n">previous</span>
          <span class="n">version</span> <span class="mi">3</span> <span class="n">program</span><span class="o">.</span>
      <span class="n">experimentalDefaultGhost</span> <span class="o">-</span> <span class="n">Like</span> <span class="n">migration3to4</span><span class="p">,</span> <span class="n">but</span> <span class="n">allow</span> <span class="p">`</span><span class="kr">function</span><span class="p">`</span>
          <span class="n">and</span> <span class="p">`</span><span class="kr">predicate</span><span class="p">`</span> <span class="ow">as</span> <span class="n">alternatives</span> <span class="kr">to</span> <span class="n">declaring</span> <span class="kr">ghost</span> <span class="n">functions</span> <span class="n">and</span>
          <span class="n">predicates</span><span class="p">,</span> <span class="n">respectively</span><span class="o">.</span>
      <span class="n">experimentalDefaultCompiled</span> <span class="o">-</span> <span class="n">Like</span> <span class="n">migration3to4</span><span class="p">,</span> <span class="n">but</span> <span class="n">allow</span>
          <span class="p">`</span><span class="kr">function</span><span class="p">`</span> <span class="n">and</span> <span class="p">`</span><span class="kr">predicate</span><span class="p">`</span> <span class="ow">as</span> <span class="n">alternatives</span> <span class="kr">to</span> <span class="n">declaring</span> <span class="n">compiled</span>
          <span class="n">functions</span> <span class="n">and</span> <span class="n">predicates</span><span class="p">,</span> <span class="n">respectively</span><span class="o">.</span>
      <span class="n">experimentalPredicateAlwaysGhost</span> <span class="o">-</span> <span class="n">Compiled</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">written</span>
          <span class="p">`</span><span class="kr">function</span><span class="p">`</span><span class="o">.</span> <span class="n">Ghost</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">written</span> <span class="p">`</span><span class="kr">ghost</span> <span class="kr">function</span><span class="p">`</span><span class="o">.</span>
          <span class="n">Predicates</span> <span class="n">are</span> <span class="n">always</span> <span class="kr">ghost</span> <span class="n">and</span> <span class="n">are</span> <span class="n">written</span> <span class="p">`</span><span class="kr">predicate</span><span class="p">`</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">quantifierSyntax</span><span class="o">:&lt;</span><span class="n">version</span><span class="o">&gt;</span>
      <span class="n">The</span> <span class="n">syntax</span> <span class="kr">for</span> <span class="n">quantification</span> <span class="n">domains</span> <span class="ow">is</span> <span class="n">changing</span> <span class="n">from</span> <span class="n">Dafny</span> <span class="n">version</span>
      <span class="mi">3</span> <span class="kr">to</span> <span class="n">version</span> <span class="mi">4</span><span class="p">,</span> <span class="n">more</span> <span class="n">specifically</span> <span class="n">where</span> <span class="n">quantifier</span> <span class="n">ranges</span> <span class="p">(</span><span class="o">|</span>
      <span class="o">&lt;</span><span class="n">Range</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">are</span> <span class="n">allowed</span><span class="o">.</span> <span class="n">This</span> <span class="n">switch</span> <span class="n">gives</span> <span class="n">early</span> <span class="n">access</span> <span class="kr">to</span> <span class="n">the</span> <span class="kr">new</span>
      <span class="n">syntax</span><span class="o">.</span>
  
      <span class="mi">3</span> <span class="o">-</span> <span class="n">Ranges</span> <span class="n">are</span> <span class="n">only</span> <span class="n">allowed</span> <span class="n">after</span> <span class="n">all</span> <span class="n">quantified</span> <span class="n">variables</span>
          <span class="n">are</span> <span class="n">declared</span><span class="o">.</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="kt">set</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span>
          <span class="n">y</span> <span class="o">::</span> <span class="n">y</span><span class="p">)</span>
      <span class="mi">4</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Ranges</span> <span class="n">are</span> <span class="n">allowed</span> <span class="n">after</span> <span class="n">each</span> <span class="n">quantified</span> <span class="n">variable</span> <span class="n">declaration</span><span class="o">.</span>
          <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="kt">set</span> <span class="n">x</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">::</span> <span class="n">y</span><span class="p">)</span>
  
      <span class="n">Note</span> <span class="n">that</span> <span class="n">quantifier</span> <span class="n">variable</span> <span class="n">domains</span> <span class="p">(</span><span class="o">&lt;-</span> <span class="o">&lt;</span><span class="n">Domain</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">are</span> <span class="n">available</span> <span class="ow">in</span>
      <span class="n">both</span> <span class="n">syntax</span> <span class="n">versions</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">disableScopes</span>
      <span class="n">Treat</span> <span class="n">all</span> <span class="kr">export</span> <span class="n">sets</span> <span class="ow">as</span> <span class="err">'export reveal *'</span><span class="o">.</span> <span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span> <span class="n">don't</span> <span class="n">hide</span> <span class="kr">function</span>
      <span class="n">bodies</span> <span class="n">or</span> <span class="kr">type</span> <span class="n">definitions</span> <span class="n">during</span> <span class="n">translation</span><span class="o">.</span>
  
  <span class="o">----</span> <span class="n">Warning</span> <span class="n">selection</span> <span class="o">-----------------------------------------------------</span>
  
  <span class="o">/</span><span class="n">warnShadowing</span>
      <span class="n">Emits</span> <span class="n">a</span> <span class="n">warning</span> <span class="kr">if</span> <span class="n">the</span> <span class="n">name</span> <span class="n">of</span> <span class="n">a</span> <span class="n">declared</span> <span class="n">variable</span> <span class="n">caused</span> <span class="n">another</span>
      <span class="n">variable</span> <span class="kr">to</span> <span class="n">be</span> <span class="n">shadowed</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">warnMissingConstructorParenthesis</span>
      <span class="n">Emits</span> <span class="n">a</span> <span class="n">warning</span> <span class="n">when</span> <span class="n">a</span> <span class="kr">constructor</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">a</span> <span class="kr">case</span> <span class="n">pattern</span> <span class="ow">is</span> <span class="n">not</span>
      <span class="n">followed</span> <span class="kr">by</span> <span class="n">parentheses</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">deprecation</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Don't</span> <span class="n">give</span> <span class="n">any</span> <span class="n">warnings</span> <span class="n">about</span> <span class="n">deprecated</span> <span class="n">features</span><span class="o">.</span>
      <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Show</span> <span class="n">warnings</span> <span class="n">about</span> <span class="n">deprecated</span> <span class="n">features</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">warningsAsErrors</span>
      <span class="n">Treat</span> <span class="n">warnings</span> <span class="ow">as</span> <span class="n">errors</span><span class="o">.</span>
  
  <span class="o">----</span> <span class="n">Verification</span> <span class="n">options</span> <span class="o">-------------------------------------------------</span>
  
  <span class="o">/</span><span class="n">allowAxioms</span><span class="o">:&lt;</span><span class="n">value</span><span class="o">&gt;</span>
      <span class="n">Prevents</span> <span class="n">a</span> <span class="n">warning</span> <span class="n">from</span> <span class="n">being</span> <span class="n">generated</span> <span class="kr">for</span> <span class="n">axioms</span><span class="p">,</span> <span class="n">such</span> <span class="ow">as</span> <span class="kr">assume</span> <span class="n">statements</span> <span class="n">and</span> <span class="n">functions</span> <span class="n">or</span> <span class="n">methods</span> <span class="n">without</span> <span class="n">a</span> <span class="n">body</span><span class="p">,</span> <span class="n">that</span> <span class="n">don't</span> <span class="n">have</span> <span class="n">an</span> <span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span> <span class="n">attribute</span><span class="o">.</span>

  <span class="o">/</span><span class="n">verificationLogger</span><span class="o">:&lt;</span><span class="n">configuration</span><span class="o">&gt;</span>
      <span class="n">Logs</span> <span class="n">verification</span> <span class="n">results</span> <span class="n">using</span> <span class="n">the</span> <span class="n">given</span> <span class="n">test</span> <span class="n">result</span> <span class="n">format</span><span class="o">.</span> <span class="n">The</span> <span class="n">currently</span> <span class="n">supported</span> <span class="n">formats</span> <span class="n">are</span> <span class="p">`</span><span class="n">trx</span><span class="p">`,</span> <span class="p">`</span><span class="n">csv</span><span class="p">`,</span> <span class="n">and</span> <span class="p">`</span><span class="n">text</span><span class="p">`</span><span class="o">.</span> <span class="n">These</span> <span class="n">are</span><span class="o">:</span> <span class="n">the</span> <span class="n">XML</span><span class="o">-</span><span class="n">based</span> <span class="n">format</span> <span class="n">commonly</span> <span class="n">used</span> <span class="kr">for</span> <span class="n">test</span> <span class="n">results</span> <span class="kr">for</span> <span class="o">.</span><span class="n">NET</span> <span class="n">languages</span><span class="p">,</span> <span class="n">a</span> <span class="n">custom</span> <span class="n">CSV</span> <span class="n">schema</span><span class="p">,</span> <span class="n">and</span> <span class="n">a</span> <span class="n">textual</span> <span class="n">format</span> <span class="n">meant</span> <span class="kr">for</span> <span class="n">human</span> <span class="n">consumption</span><span class="o">.</span> <span class="n">You</span> <span class="n">can</span> <span class="n">provide</span> <span class="n">configuration</span> <span class="n">using</span> <span class="n">the</span> <span class="n">same</span> <span class="kt">string</span> <span class="n">format</span> <span class="ow">as</span> <span class="n">when</span> <span class="n">using</span> <span class="n">the</span> <span class="o">--</span><span class="n">logger</span> <span class="n">option</span> <span class="kr">for</span> <span class="n">dotnet</span> <span class="n">test</span><span class="p">,</span> <span class="n">such</span> <span class="ow">as</span><span class="o">:</span> <span class="o">--</span><span class="n">format</span> <span class="s2">"trx;LogFileName=&lt;...&gt;"</span><span class="p">);</span>
      
      <span class="n">The</span> <span class="p">`</span><span class="n">trx</span><span class="p">`</span> <span class="n">and</span> <span class="p">`</span><span class="n">csv</span><span class="p">`</span> <span class="n">formats</span> <span class="n">automatically</span> <span class="n">choose</span> <span class="n">an</span> <span class="n">output</span> <span class="n">file</span> <span class="n">name</span> <span class="kr">by</span> <span class="n">default</span><span class="p">,</span> <span class="n">and</span> <span class="kr">print</span> <span class="n">the</span> <span class="n">name</span> <span class="n">of</span> <span class="kr">this</span> <span class="n">file</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">console</span><span class="o">.</span> <span class="n">The</span> <span class="p">`</span><span class="n">text</span><span class="p">`</span> <span class="n">format</span> <span class="n">prints</span> <span class="n">its</span> <span class="n">output</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">console</span> <span class="kr">by</span> <span class="n">default</span><span class="p">,</span> <span class="n">but</span> <span class="n">can</span> <span class="n">send</span> <span class="n">output</span> <span class="kr">to</span> <span class="n">a</span> <span class="n">file</span> <span class="n">given</span> <span class="n">the</span> <span class="p">`</span><span class="n">LogFileName</span><span class="p">`</span> <span class="n">option</span><span class="o">.</span>
      
      <span class="n">The</span> <span class="p">`</span><span class="n">text</span><span class="p">`</span> <span class="n">format</span> <span class="n">also</span> <span class="n">includes</span> <span class="n">a</span> <span class="n">more</span> <span class="n">detailed</span> <span class="n">breakdown</span> <span class="n">of</span> <span class="n">what</span> <span class="n">assertions</span> <span class="n">appear</span> <span class="ow">in</span> <span class="n">each</span> <span class="n">assertion</span> <span class="n">batch</span><span class="o">.</span> <span class="n">When</span> <span class="n">combined</span> <span class="n">with</span> <span class="n">the</span> <span class="n">isolate</span><span class="o">-</span><span class="n">assertions</span> <span class="n">option</span><span class="p">,</span> <span class="n">it</span> <span class="n">will</span> <span class="n">provide</span> <span class="n">approximate</span> <span class="n">time</span> <span class="n">and</span> <span class="n">resource</span> <span class="n">use</span> <span class="n">costs</span> <span class="kr">for</span> <span class="n">each</span> <span class="n">assertion</span><span class="p">,</span> <span class="n">allowing</span> <span class="n">identification</span> <span class="n">of</span> <span class="n">especially</span> <span class="n">expensive</span> <span class="n">assertions</span><span class="o">.</span>

  <span class="o">/</span><span class="n">dafnyVerify</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Stop</span> <span class="n">after</span> <span class="n">resolution</span> <span class="n">and</span> <span class="n">typechecking</span><span class="o">.</span>
      <span class="mi">1</span> <span class="o">-</span> <span class="n">Continue</span> <span class="n">on</span> <span class="kr">to</span> <span class="n">verification</span> <span class="n">and</span> <span class="n">compilation</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">verifyAllModules</span>
      <span class="n">Verify</span> <span class="n">modules</span> <span class="n">that</span> <span class="n">come</span> <span class="n">from</span> <span class="n">an</span> <span class="kr">include</span> <span class="n">directive</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">emitUncompilableCode</span>
      <span class="n">Allow</span> <span class="n">compilers</span> <span class="kr">to</span> <span class="n">emit</span> <span class="n">uncompilable</span> <span class="n">code</span> <span class="n">that</span> <span class="n">usually</span> <span class="n">contain</span> <span class="n">useful</span>
      <span class="n">information</span> <span class="n">about</span> <span class="n">what</span> <span class="n">feature</span> <span class="ow">is</span> <span class="n">missing</span><span class="p">,</span> <span class="n">rather</span> <span class="n">than</span>
      <span class="n">stopping</span> <span class="n">on</span> <span class="n">the</span> <span class="n">first</span> <span class="n">problem</span>
  
  <span class="o">/</span><span class="n">separateModuleOutput</span>
      <span class="n">Output</span> <span class="n">verification</span> <span class="n">results</span> <span class="kr">for</span> <span class="n">each</span> <span class="kr">module</span> <span class="n">separately</span><span class="p">,</span> <span class="n">rather</span> <span class="n">than</span>
      <span class="n">aggregating</span> <span class="n">them</span> <span class="n">after</span> <span class="n">they</span> <span class="n">are</span> <span class="n">all</span> <span class="n">finished</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">noCheating</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Allow</span> <span class="kr">assume</span> <span class="n">statements</span> <span class="n">and</span> <span class="n">free</span> <span class="n">invariants</span><span class="o">.</span>
      <span class="mi">1</span> <span class="o">-</span> <span class="n">Treat</span> <span class="n">all</span> <span class="n">assumptions</span> <span class="ow">as</span> <span class="n">asserts</span><span class="p">,</span> <span class="n">and</span> <span class="n">drop</span> <span class="n">free</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">induction</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Never</span> <span class="n">do</span> <span class="n">induction</span><span class="p">,</span> <span class="n">not</span> <span class="n">even</span> <span class="n">when</span> <span class="n">attributes</span> <span class="n">request</span> <span class="n">it</span><span class="o">.</span>
      <span class="mi">1</span> <span class="o">-</span> <span class="n">Only</span> <span class="n">apply</span> <span class="n">induction</span> <span class="n">when</span> <span class="n">attributes</span> <span class="n">request</span> <span class="n">it</span><span class="o">.</span>
      <span class="mi">2</span> <span class="o">-</span> <span class="n">Apply</span> <span class="n">induction</span> <span class="ow">as</span> <span class="n">requested</span> <span class="p">(</span><span class="kr">by</span> <span class="n">attributes</span><span class="p">)</span> <span class="n">and</span> <span class="n">also</span> <span class="kr">for</span>
          <span class="n">heuristically</span> <span class="n">chosen</span> <span class="n">quantifiers</span><span class="o">.</span>
      <span class="mi">3</span> <span class="o">-</span> <span class="n">Apply</span> <span class="n">induction</span> <span class="ow">as</span> <span class="n">requested</span><span class="p">,</span> <span class="n">and</span> <span class="kr">for</span> <span class="n">heuristically</span> <span class="n">chosen</span>
          <span class="n">quantifiers</span> <span class="n">and</span> <span class="n">lemmas</span><span class="o">.</span>
      <span class="mi">4</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Apply</span> <span class="n">induction</span> <span class="ow">as</span> <span class="n">requested</span><span class="p">,</span> <span class="n">and</span> <span class="kr">for</span> <span class="n">lemmas</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">inductionHeuristic</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Least</span> <span class="n">discriminating</span> <span class="n">induction</span> <span class="n">heuristic</span> <span class="p">(</span><span class="n">that</span> <span class="ow">is</span><span class="p">,</span> <span class="n">lean</span> <span class="n">toward</span>
          <span class="n">applying</span> <span class="n">induction</span> <span class="n">more</span> <span class="n">often</span><span class="p">)</span><span class="o">.</span>
      <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span> <span class="o">-</span> <span class="n">Levels</span> <span class="ow">in</span> <span class="n">between</span><span class="p">,</span> <span class="n">ordered</span> <span class="ow">as</span> <span class="n">follows</span> <span class="ow">as</span> <span class="n">far</span> <span class="ow">as</span> <span class="n">how</span>
          <span class="n">discriminating</span> <span class="n">they</span> <span class="n">are</span><span class="o">:</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="o">.</span>
      <span class="mi">6</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Most</span> <span class="n">discriminating</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">trackPrintEffects</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Every</span> <span class="n">compiled</span> <span class="kr">method</span><span class="p">,</span> <span class="kr">constructor</span><span class="p">,</span> <span class="n">and</span> <span class="kr">iterator</span><span class="p">,</span>
         <span class="n">whether</span> <span class="n">or</span> <span class="n">not</span> <span class="n">it</span> <span class="n">bears</span> <span class="n">a</span> <span class="p">{</span><span class="o">:</span><span class="kr">print</span><span class="p">}</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">may</span> <span class="n">have</span> <span class="kr">print</span>
         <span class="n">effects</span><span class="o">.</span>
      <span class="mi">1</span> <span class="o">-</span> <span class="n">A</span> <span class="n">compiled</span> <span class="kr">method</span><span class="p">,</span> <span class="kr">constructor</span><span class="p">,</span> <span class="n">or</span> <span class="kr">iterator</span> <span class="ow">is</span> <span class="n">allowed</span> <span class="kr">to</span> <span class="n">have</span>
         <span class="kr">print</span> <span class="n">effects</span> <span class="n">only</span> <span class="kr">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">marked</span> <span class="n">with</span> <span class="p">{</span><span class="o">:</span><span class="kr">print</span><span class="p">}</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">definiteAssignment</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Ignores</span> <span class="n">definite</span><span class="o">-</span><span class="n">assignment</span> <span class="n">rules</span><span class="o">.</span> <span class="n">This</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kr">for</span> <span class="n">testing</span>
          <span class="n">only</span><span class="o">--</span><span class="n">it</span> <span class="ow">is</span> <span class="n">not</span> <span class="n">sound</span><span class="o">.</span>
      <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Enforces</span> <span class="n">definite</span><span class="o">-</span><span class="n">assignment</span> <span class="n">rules</span> <span class="kr">for</span> <span class="n">compiled</span>
          <span class="n">variables</span> <span class="n">and</span> <span class="n">fields</span> <span class="n">whose</span> <span class="n">types</span> <span class="n">do</span> <span class="n">not</span> <span class="n">support</span>
          <span class="n">auto</span><span class="o">-</span><span class="n">initialization</span><span class="p">,</span> <span class="n">and</span> <span class="kr">for</span> <span class="kr">ghost</span> <span class="n">variables</span> <span class="n">and</span> <span class="n">fields</span> <span class="n">whose</span>
          <span class="kr">type</span> <span class="ow">is</span> <span class="n">possibly</span> <span class="n">empty</span><span class="o">.</span>
      <span class="mi">2</span> <span class="o">-</span> <span class="n">Enforces</span> <span class="n">definite</span><span class="o">-</span><span class="n">assignment</span> <span class="kr">for</span> <span class="n">all</span> <span class="n">non</span><span class="o">-</span><span class="kr">yield</span><span class="o">-</span><span class="n">parameter</span>
          <span class="n">variables</span> <span class="n">and</span> <span class="n">fields</span><span class="p">,</span> <span class="n">regardless</span> <span class="n">of</span> <span class="n">their</span> <span class="n">types</span><span class="o">.</span>
      <span class="mi">3</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">2</span><span class="p">,</span> <span class="n">but</span> <span class="n">also</span> <span class="n">performs</span> <span class="n">checks</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">compiler</span> <span class="n">that</span> <span class="n">no</span>
          <span class="n">nondeterministic</span> <span class="n">statements</span> <span class="n">are</span> <span class="n">used</span><span class="p">;</span> <span class="n">thus</span><span class="p">,</span> <span class="n">a</span> <span class="n">program</span> <span class="n">that</span>
          <span class="n">passes</span> <span class="n">at</span> <span class="kr">this</span> <span class="n">level</span> <span class="mi">3</span> <span class="ow">is</span> <span class="n">one</span> <span class="n">that</span> <span class="n">the</span> <span class="n">language</span> <span class="n">guarantees</span> <span class="n">that</span>
          <span class="n">values</span> <span class="n">seen</span> <span class="n">during</span> <span class="n">execution</span> <span class="n">will</span> <span class="n">be</span> <span class="n">the</span> <span class="n">same</span> <span class="ow">in</span> <span class="n">every</span> <span class="n">run</span> <span class="n">of</span>
          <span class="n">the</span> <span class="n">program</span><span class="o">.</span>
      <span class="mi">4</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">1</span><span class="p">,</span> <span class="n">but</span> <span class="n">enforces</span> <span class="n">definite</span> <span class="n">assignment</span> <span class="kr">for</span> <span class="n">all</span> <span class="n">local</span> <span class="n">variables</span>
          <span class="n">and</span> <span class="n">out</span><span class="o">-</span><span class="n">parameters</span><span class="p">,</span> <span class="n">regardless</span> <span class="n">of</span> <span class="n">their</span> <span class="n">types</span><span class="o">.</span> <span class="p">(</span><span class="n">Whether</span> <span class="n">or</span> <span class="n">not</span>
          <span class="n">fields</span> <span class="n">and</span> <span class="kr">new</span> <span class="n">arrays</span> <span class="n">are</span> <span class="n">subject</span> <span class="kr">to</span> <span class="n">definite</span> <span class="n">assignments</span> <span class="n">depends</span>
          <span class="n">on</span> <span class="n">their</span> <span class="n">types</span><span class="o">.</span><span class="p">)</span>
  
  <span class="o">/</span><span class="n">noAutoReq</span>
      <span class="n">Ignore</span> <span class="n">autoReq</span> <span class="n">attributes</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">autoReqPrint</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>
      <span class="n">Print</span> <span class="n">out</span> <span class="n">requirements</span> <span class="n">that</span> <span class="n">were</span> <span class="n">automatically</span> <span class="n">generated</span> <span class="kr">by</span> <span class="n">autoReq</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">noNLarith</span>
      <span class="n">Reduce</span> <span class="n">Z3's</span> <span class="n">knowledge</span> <span class="n">of</span> <span class="n">non</span><span class="o">-</span><span class="n">linear</span> <span class="n">arithmetic</span> <span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">/</span><span class="p">,</span><span class="o">%</span><span class="p">)</span><span class="o">.</span>
  
      <span class="n">Results</span> <span class="ow">in</span> <span class="n">more</span> <span class="n">manual</span> <span class="n">work</span><span class="p">,</span> <span class="n">but</span> <span class="n">also</span> <span class="n">produces</span> <span class="n">more</span> <span class="n">predictable</span>
      <span class="n">behavior</span><span class="o">.</span> <span class="p">(</span><span class="n">This</span> <span class="n">switch</span> <span class="n">will</span> <span class="n">perhaps</span> <span class="n">be</span> <span class="n">replaced</span> <span class="kr">by</span> <span class="o">/</span><span class="n">arith</span> <span class="ow">in</span> <span class="n">the</span>
      <span class="n">future</span><span class="o">.</span> <span class="n">For</span> <span class="n">now</span><span class="p">,</span> <span class="n">it</span> <span class="n">takes</span> <span class="n">precedence</span> <span class="n">of</span> <span class="o">/</span><span class="n">arith</span><span class="o">.</span><span class="p">)</span>
  
  <span class="o">/</span><span class="n">arith</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="p">(</span><span class="n">experimental</span><span class="p">)</span> <span class="n">Adjust</span> <span class="n">how</span> <span class="n">Dafny</span> <span class="n">interprets</span> <span class="n">arithmetic</span> <span class="n">operations</span><span class="o">.</span>
  
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Use</span> <span class="n">Boogie</span><span class="o">/</span><span class="n">Z3</span> <span class="n">built</span><span class="o">-</span><span class="n">ins</span> <span class="kr">for</span> <span class="n">all</span> <span class="n">arithmetic</span> <span class="n">operations</span><span class="o">.</span>
      <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">0</span><span class="p">,</span> <span class="n">but</span> <span class="n">introduce</span> <span class="n">symbolic</span> <span class="n">synonyms</span> <span class="kr">for</span> <span class="o">*</span><span class="p">,</span><span class="o">/</span><span class="p">,</span><span class="o">%</span><span class="p">,</span> <span class="n">and</span>
          <span class="n">allow</span> <span class="n">these</span> <span class="n">operators</span> <span class="kr">to</span> <span class="n">be</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">triggers</span><span class="o">.</span>
      <span class="mi">2</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">1</span><span class="p">,</span> <span class="n">but</span> <span class="n">introduce</span> <span class="n">symbolic</span> <span class="n">synonyms</span> <span class="n">also</span> <span class="kr">for</span> <span class="o">+</span><span class="p">,</span><span class="o">-.</span>
      <span class="mi">3</span> <span class="o">-</span> <span class="n">Turn</span> <span class="n">off</span> <span class="n">non</span><span class="o">-</span><span class="n">linear</span> <span class="n">arithmetic</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">SMT</span> <span class="n">solver</span><span class="o">.</span> <span class="n">Still</span><span class="p">,</span> <span class="n">use</span>
          <span class="n">Boogie</span><span class="o">/</span><span class="n">Z3</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">symbols</span> <span class="kr">for</span> <span class="n">all</span> <span class="n">arithmetic</span> <span class="n">operations</span><span class="o">.</span>
      <span class="mi">4</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">3</span><span class="p">,</span> <span class="n">but</span> <span class="n">introduce</span> <span class="n">symbolic</span> <span class="n">synonyms</span> <span class="kr">for</span> <span class="o">*</span><span class="p">,</span><span class="o">/</span><span class="p">,</span><span class="o">%</span><span class="p">,</span> <span class="n">and</span> <span class="n">allow</span>
          <span class="n">these</span> <span class="n">operators</span> <span class="kr">to</span> <span class="n">be</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">triggers</span><span class="o">.</span>
      <span class="mi">5</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">4</span><span class="p">,</span> <span class="n">but</span> <span class="n">introduce</span> <span class="n">symbolic</span> <span class="n">synonyms</span> <span class="n">also</span> <span class="kr">for</span> <span class="o">+</span><span class="p">,</span><span class="o">-.</span>
      <span class="mi">6</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">5</span><span class="p">,</span> <span class="n">and</span> <span class="n">introduce</span> <span class="n">axioms</span> <span class="n">that</span> <span class="n">distribute</span> <span class="o">+</span> <span class="n">over</span> <span class="o">*.</span>
      <span class="mi">7</span> <span class="o">-</span> <span class="n">like</span> <span class="mi">6</span><span class="p">,</span> <span class="n">and</span> <span class="n">introduce</span> <span class="n">facts</span> <span class="n">that</span> <span class="n">associate</span> <span class="n">literals</span> <span class="n">arguments</span> <span class="n">of</span> <span class="o">*.</span>
      <span class="mi">8</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">7</span><span class="p">,</span> <span class="n">and</span> <span class="n">introduce</span> <span class="n">axiom</span> <span class="kr">for</span> <span class="n">the</span> <span class="n">connection</span> <span class="n">between</span> <span class="o">*</span><span class="p">,</span><span class="o">/</span><span class="p">,</span><span class="o">%.</span>
      <span class="mi">9</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">8</span><span class="p">,</span> <span class="n">and</span> <span class="n">introduce</span> <span class="n">axioms</span> <span class="kr">for</span> <span class="n">sign</span> <span class="n">of</span> <span class="n">multiplication</span><span class="o">.</span>
      <span class="mi">10</span> <span class="o">-</span> <span class="n">Like</span> <span class="mi">9</span><span class="p">,</span> <span class="n">and</span> <span class="n">introduce</span> <span class="n">axioms</span> <span class="kr">for</span> <span class="n">commutativity</span> <span class="n">and</span>
          <span class="n">associativity</span> <span class="n">of</span> <span class="o">*.</span>
  
  <span class="o">/</span><span class="n">autoTriggers</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Do</span> <span class="n">not</span> <span class="n">generate</span> <span class="p">{</span><span class="o">:</span><span class="n">trigger</span><span class="p">}</span> <span class="n">annotations</span> <span class="kr">for</span> <span class="n">user</span><span class="o">-</span><span class="n">level</span>
          <span class="n">quantifiers</span><span class="o">.</span>
      <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Add</span> <span class="n">a</span> <span class="p">{</span><span class="o">:</span><span class="n">trigger</span><span class="p">}</span> <span class="kr">to</span> <span class="n">each</span> <span class="n">user</span><span class="o">-</span><span class="n">level</span> <span class="n">quantifier</span><span class="o">.</span>
          <span class="n">Existing</span> <span class="n">annotations</span> <span class="n">are</span> <span class="n">preserved</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">rewriteFocalPredicates</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Don't</span> <span class="n">rewrite</span> <span class="n">predicates</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">of</span> <span class="n">prefix</span> <span class="n">lemmas</span><span class="o">.</span>
      <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">In</span> <span class="n">the</span> <span class="n">body</span> <span class="n">of</span> <span class="n">prefix</span> <span class="n">lemmas</span><span class="p">,</span> <span class="n">rewrite</span> <span class="n">any</span> <span class="n">use</span> <span class="n">of</span> <span class="n">a</span>
          <span class="n">focal</span> <span class="kr">predicate</span> <span class="n">P</span> <span class="kr">to</span> <span class="n">P</span><span class="err">#</span><span class="p">[</span><span class="err">_</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">extractCounterexample</span>
      <span class="n">If</span> <span class="n">verification</span> <span class="n">fails</span><span class="p">,</span> <span class="n">report</span> <span class="n">a</span> <span class="n">detailed</span> <span class="n">counterexample</span> <span class="kr">for</span> <span class="n">the</span>
      <span class="n">first</span> <span class="n">failing</span> <span class="n">assertion</span> <span class="p">(</span><span class="n">experimental</span><span class="p">)</span><span class="o">.</span>
  
  <span class="o">----</span> <span class="n">Compilation</span> <span class="n">options</span> <span class="o">---------------------------------------------------</span>
  
  <span class="o">/</span><span class="n">compileTarget</span><span class="o">:&lt;</span><span class="n">language</span><span class="o">&gt;</span>
      <span class="n">cs</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Compile</span> <span class="kr">to</span> <span class="o">.</span><span class="n">NET</span> <span class="n">via</span> <span class="n">C</span><span class="err">#</span><span class="o">.</span>
      <span class="n">go</span> <span class="o">-</span> <span class="n">Compile</span> <span class="kr">to</span> <span class="n">Go</span><span class="o">.</span>
      <span class="n">js</span> <span class="o">-</span> <span class="n">Compile</span> <span class="kr">to</span> <span class="n">JavaScript</span><span class="o">.</span>
      <span class="n">java</span> <span class="o">-</span> <span class="n">Compile</span> <span class="kr">to</span> <span class="n">Java</span><span class="o">.</span>
      <span class="n">py</span> <span class="o">-</span> <span class="n">Compile</span> <span class="kr">to</span> <span class="n">Python</span><span class="o">.</span>
      <span class="n">cpp</span> <span class="o">-</span> <span class="n">Compile</span> <span class="kr">to</span> <span class="n">C</span><span class="o">++.</span>
      <span class="n">dfy</span> <span class="o">-</span> <span class="n">Compile</span> <span class="kr">to</span> <span class="n">Dafny</span><span class="o">.</span>
      
      <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">C</span><span class="o">++</span> <span class="n">backend</span> <span class="n">has</span> <span class="n">various</span> <span class="n">limitations</span> <span class="p">(</span><span class="n">see</span>
      <span class="n">Docs</span><span class="o">/</span><span class="n">Compilation</span><span class="o">/</span><span class="n">Cpp</span><span class="o">.</span><span class="n">md</span><span class="p">)</span><span class="o">.</span> <span class="n">This</span> <span class="n">includes</span> <span class="n">lack</span> <span class="n">of</span> <span class="n">support</span> <span class="kr">for</span>
      <span class="n">BigIntegers</span> <span class="p">(</span><span class="n">aka</span> <span class="kt">int</span><span class="p">),</span> <span class="n">most</span> <span class="n">higher</span> <span class="n">order</span> <span class="n">functions</span><span class="p">,</span> <span class="n">and</span> <span class="n">advanced</span>
      <span class="n">features</span> <span class="n">like</span> <span class="n">traits</span> <span class="n">or</span> <span class="n">co</span><span class="o">-</span><span class="n">inductive</span> <span class="n">types</span><span class="o">.</span>

  <span class="o">/</span><span class="n">library</span><span class="o">:&lt;</span><span class="n">value</span><span class="o">&gt;</span>
      <span class="n">The</span> <span class="n">contents</span> <span class="n">of</span> <span class="kr">this</span> <span class="n">file</span> <span class="n">and</span> <span class="n">any</span> <span class="n">files</span> <span class="n">it</span> <span class="n">includes</span> <span class="n">can</span> <span class="n">be</span> <span class="n">referenced</span> <span class="n">from</span> <span class="n">other</span> <span class="n">files</span> <span class="ow">as</span> <span class="kr">if</span> <span class="n">they</span> <span class="n">were</span> <span class="n">included</span><span class="o">.</span> 
      <span class="n">However</span><span class="p">,</span> <span class="n">these</span> <span class="n">contents</span> <span class="n">are</span> <span class="n">skipped</span> <span class="n">during</span> <span class="n">code</span> <span class="n">generation</span> <span class="n">and</span> <span class="n">verification</span><span class="o">.</span>
      <span class="n">This</span> <span class="n">option</span> <span class="ow">is</span> <span class="n">useful</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">diamond</span> <span class="n">dependency</span> <span class="n">situation</span><span class="p">,</span> 
      <span class="kr">to</span> <span class="n">prevent</span> <span class="n">code</span> <span class="n">from</span> <span class="n">the</span> <span class="n">bottom</span> <span class="n">dependency</span> <span class="n">from</span> <span class="n">being</span> <span class="n">generated</span> <span class="n">more</span> <span class="n">than</span> <span class="n">once</span><span class="o">.</span>
      <span class="n">The</span> <span class="n">value</span> <span class="n">may</span> <span class="n">be</span> <span class="n">a</span> <span class="n">comma</span><span class="o">-</span><span class="n">separated</span> <span class="n">list</span> <span class="n">of</span> <span class="n">files</span> <span class="n">and</span> <span class="n">folders</span><span class="o">.</span>

  <span class="o">/</span><span class="n">optimizeErasableDatatypeWrapper</span><span class="o">:&lt;</span><span class="n">value</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Include</span> <span class="n">all</span> <span class="n">non</span><span class="o">-</span><span class="kr">ghost</span> <span class="kr">datatype</span> <span class="n">constructors</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">compiled</span> <span class="n">code</span>
      <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">In</span> <span class="n">the</span> <span class="n">compiled</span> <span class="n">target</span> <span class="n">code</span><span class="p">,</span> <span class="n">transform</span> <span class="n">any</span> <span class="n">non</span><span class="o">-</span><span class="n">extern</span>
          <span class="kr">datatype</span> <span class="n">with</span> <span class="n">a</span> <span class="n">single</span> <span class="n">non</span><span class="o">-</span><span class="kr">ghost</span> <span class="kr">constructor</span> <span class="n">that</span> <span class="n">has</span> <span class="n">a</span> <span class="n">single</span>
          <span class="n">non</span><span class="o">-</span><span class="kr">ghost</span> <span class="n">parameter</span> <span class="n">into</span> <span class="n">just</span> <span class="n">that</span> <span class="n">parameter</span><span class="o">.</span> <span class="n">For</span> <span class="n">example</span><span class="p">,</span> <span class="n">the</span> <span class="kr">type</span>
              <span class="kr">datatype</span> <span class="n">Record</span> <span class="o">=</span> <span class="n">Record</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span>
          <span class="ow">is</span> <span class="n">transformed</span> <span class="n">into</span> <span class="n">just</span> <span class="err">'int'</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">code</span><span class="o">.</span>

  <span class="o">/</span><span class="n">out</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>
      <span class="n">Specify</span> <span class="n">the</span> <span class="n">filename</span> <span class="n">and</span> <span class="n">location</span> <span class="kr">for</span> <span class="n">the</span> <span class="n">generated</span> <span class="n">target</span> <span class="n">language</span> <span class="n">files</span><span class="o">.</span>

  <span class="o">/</span><span class="n">runAllTests</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Annotates</span> <span class="n">compiled</span> <span class="n">methods</span> <span class="n">with</span> <span class="n">the</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span>
              <span class="n">attribute</span> <span class="n">such</span> <span class="n">that</span> <span class="n">they</span> <span class="n">can</span> <span class="n">be</span> <span class="n">tested</span> <span class="n">using</span> <span class="n">a</span> <span class="n">testing</span> <span class="n">framework</span>
              <span class="ow">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">language</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">xUnit</span> <span class="kr">for</span> <span class="n">C</span><span class="err">#</span><span class="p">)</span><span class="o">.</span>
          <span class="mi">1</span> <span class="o">-</span> <span class="n">Emits</span> <span class="n">a</span> <span class="n">main</span> <span class="kr">method</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">language</span> <span class="n">that</span> <span class="n">will</span> <span class="n">execute</span>
              <span class="n">every</span> <span class="kr">method</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">program</span> <span class="n">with</span> <span class="n">the</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span> <span class="n">attribute</span><span class="o">.</span> <span class="n">Cannot</span>
              <span class="n">be</span> <span class="n">used</span> <span class="kr">if</span> <span class="n">the</span> <span class="n">program</span> <span class="n">already</span> <span class="n">contains</span> <span class="n">a</span> <span class="n">main</span> <span class="kr">method</span><span class="o">.</span> <span class="n">Note</span> <span class="n">that</span>
              <span class="o">/</span><span class="n">compile</span><span class="o">:</span><span class="mi">3</span> <span class="n">or</span> <span class="mi">4</span> <span class="n">must</span> <span class="n">be</span> <span class="n">provided</span> <span class="ow">as</span> <span class="n">well</span> <span class="kr">to</span> <span class="n">actually</span> <span class="n">execute</span>
              <span class="kr">this</span> <span class="n">main</span> <span class="kr">method</span><span class="o">!</span>

  <span class="o">/</span><span class="n">compile</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Do</span> <span class="n">not</span> <span class="n">compile</span> <span class="n">Dafny</span> <span class="n">program</span><span class="o">.</span>
      <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Upon</span> <span class="n">successful</span> <span class="n">verification</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Dafny</span> <span class="n">program</span><span class="p">,</span>
          <span class="n">compile</span> <span class="n">it</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">designated</span> <span class="n">target</span> <span class="n">language</span><span class="o">.</span> <span class="p">(</span><span class="o">/</span><span class="n">noVerify</span>
          <span class="n">automatically</span> <span class="n">counts</span> <span class="ow">as</span> <span class="n">a</span> <span class="n">failed</span> <span class="n">verification</span><span class="o">.</span><span class="p">)</span>
      <span class="mi">2</span> <span class="o">-</span> <span class="n">Always</span> <span class="n">attempt</span> <span class="kr">to</span> <span class="n">compile</span> <span class="n">Dafny</span> <span class="n">program</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">target</span> <span class="n">language</span><span class="p">,</span>
          <span class="n">regardless</span> <span class="n">of</span> <span class="n">verification</span> <span class="n">outcome</span><span class="o">.</span>
      <span class="mi">3</span> <span class="o">-</span> <span class="n">If</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">Main</span> <span class="kr">method</span> <span class="n">and</span> <span class="n">there</span> <span class="n">are</span> <span class="n">no</span> <span class="n">verification</span> <span class="n">errors</span>
          <span class="n">and</span> <span class="o">/</span><span class="n">noVerify</span> <span class="ow">is</span> <span class="n">not</span> <span class="n">used</span><span class="p">,</span> <span class="n">compiles</span> <span class="n">program</span> <span class="ow">in</span> <span class="n">memory</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span>
          <span class="n">does</span> <span class="n">not</span> <span class="n">write</span> <span class="n">an</span> <span class="n">output</span> <span class="n">file</span><span class="p">)</span> <span class="n">and</span> <span class="n">runs</span> <span class="n">it</span><span class="o">.</span>
      <span class="mi">4</span> <span class="o">-</span> <span class="n">Like</span> <span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">but</span> <span class="n">attempts</span> <span class="kr">to</span> <span class="n">compile</span> <span class="n">and</span> <span class="n">run</span> <span class="n">regardless</span> <span class="n">of</span>
          <span class="n">verification</span> <span class="n">outcome</span><span class="o">.</span>
  <span class="o">/</span><span class="n">Main</span><span class="o">:&lt;</span><span class="n">name</span><span class="o">&gt;</span>
      <span class="n">Specify</span> <span class="n">the</span> <span class="p">(</span><span class="n">fully</span><span class="o">-</span><span class="n">qualified</span><span class="p">)</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="kr">method</span> <span class="kr">to</span> <span class="n">use</span> <span class="ow">as</span> <span class="n">the</span> <span class="n">executable</span> <span class="n">entry</span> <span class="n">point</span><span class="o">.</span>
      <span class="n">Default</span> <span class="ow">is</span> <span class="n">the</span> <span class="kr">method</span> <span class="n">with</span> <span class="n">the</span> <span class="p">{</span><span class="o">:</span><span class="n">main</span><span class="p">}</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">or</span> <span class="kr">else</span> <span class="n">the</span> <span class="kr">method</span> <span class="n">named</span> <span class="err">'Main'</span><span class="o">.</span>
      <span class="n">A</span> <span class="n">Main</span> <span class="kr">method</span> <span class="n">can</span> <span class="n">have</span> <span class="n">at</span> <span class="n">most</span> <span class="n">one</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="kr">ghost</span><span class="p">)</span> <span class="n">argument</span> <span class="n">of</span> <span class="kr">type</span> <span class="p">`</span><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="p">`</span>
  <span class="o">--</span><span class="n">args</span> <span class="o">&lt;</span><span class="n">arg1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">arg2</span><span class="o">&gt;</span> <span class="o">...</span>
      <span class="n">When</span> <span class="n">running</span> <span class="n">a</span> <span class="n">Dafny</span> <span class="n">file</span> <span class="n">through</span> <span class="o">/</span><span class="n">compile</span><span class="o">:</span><span class="mi">3</span> <span class="n">or</span> <span class="o">/</span><span class="n">compile</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span> <span class="err">'--args'</span> <span class="kr">provides</span>
      <span class="n">all</span> <span class="n">arguments</span> <span class="n">after</span> <span class="n">it</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">Main</span> <span class="kr">function</span><span class="p">,</span> <span class="n">at</span> <span class="n">index</span> <span class="n">starting</span> <span class="n">at</span> <span class="mi">1</span><span class="o">.</span>
      <span class="n">Index</span> <span class="mi">0</span> <span class="ow">is</span> <span class="n">used</span> <span class="kr">to</span> <span class="n">store</span> <span class="n">the</span> <span class="n">executable's</span> <span class="n">name</span> <span class="kr">if</span> <span class="n">it</span> <span class="kr">exists</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">compileVerbose</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Don't</span> <span class="kr">print</span> <span class="n">status</span> <span class="n">of</span> <span class="n">compilation</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">console</span><span class="o">.</span>
      <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Print</span> <span class="n">information</span> <span class="n">such</span> <span class="ow">as</span> <span class="n">files</span> <span class="n">being</span> <span class="n">written</span> <span class="kr">by</span> <span class="n">the</span>
          <span class="n">compiler</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">console</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">spillTargetCode</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="n">Explicitly</span> <span class="n">writes</span> <span class="n">the</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">language</span> <span class="kr">to</span> <span class="n">one</span> <span class="n">or</span> <span class="n">more</span> <span class="n">files</span><span class="o">.</span>
      <span class="n">This</span> <span class="ow">is</span> <span class="n">not</span> <span class="n">necessary</span> <span class="kr">to</span> <span class="n">run</span> <span class="n">a</span> <span class="n">Dafny</span> <span class="n">program</span><span class="p">,</span> <span class="n">but</span> <span class="n">may</span> <span class="n">be</span> <span class="n">of</span> <span class="n">interest</span> <span class="n">when</span>
      <span class="n">building</span> <span class="n">multi</span><span class="o">-</span><span class="n">language</span> <span class="n">programs</span> <span class="n">or</span> <span class="kr">for</span> <span class="n">debugging</span><span class="o">.</span>
  
      <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Don't</span> <span class="n">make</span> <span class="n">any</span> <span class="n">extra</span> <span class="n">effort</span> <span class="kr">to</span> <span class="n">write</span> <span class="n">the</span> <span class="n">textual</span>
          <span class="n">target</span> <span class="n">program</span> <span class="p">(</span><span class="n">but</span> <span class="n">still</span> <span class="n">compile</span> <span class="n">it</span><span class="p">,</span> <span class="kr">if</span> <span class="o">/</span><span class="n">compile</span> <span class="n">indicates</span> <span class="kr">to</span>
          <span class="n">do</span> <span class="n">so</span><span class="p">)</span><span class="o">.</span>
      <span class="mi">1</span> <span class="o">-</span> <span class="n">Write</span> <span class="n">the</span> <span class="n">textual</span> <span class="n">target</span> <span class="n">program</span><span class="p">,</span> <span class="kr">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">being</span> <span class="n">compiled</span><span class="o">.</span>
      <span class="mi">2</span> <span class="o">-</span> <span class="n">Write</span> <span class="n">the</span> <span class="n">textual</span> <span class="n">target</span> <span class="n">program</span><span class="p">,</span> <span class="n">provided</span> <span class="n">it</span> <span class="n">passes</span> <span class="n">the</span>
          <span class="n">verifier</span> <span class="p">(</span><span class="n">and</span> <span class="o">/</span><span class="n">noVerify</span> <span class="ow">is</span> <span class="n">NOT</span> <span class="n">used</span><span class="p">),</span> <span class="n">regardless</span> <span class="n">of</span> <span class="o">/</span><span class="n">compile</span>
          <span class="n">setting</span><span class="o">.</span>
      <span class="mi">3</span> <span class="o">-</span> <span class="n">Write</span> <span class="n">the</span> <span class="n">textual</span> <span class="n">target</span> <span class="n">program</span><span class="p">,</span> <span class="n">regardless</span> <span class="n">of</span> <span class="n">verification</span>
          <span class="n">outcome</span> <span class="n">and</span> <span class="o">/</span><span class="n">compile</span> <span class="n">setting</span><span class="o">.</span>
      <span class="n">Note</span><span class="p">,</span> <span class="n">some</span> <span class="n">compiler</span> <span class="n">targets</span> <span class="n">may</span> <span class="p">(</span><span class="n">always</span> <span class="n">or</span> <span class="ow">in</span> <span class="n">some</span> <span class="n">situations</span><span class="p">)</span> <span class="n">write</span>
      <span class="n">out</span> <span class="n">the</span> <span class="n">textual</span> <span class="n">target</span> <span class="n">program</span> <span class="ow">as</span> <span class="n">part</span> <span class="n">of</span> <span class="n">compilation</span><span class="p">,</span> <span class="ow">in</span> <span class="n">which</span> <span class="kr">case</span>
      <span class="o">/</span><span class="n">spillTargetCode</span><span class="o">:</span><span class="mi">0</span> <span class="n">behaves</span> <span class="n">the</span> <span class="n">same</span> <span class="n">way</span> <span class="ow">as</span> <span class="o">/</span><span class="n">spillTargetCode</span><span class="o">:</span><span class="mi">1</span><span class="o">.</span>
  <span class="o">/</span><span class="n">coverage</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>
      <span class="n">The</span> <span class="n">compiler</span> <span class="n">emits</span> <span class="n">branch</span><span class="o">-</span><span class="n">coverage</span> <span class="n">calls</span> <span class="n">and</span> <span class="n">outputs</span> <span class="n">into</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span> <span class="n">a</span>
      <span class="n">legend</span> <span class="n">that</span> <span class="n">gives</span> <span class="n">a</span> <span class="n">description</span> <span class="n">of</span> <span class="n">each</span> <span class="n">source</span><span class="o">-</span><span class="n">location</span> <span class="n">identifier</span>
      <span class="n">used</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">branch</span><span class="o">-</span><span class="n">coverage</span> <span class="n">calls</span><span class="o">.</span> <span class="p">(</span><span class="n">Use</span> <span class="o">-</span> <span class="ow">as</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span> <span class="kr">to</span> <span class="kr">print</span> <span class="kr">to</span> <span class="n">the</span>
      <span class="n">console</span><span class="o">.</span><span class="p">)</span>
  
  <span class="o">/</span><span class="n">optimize</span>
      <span class="n">Produce</span> <span class="n">optimized</span> <span class="n">C</span><span class="err">#</span> <span class="n">code</span> <span class="kr">by</span> <span class="n">passing</span> <span class="n">the</span> <span class="o">/</span><span class="n">optimize</span> <span class="n">flag</span> <span class="kr">to</span> <span class="n">csc</span><span class="o">.</span><span class="n">exe</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">optimizeResolution</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
      <span class="mi">0</span> <span class="o">-</span> <span class="n">Resolve</span> <span class="n">and</span> <span class="n">translate</span> <span class="n">all</span> <span class="n">methods</span><span class="o">.</span>
      <span class="mi">1</span> <span class="o">-</span> <span class="n">Translate</span> <span class="n">methods</span> <span class="n">only</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">call</span> <span class="n">graph</span> <span class="n">of</span> <span class="n">current</span> <span class="n">verification</span>
          <span class="n">target</span><span class="o">.</span>
      <span class="mi">2</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">As</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="n">but</span> <span class="n">only</span> <span class="n">resolve</span> <span class="kr">method</span> <span class="n">bodies</span> <span class="ow">in</span>
          <span class="n">non</span><span class="o">-</span><span class="n">included</span> <span class="n">Dafny</span> <span class="n">sources</span><span class="o">.</span>
  <span class="o">/</span><span class="n">useRuntimeLib</span>
      <span class="n">Refer</span> <span class="kr">to</span> <span class="n">a</span> <span class="n">pre</span><span class="o">-</span><span class="n">built</span> <span class="n">DafnyRuntime</span><span class="o">.</span><span class="n">dll</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">compiled</span> <span class="n">assembly</span>
      <span class="n">rather</span> <span class="n">than</span> <span class="n">including</span> <span class="n">DafnyRuntime</span><span class="o">.</span><span class="n">cs</span> <span class="n">verbatim</span><span class="o">.</span>
  
  <span class="o">/</span><span class="n">testContracts</span><span class="o">:&lt;</span><span class="n">Externs</span><span class="o">|</span><span class="n">TestedExterns</span><span class="o">&gt;</span>
      <span class="n">Enable</span> <span class="n">run</span><span class="o">-</span><span class="n">time</span> <span class="n">testing</span> <span class="n">of</span> <span class="n">the</span> <span class="n">compilable</span> <span class="n">portions</span> <span class="n">of</span> <span class="n">certain</span> <span class="kr">function</span>
      <span class="n">or</span> <span class="kr">method</span> <span class="n">contracts</span><span class="p">,</span> <span class="n">at</span> <span class="n">their</span> <span class="n">call</span> <span class="n">sites</span><span class="o">.</span> <span class="n">The</span> <span class="n">current</span> <span class="n">implementation</span>
      <span class="n">focuses</span> <span class="n">on</span> <span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span> <span class="n">code</span> <span class="n">but</span> <span class="n">may</span> <span class="n">support</span> <span class="n">other</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">future</span><span class="o">.</span>
  
      <span class="n">Externs</span> <span class="o">-</span> <span class="n">Check</span> <span class="n">contracts</span> <span class="n">on</span> <span class="n">every</span> <span class="n">call</span> <span class="kr">to</span> <span class="n">a</span> <span class="kr">function</span> <span class="n">or</span> <span class="kr">method</span> <span class="n">marked</span>
          <span class="n">with</span> <span class="n">the</span> <span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">regardless</span> <span class="n">of</span> <span class="n">where</span> <span class="n">it</span> <span class="n">occurs</span><span class="o">.</span>
      <span class="n">TestedExterns</span> <span class="o">-</span> <span class="n">Check</span> <span class="n">contracts</span> <span class="n">on</span> <span class="n">every</span> <span class="n">call</span> <span class="kr">to</span> <span class="n">a</span> <span class="kr">function</span> <span class="n">or</span> <span class="kr">method</span>
          <span class="n">marked</span> <span class="n">with</span> <span class="n">the</span> <span class="p">{</span><span class="o">:</span><span class="n">extern</span><span class="p">}</span> <span class="n">attribute</span> <span class="n">when</span> <span class="n">it</span> <span class="n">occurs</span> <span class="ow">in</span> <span class="n">a</span> <span class="kr">method</span>
          <span class="n">with</span> <span class="n">the</span> <span class="p">{</span><span class="o">:</span><span class="n">test</span><span class="p">}</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">and</span> <span class="n">warn</span> <span class="kr">if</span> <span class="n">no</span> <span class="n">corresponding</span> <span class="n">test</span>
          <span class="kr">exists</span> <span class="kr">for</span> <span class="n">a</span> <span class="n">given</span> <span class="n">external</span> <span class="n">declaration</span><span class="o">.</span>
  
  <span class="o">----------------------------------------------------------------------------</span>
  
  <span class="n">Dafny</span> <span class="n">generally</span> <span class="n">accepts</span> <span class="n">Boogie</span> <span class="n">options</span> <span class="n">and</span> <span class="n">passes</span> <span class="n">these</span> <span class="n">on</span> <span class="kr">to</span> <span class="n">Boogie</span><span class="o">.</span>
  <span class="n">However</span><span class="p">,</span> <span class="n">some</span> <span class="n">Boogie</span> <span class="n">options</span><span class="p">,</span> <span class="n">like</span> <span class="o">/</span><span class="n">loopUnroll</span><span class="p">,</span> <span class="n">may</span> <span class="n">not</span> <span class="n">be</span> <span class="n">sound</span> <span class="kr">for</span>
  <span class="n">Dafny</span> <span class="n">or</span> <span class="n">may</span> <span class="n">not</span> <span class="n">have</span> <span class="n">the</span> <span class="n">same</span> <span class="n">meaning</span> <span class="kr">for</span> <span class="n">a</span> <span class="n">Dafny</span> <span class="n">program</span> <span class="ow">as</span> <span class="n">it</span> <span class="n">would</span>
  <span class="kr">for</span> <span class="n">a</span> <span class="n">similar</span> <span class="n">Boogie</span> <span class="n">program</span><span class="o">.</span>
  
  <span class="o">----</span> <span class="n">Boogie</span> <span class="n">options</span> <span class="o">--------------------------------------------------------</span>

  <span class="n">Multiple</span> <span class="o">.</span><span class="n">bpl</span> <span class="n">files</span> <span class="n">supplied</span> <span class="n">on</span> <span class="n">the</span> <span class="n">command</span> <span class="n">line</span> <span class="n">are</span> <span class="n">concatenated</span> <span class="n">into</span> <span class="n">one</span>
  <span class="n">Boogie</span> <span class="n">program</span><span class="o">.</span>

  <span class="o">/</span><span class="n">lib</span><span class="o">:&lt;</span><span class="n">name</span><span class="o">&gt;</span>   <span class="n">Include</span> <span class="n">definitions</span> <span class="ow">in</span> <span class="n">library</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;.</span> <span class="n">The</span> <span class="n">file</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;.</span><span class="n">bpl</span>
                <span class="n">must</span> <span class="n">be</span> <span class="n">an</span> <span class="n">included</span> <span class="n">resource</span> <span class="ow">in</span> <span class="n">Core</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span> <span class="n">Currently</span><span class="p">,</span> <span class="n">the</span>
                <span class="n">following</span> <span class="n">libraries</span> <span class="n">are</span> <span class="n">supported</span><span class="o">---</span><span class="n">base</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span>
  <span class="o">/</span><span class="n">proc</span><span class="o">:&lt;</span><span class="n">p</span><span class="o">&gt;</span>     <span class="n">Only</span> <span class="n">check</span> <span class="n">procedures</span> <span class="n">matched</span> <span class="kr">by</span> <span class="n">pattern</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;.</span> <span class="n">This</span> <span class="n">option</span>
                <span class="n">may</span> <span class="n">be</span> <span class="n">specified</span> <span class="n">multiple</span> <span class="n">times</span> <span class="kr">to</span> <span class="kr">match</span> <span class="n">multiple</span> <span class="n">patterns</span><span class="o">.</span>
                <span class="n">The</span> <span class="n">pattern</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="n">matches</span> <span class="n">the</span> <span class="n">whole</span> <span class="n">procedure</span> <span class="n">name</span> <span class="n">and</span> <span class="n">may</span>
                <span class="n">contain</span> <span class="o">*</span> <span class="n">wildcards</span> <span class="n">which</span> <span class="kr">match</span> <span class="n">any</span> <span class="n">character</span> <span class="n">zero</span> <span class="n">or</span> <span class="n">more</span>
                <span class="n">times</span><span class="o">.</span>
  <span class="o">/</span><span class="n">noProc</span><span class="o">:&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="n">Do</span> <span class="n">not</span> <span class="n">check</span> <span class="n">procedures</span> <span class="n">matched</span> <span class="kr">by</span> <span class="n">pattern</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;.</span> <span class="n">Exclusions</span>
                <span class="n">with</span> <span class="o">/</span><span class="n">noProc</span> <span class="n">are</span> <span class="n">applied</span> <span class="n">after</span> <span class="n">inclusions</span> <span class="n">with</span> <span class="o">/</span><span class="n">proc</span><span class="o">.</span>
  <span class="o">/</span><span class="n">noResolve</span>    <span class="n">parse</span> <span class="n">only</span>
  <span class="o">/</span><span class="n">noTypecheck</span>  <span class="n">parse</span> <span class="n">and</span> <span class="n">resolve</span> <span class="n">only</span>
  <span class="o">/</span><span class="kr">print</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>
                <span class="kr">print</span> <span class="n">Boogie</span> <span class="n">program</span> <span class="n">after</span> <span class="n">parsing</span> <span class="n">it</span>
                <span class="p">(</span><span class="n">use</span> <span class="o">-</span> <span class="ow">as</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span> <span class="kr">to</span> <span class="kr">print</span> <span class="kr">to</span> <span class="n">console</span><span class="p">)</span>
  <span class="o">/</span><span class="n">pretty</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>   <span class="mi">0</span> <span class="o">-</span> <span class="kr">print</span> <span class="n">each</span> <span class="n">Boogie</span> <span class="n">statement</span> <span class="n">on</span> <span class="n">one</span> <span class="n">line</span> <span class="p">(</span><span class="n">faster</span><span class="p">)</span><span class="o">.</span>
                <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">pretty</span><span class="o">-</span><span class="kr">print</span> <span class="n">with</span> <span class="n">some</span> <span class="n">line</span> <span class="n">breaks</span><span class="o">.</span>
  <span class="o">/</span><span class="n">printWithUniqueIds</span>
                <span class="kr">print</span> <span class="n">augmented</span> <span class="n">information</span> <span class="n">that</span> <span class="n">uniquely</span> <span class="n">identifies</span> <span class="n">variables</span>
  <span class="o">/</span><span class="n">printUnstructured</span>
                <span class="n">with</span> <span class="o">/</span><span class="kr">print</span> <span class="n">option</span><span class="p">,</span> <span class="n">desugars</span> <span class="n">all</span> <span class="n">structured</span> <span class="n">statements</span>
  <span class="o">/</span><span class="n">printPassive</span>
                <span class="n">with</span> <span class="o">/</span><span class="kr">print</span> <span class="n">option</span><span class="p">,</span> <span class="n">prints</span> <span class="n">passive</span> <span class="n">version</span> <span class="n">of</span> <span class="n">program</span>
  <span class="o">/</span><span class="n">printDesugared</span>
                <span class="n">with</span> <span class="o">/</span><span class="kr">print</span> <span class="n">option</span><span class="p">,</span> <span class="n">desugars</span> <span class="n">calls</span>
  <span class="o">/</span><span class="n">printLambdaLifting</span>
                <span class="n">with</span> <span class="o">/</span><span class="kr">print</span> <span class="n">option</span><span class="p">,</span> <span class="n">desugars</span> <span class="n">lambda</span> <span class="n">lifting</span>
  <span class="o">/</span><span class="n">freeVarLambdaLifting</span>
                <span class="n">Boogie's</span> <span class="n">lambda</span> <span class="n">lifting</span> <span class="n">transforms</span> <span class="n">the</span> <span class="n">bodies</span> <span class="n">of</span> <span class="n">lambda</span>
                <span class="n">expressions</span> <span class="n">into</span> <span class="n">templates</span> <span class="n">with</span> <span class="n">holes</span><span class="o">.</span> <span class="n">By</span> <span class="n">default</span><span class="p">,</span> <span class="n">holes</span>
                <span class="n">are</span> <span class="n">maximally</span> <span class="n">large</span> <span class="n">subexpressions</span> <span class="n">that</span> <span class="n">do</span> <span class="n">not</span> <span class="n">contain</span>
                <span class="n">bound</span> <span class="n">variables</span><span class="o">.</span> <span class="n">This</span> <span class="n">option</span> <span class="n">performs</span> <span class="n">a</span> <span class="n">form</span> <span class="n">of</span> <span class="n">lambda</span>
                <span class="n">lifting</span> <span class="ow">in</span> <span class="n">which</span> <span class="n">holes</span> <span class="n">are</span> <span class="n">the</span> <span class="n">lambda's</span> <span class="n">free</span> <span class="n">variables</span><span class="o">.</span>
  <span class="o">/</span><span class="n">overlookTypeErrors</span>
                <span class="n">skip</span> <span class="n">any</span> <span class="n">implementation</span> <span class="n">with</span> <span class="n">resolution</span> <span class="n">or</span> <span class="kr">type</span> <span class="n">checking</span> <span class="n">errors</span>
  <span class="o">/</span><span class="n">loopUnroll</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">unroll</span> <span class="n">loops</span><span class="p">,</span> <span class="n">following</span> <span class="n">up</span> <span class="kr">to</span> <span class="n">n</span> <span class="n">back</span> <span class="n">edges</span> <span class="p">(</span><span class="n">and</span> <span class="kr">then</span> <span class="n">some</span><span class="p">)</span>
                <span class="n">default</span> <span class="ow">is</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">which</span> <span class="n">means</span> <span class="n">loops</span> <span class="n">are</span> <span class="n">not</span> <span class="n">unrolled</span>
  <span class="o">/</span><span class="n">extractLoops</span>
                <span class="n">convert</span> <span class="n">all</span> <span class="n">irreducible</span> <span class="n">loops</span> <span class="kr">to</span> <span class="n">reducible</span> <span class="n">forms</span> <span class="kr">by</span> <span class="n">node</span> <span class="n">splitting</span>
                <span class="n">and</span> <span class="n">extract</span> <span class="n">all</span> <span class="n">loops</span> <span class="n">into</span> <span class="n">recursive</span> <span class="n">procedures</span>
  <span class="o">/</span><span class="n">soundLoopUnrolling</span>
                <span class="n">sound</span> <span class="n">loop</span> <span class="n">unrolling</span>
  <span class="o">/</span><span class="n">kInductionDepth</span><span class="o">:&lt;</span><span class="n">k</span><span class="o">&gt;</span>
                <span class="n">uses</span> <span class="n">combined</span><span class="o">-</span><span class="kr">case</span> <span class="n">k</span><span class="o">-</span><span class="n">induction</span> <span class="kr">to</span> <span class="n">soundly</span> <span class="n">eliminate</span> <span class="n">loops</span><span class="p">,</span>
                <span class="kr">by</span> <span class="n">unwinding</span> <span class="n">proportional</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">supplied</span> <span class="n">parameter</span>
  <span class="o">/</span><span class="n">inferModifies</span>
                <span class="n">automatically</span> <span class="n">infer</span> <span class="kr">modifies</span> <span class="n">clauses</span>
  <span class="o">/</span><span class="n">printModel</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">do</span> <span class="n">not</span> <span class="kr">print</span> <span class="n">Z3's</span> <span class="n">error</span> <span class="n">model</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="kr">print</span> <span class="n">Z3's</span> <span class="n">error</span> <span class="n">model</span>
  <span class="o">/</span><span class="n">printModelToFile</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>
                <span class="kr">print</span> <span class="n">model</span> <span class="kr">to</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">console</span>
  <span class="o">/</span><span class="n">mv</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>    <span class="n">Specify</span> <span class="n">file</span> <span class="kr">to</span> <span class="n">save</span> <span class="n">the</span> <span class="n">model</span> <span class="n">with</span> <span class="n">captured</span> <span class="n">states</span>
                <span class="p">(</span><span class="n">see</span> <span class="n">documentation</span> <span class="kr">for</span> <span class="o">:</span><span class="n">captureState</span> <span class="n">attribute</span><span class="p">)</span>
  <span class="o">/</span><span class="n">enhancedErrorMessages</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">no</span> <span class="n">enhanced</span> <span class="n">error</span> <span class="n">messages</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="n">Z3</span> <span class="n">error</span> <span class="n">model</span> <span class="n">enhanced</span> <span class="n">error</span> <span class="n">messages</span>
  <span class="o">/</span><span class="n">printCFG</span><span class="o">:&lt;</span><span class="n">prefix</span><span class="o">&gt;</span> <span class="o">:</span> <span class="kr">print</span> <span class="n">control</span> <span class="n">flow</span> <span class="n">graph</span> <span class="n">of</span> <span class="n">each</span> <span class="n">implementation</span> <span class="ow">in</span>
                       <span class="n">Graphviz</span> <span class="n">format</span> <span class="kr">to</span> <span class="n">files</span> <span class="n">named</span><span class="o">:</span>
                         <span class="o">&lt;</span><span class="n">prefix</span><span class="o">&gt;.&lt;</span><span class="n">procedure</span> <span class="n">name</span><span class="o">&gt;.</span><span class="n">dot</span>
  <span class="o">/</span><span class="n">useBaseNameForFileName</span> <span class="o">:</span> <span class="n">When</span> <span class="n">parsing</span> <span class="n">use</span> <span class="n">basename</span> <span class="n">of</span> <span class="n">file</span> <span class="kr">for</span> <span class="n">tokens</span> <span class="n">instead</span>
                            <span class="n">of</span> <span class="n">the</span> <span class="n">path</span> <span class="n">supplied</span> <span class="n">on</span> <span class="n">the</span> <span class="n">command</span> <span class="n">line</span>
  <span class="o">/</span><span class="n">emitDebugInformation</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="n">do</span> <span class="n">not</span> <span class="n">emit</span> <span class="n">debug</span> <span class="n">information</span>
                <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">emit</span> <span class="n">the</span> <span class="n">debug</span> <span class="n">information</span> <span class="o">:</span><span class="n">qid</span><span class="p">,</span> <span class="o">:</span><span class="n">skolemid</span> <span class="n">and</span> <span class="kt">set</span><span class="o">-</span><span class="n">info</span> <span class="o">:</span><span class="n">boogie</span><span class="o">-</span><span class="n">vc</span><span class="o">-</span><span class="n">id</span>
  <span class="o">/</span><span class="n">normalizeNames</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Keep</span> <span class="n">Boogie</span> <span class="n">program</span> <span class="n">names</span> <span class="n">when</span> <span class="n">generating</span> <span class="n">SMT</span> <span class="n">commands</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="n">Normalize</span> <span class="n">Boogie</span> <span class="n">program</span> <span class="n">names</span> <span class="n">when</span> <span class="n">generating</span> <span class="n">SMT</span> <span class="n">commands</span><span class="o">.</span> 
                  <span class="n">This</span> <span class="n">keeps</span> <span class="n">SMT</span> <span class="n">solver</span> <span class="n">input</span><span class="p">,</span> <span class="n">and</span> <span class="n">thus</span> <span class="n">output</span><span class="p">,</span> 
                  <span class="n">constant</span> <span class="n">when</span> <span class="n">renaming</span> <span class="n">declarations</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">input</span> <span class="n">program</span><span class="o">.</span>
  <span class="o">/</span><span class="n">normalizeDeclarationOrder</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="n">Keep</span> <span class="n">order</span> <span class="n">of</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="n">declarations</span> <span class="n">when</span> <span class="n">generating</span> <span class="n">SMT</span> <span class="n">commands</span><span class="o">.</span>
                <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">Normalize</span> <span class="n">order</span> <span class="n">of</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="n">declarations</span> <span class="n">when</span> <span class="n">generating</span> <span class="n">SMT</span> <span class="n">commands</span><span class="o">.</span>
                  <span class="n">This</span> <span class="n">keeps</span> <span class="n">SMT</span> <span class="n">solver</span> <span class="n">input</span><span class="p">,</span> <span class="n">and</span> <span class="n">thus</span> <span class="n">output</span><span class="p">,</span> 
                  <span class="n">constant</span> <span class="n">when</span> <span class="n">reordering</span> <span class="n">declarations</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">input</span> <span class="n">program</span><span class="o">.</span>

  <span class="o">----</span> <span class="n">Inference</span> <span class="n">options</span> <span class="o">-----------------------------------------------------</span>

  <span class="o">/</span><span class="n">infer</span><span class="o">:&lt;</span><span class="n">flags</span><span class="o">&gt;</span>
                <span class="n">use</span> <span class="kr">abstract</span> <span class="n">interpretation</span> <span class="kr">to</span> <span class="n">infer</span> <span class="n">invariants</span>
                <span class="o">&lt;</span><span class="n">flags</span><span class="o">&gt;</span> <span class="n">must</span> <span class="n">specify</span> <span class="n">exactly</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">following</span> <span class="n">domains</span><span class="o">:</span>
                   <span class="n">t</span> <span class="o">=</span> <span class="n">trivial</span> <span class="n">bottom</span><span class="o">/</span><span class="n">top</span> <span class="n">lattice</span>
                   <span class="n">j</span> <span class="o">=</span> <span class="n">stronger</span> <span class="n">intervals</span>
                <span class="n">together</span> <span class="n">with</span> <span class="n">any</span> <span class="n">of</span> <span class="n">the</span> <span class="n">following</span> <span class="n">options</span><span class="o">:</span>
                   <span class="n">s</span> <span class="o">=</span> <span class="n">debug</span> <span class="n">statistics</span>
                <span class="mi">0</span><span class="o">..</span><span class="mi">9</span> <span class="o">=</span> <span class="n">number</span> <span class="n">of</span> <span class="n">iterations</span> <span class="n">before</span> <span class="n">applying</span> <span class="n">a</span> <span class="n">widen</span> <span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="o">/</span><span class="n">checkInfer</span>   <span class="n">instrument</span> <span class="n">inferred</span> <span class="n">invariants</span> <span class="ow">as</span> <span class="n">asserts</span> <span class="kr">to</span> <span class="n">be</span> <span class="n">checked</span> <span class="kr">by</span>
                <span class="n">theorem</span> <span class="n">prover</span>
  <span class="o">/</span><span class="n">contractInfer</span>
                <span class="n">perform</span> <span class="n">procedure</span> <span class="n">contract</span> <span class="n">inference</span>
  <span class="o">/</span><span class="n">instrumentInfer</span>
                <span class="n">h</span> <span class="o">-</span> <span class="n">instrument</span> <span class="n">inferred</span> <span class="n">invariants</span> <span class="n">only</span> <span class="n">at</span> <span class="n">beginning</span> <span class="n">of</span>
                    <span class="n">loop</span> <span class="n">headers</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span>
                <span class="n">e</span> <span class="o">-</span> <span class="n">instrument</span> <span class="n">inferred</span> <span class="n">invariants</span> <span class="n">at</span> <span class="n">beginning</span> <span class="n">and</span> <span class="n">end</span>
                    <span class="n">of</span> <span class="n">every</span> <span class="n">block</span> <span class="p">(</span><span class="kr">this</span> <span class="n">mode</span> <span class="ow">is</span> <span class="n">intended</span> <span class="kr">for</span> <span class="n">use</span> <span class="ow">in</span>
                    <span class="n">debugging</span> <span class="n">of</span> <span class="kr">abstract</span> <span class="n">domains</span><span class="p">)</span>
  <span class="o">/</span><span class="n">printInstrumented</span>
                <span class="kr">print</span> <span class="n">Boogie</span> <span class="n">program</span> <span class="n">after</span> <span class="n">it</span> <span class="n">has</span> <span class="n">been</span> <span class="n">instrumented</span> <span class="n">with</span>
                <span class="n">invariants</span>

  <span class="o">----</span> <span class="n">Debugging</span> <span class="n">and</span> <span class="n">general</span> <span class="n">tracing</span> <span class="n">options</span> <span class="o">---------------------------------</span>

  <span class="o">/</span><span class="n">silent</span>       <span class="kr">print</span> <span class="n">nothing</span> <span class="n">at</span> <span class="n">all</span>
  <span class="o">/</span><span class="n">quiet</span>        <span class="kr">print</span> <span class="n">nothing</span> <span class="n">but</span> <span class="n">warnings</span> <span class="n">and</span> <span class="n">errors</span>
  <span class="o">/</span><span class="n">trace</span>        <span class="n">blurt</span> <span class="n">out</span> <span class="n">various</span> <span class="n">debug</span> <span class="n">trace</span> <span class="n">information</span>
  <span class="o">/</span><span class="n">traceTimes</span>   <span class="n">output</span> <span class="n">timing</span> <span class="n">information</span> <span class="n">at</span> <span class="n">certain</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">pipeline</span>
  <span class="o">/</span><span class="n">tracePOs</span>     <span class="n">output</span> <span class="n">information</span> <span class="n">about</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">proof</span> <span class="n">obligations</span>
                <span class="p">(</span><span class="n">also</span> <span class="n">included</span> <span class="ow">in</span> <span class="n">the</span> <span class="o">/</span><span class="n">trace</span> <span class="n">output</span><span class="p">)</span>
  <span class="o">/</span><span class="n">forceBplErrors</span>
                <span class="n">show</span> <span class="n">boogie</span> <span class="n">errors</span> <span class="n">even</span> <span class="kr">if</span> <span class="p">{</span><span class="o">:</span><span class="n">msg</span> <span class="o">...</span><span class="p">}</span> <span class="n">attribute</span> <span class="ow">is</span> <span class="n">present</span>
  <span class="o">/</span><span class="kr">break</span>        <span class="n">launch</span> <span class="n">and</span> <span class="kr">break</span> <span class="n">into</span> <span class="n">debugger</span>

  <span class="o">----</span> <span class="n">Civl</span> <span class="n">options</span> <span class="o">----------------------------------------------------------</span>

  <span class="o">/</span><span class="n">trustMoverTypes</span>
                <span class="n">do</span> <span class="n">not</span> <span class="n">verify</span> <span class="n">mover</span> <span class="kr">type</span> <span class="n">annotations</span> <span class="n">on</span> <span class="n">atomic</span> <span class="n">action</span> <span class="n">declarations</span>
  <span class="o">/</span><span class="n">trustNoninterference</span>
                <span class="n">do</span> <span class="n">not</span> <span class="n">perform</span> <span class="n">noninterference</span> <span class="n">checks</span>
  <span class="o">/</span><span class="n">trustRefinement</span>
                <span class="n">do</span> <span class="n">not</span> <span class="n">perform</span> <span class="n">refinement</span> <span class="n">checks</span>
  <span class="o">/</span><span class="n">trustLayersUpto</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">do</span> <span class="n">not</span> <span class="n">verify</span> <span class="n">layers</span> <span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span> <span class="n">and</span> <span class="n">below</span>
  <span class="o">/</span><span class="n">trustLayersDownto</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">do</span> <span class="n">not</span> <span class="n">verify</span> <span class="n">layers</span> <span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span> <span class="n">and</span> <span class="n">above</span>
  <span class="o">/</span><span class="n">trustSequentialization</span>
                <span class="n">do</span> <span class="n">not</span> <span class="n">perform</span> <span class="n">sequentialization</span> <span class="n">checks</span>
  <span class="o">/</span><span class="n">civlDesugaredFile</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>
                <span class="kr">print</span> <span class="n">plain</span> <span class="n">Boogie</span> <span class="n">program</span> <span class="kr">to</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span>

  <span class="o">----</span> <span class="n">Verification</span><span class="o">-</span><span class="n">condition</span> <span class="n">generation</span> <span class="n">options</span> <span class="o">-----------------------------</span>

  <span class="o">/</span><span class="n">liveVariableAnalysis</span><span class="o">:&lt;</span><span class="n">c</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="o">=</span> <span class="n">do</span> <span class="n">not</span> <span class="n">perform</span> <span class="n">live</span> <span class="n">variable</span> <span class="n">analysis</span>
                <span class="mi">1</span> <span class="o">=</span> <span class="n">perform</span> <span class="n">live</span> <span class="n">variable</span> <span class="n">analysis</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span>
                <span class="mi">2</span> <span class="o">=</span> <span class="n">perform</span> <span class="n">interprocedural</span> <span class="n">live</span> <span class="n">variable</span> <span class="n">analysis</span>
  <span class="o">/</span><span class="n">noVerify</span>     <span class="n">skip</span> <span class="n">VC</span> <span class="n">generation</span> <span class="n">and</span> <span class="n">invocation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">theorem</span> <span class="n">prover</span>
  <span class="o">/</span><span class="n">verifySnapshots</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">verify</span> <span class="n">several</span> <span class="n">program</span> <span class="n">snapshots</span> <span class="p">(</span><span class="n">named</span> <span class="o">&lt;</span><span class="n">filename</span><span class="o">&gt;.</span><span class="n">v0</span><span class="o">.</span><span class="n">bpl</span>
                <span class="kr">to</span> <span class="o">&lt;</span><span class="n">filename</span><span class="o">&gt;.</span><span class="n">vN</span><span class="o">.</span><span class="n">bpl</span><span class="p">)</span> <span class="n">using</span> <span class="n">verification</span> <span class="n">result</span> <span class="n">caching</span><span class="o">:</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="n">do</span> <span class="n">not</span> <span class="n">use</span> <span class="n">any</span> <span class="n">verification</span> <span class="n">result</span> <span class="n">caching</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="n">use</span> <span class="n">the</span> <span class="n">basic</span> <span class="n">verification</span> <span class="n">result</span> <span class="n">caching</span>
                <span class="mi">2</span> <span class="o">-</span> <span class="n">use</span> <span class="n">the</span> <span class="n">more</span> <span class="n">advanced</span> <span class="n">verification</span> <span class="n">result</span> <span class="n">caching</span>
                <span class="mi">3</span> <span class="o">-</span> <span class="n">use</span> <span class="n">the</span> <span class="n">more</span> <span class="n">advanced</span> <span class="n">caching</span> <span class="n">and</span> <span class="n">report</span> <span class="n">errors</span> <span class="n">according</span>
                    <span class="kr">to</span> <span class="n">the</span> <span class="kr">new</span> <span class="n">source</span> <span class="n">locations</span> <span class="kr">for</span> <span class="n">errors</span> <span class="n">and</span> <span class="n">their</span>
                    <span class="n">related</span> <span class="n">locations</span> <span class="p">(</span><span class="n">but</span> <span class="n">not</span> <span class="o">/</span><span class="n">errorTrace</span> <span class="n">and</span> <span class="n">CaptureState</span>
                    <span class="n">locations</span><span class="p">)</span>
  <span class="o">/</span><span class="n">traceCaching</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">none</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="kr">for</span> <span class="n">testing</span>
                <span class="mi">2</span> <span class="o">-</span> <span class="kr">for</span> <span class="n">benchmarking</span>
                <span class="mi">3</span> <span class="o">-</span> <span class="kr">for</span> <span class="n">testing</span><span class="p">,</span> <span class="n">benchmarking</span><span class="p">,</span> <span class="n">and</span> <span class="n">debugging</span>
  <span class="o">/</span><span class="n">verifySeparately</span>
                <span class="n">verify</span> <span class="n">each</span> <span class="n">input</span> <span class="n">program</span> <span class="n">separately</span>
  <span class="o">/</span><span class="n">removeEmptyBlocks</span><span class="o">:&lt;</span><span class="n">c</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="n">do</span> <span class="n">not</span> <span class="n">remove</span> <span class="n">empty</span> <span class="n">blocks</span> <span class="n">during</span> <span class="n">VC</span> <span class="n">generation</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="n">remove</span> <span class="n">empty</span> <span class="n">blocks</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span>
  <span class="o">/</span><span class="n">coalesceBlocks</span><span class="o">:&lt;</span><span class="n">c</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="o">=</span> <span class="n">do</span> <span class="n">not</span> <span class="n">coalesce</span> <span class="n">blocks</span>
                <span class="mi">1</span> <span class="o">=</span> <span class="n">coalesce</span> <span class="n">blocks</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span>
  <span class="o">/</span><span class="n">traceverify</span>  <span class="kr">print</span> <span class="n">debug</span> <span class="n">output</span> <span class="n">during</span> <span class="n">verification</span> <span class="n">condition</span> <span class="n">generation</span>
  <span class="o">/</span><span class="n">subsumption</span><span class="o">:&lt;</span><span class="n">c</span><span class="o">&gt;</span>
                <span class="n">apply</span> <span class="n">subsumption</span> <span class="kr">to</span> <span class="n">asserted</span> <span class="n">conditions</span><span class="o">:</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="n">never</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">not</span> <span class="kr">for</span> <span class="n">quantifiers</span><span class="p">,</span> <span class="mi">2</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">always</span>
  <span class="o">/</span><span class="n">alwaysAssumeFreeLoopInvariants</span>
                <span class="n">usually</span><span class="p">,</span> <span class="n">a</span> <span class="n">free</span> <span class="n">loop</span> <span class="kr">invariant</span> <span class="p">(</span><span class="n">or</span> <span class="kr">assume</span>
                <span class="n">statement</span> <span class="ow">in</span> <span class="n">that</span> <span class="n">position</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ignored</span> <span class="ow">in</span> <span class="n">checking</span> <span class="n">contexts</span>
                <span class="p">(</span><span class="n">like</span> <span class="n">other</span> <span class="n">free</span> <span class="n">things</span><span class="p">);</span> <span class="kr">this</span> <span class="n">option</span> <span class="n">includes</span> <span class="n">these</span> <span class="n">free</span>
                <span class="n">loop</span> <span class="n">invariants</span> <span class="ow">as</span> <span class="n">assumes</span> <span class="ow">in</span> <span class="n">both</span> <span class="n">contexts</span>
  <span class="o">/</span><span class="n">inline</span><span class="o">:&lt;</span><span class="n">i</span><span class="o">&gt;</span>   <span class="n">use</span> <span class="n">inlining</span> <span class="n">strategy</span> <span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span> <span class="kr">for</span> <span class="n">procedures</span> <span class="n">with</span> <span class="n">the</span> <span class="o">:</span><span class="n">inline</span>
                <span class="n">attribute</span><span class="p">,</span> <span class="n">see</span> <span class="o">/</span><span class="n">attrHelp</span> <span class="kr">for</span> <span class="n">details</span><span class="o">:</span>
                  <span class="n">none</span>
                  <span class="kr">assume</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span>
                  <span class="kr">assert</span>
                  <span class="n">spec</span>
  <span class="o">/</span><span class="n">printInlined</span>
                <span class="kr">print</span> <span class="n">the</span> <span class="n">implementation</span> <span class="n">after</span> <span class="n">inlining</span> <span class="n">calls</span> <span class="kr">to</span>
                <span class="n">procedures</span> <span class="n">with</span> <span class="n">the</span> <span class="o">:</span><span class="n">inline</span> <span class="n">attribute</span> <span class="p">(</span><span class="n">works</span> <span class="n">with</span> <span class="o">/</span><span class="n">inline</span><span class="p">)</span>
  <span class="o">/</span><span class="n">recursionBound</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">Set</span> <span class="n">the</span> <span class="n">recursion</span> <span class="n">bound</span> <span class="kr">for</span> <span class="n">stratified</span> <span class="n">inlining</span> <span class="kr">to</span>
                <span class="n">be</span> <span class="n">n</span> <span class="p">(</span><span class="n">default</span> <span class="mi">500</span><span class="p">)</span>
  <span class="o">/</span><span class="n">smoke</span>        <span class="n">Soundness</span> <span class="n">Smoke</span> <span class="n">Test</span><span class="o">:</span> <span class="n">try</span> <span class="kr">to</span> <span class="n">stick</span> <span class="kr">assert</span> <span class="kc">false</span><span class="p">;</span> <span class="ow">in</span> <span class="n">some</span>
                <span class="n">places</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">BPL</span> <span class="n">and</span> <span class="n">see</span> <span class="kr">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">still</span> <span class="n">prove</span> <span class="n">it</span>
  <span class="o">/</span><span class="n">smokeTimeout</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">Timeout</span><span class="p">,</span> <span class="ow">in</span> <span class="n">seconds</span><span class="p">,</span> <span class="kr">for</span> <span class="n">a</span> <span class="n">single</span> <span class="n">theorem</span> <span class="n">prover</span>
                <span class="n">invocation</span> <span class="n">during</span> <span class="n">smoke</span> <span class="n">test</span><span class="p">,</span> <span class="n">defaults</span> <span class="kr">to</span> <span class="mi">10</span><span class="o">.</span>
  <span class="o">/</span><span class="n">typeEncoding</span><span class="o">:&lt;</span><span class="n">t</span><span class="o">&gt;</span>
                <span class="n">Encoding</span> <span class="n">of</span> <span class="n">types</span> <span class="n">when</span> <span class="n">generating</span> <span class="n">VC</span> <span class="n">of</span> <span class="n">a</span> <span class="n">polymorphic</span> <span class="n">program</span><span class="o">:</span>
                   <span class="n">m</span> <span class="o">=</span> <span class="n">monomorphic</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span>
                   <span class="n">p</span> <span class="o">=</span> <span class="n">predicates</span>
                   <span class="n">a</span> <span class="o">=</span> <span class="n">arguments</span>
                <span class="n">Boogie</span> <span class="n">automatically</span> <span class="n">detects</span> <span class="n">monomorphic</span> <span class="n">programs</span> <span class="n">and</span> <span class="n">enables</span>
                <span class="n">monomorphic</span> <span class="n">VC</span> <span class="n">generation</span><span class="p">,</span> <span class="n">thereby</span> <span class="n">overriding</span> <span class="n">the</span> <span class="n">above</span> <span class="n">option</span><span class="o">.</span>
                <span class="n">If</span> <span class="n">the</span> <span class="n">latter</span> <span class="n">two</span> <span class="n">options</span> <span class="n">are</span> <span class="n">used</span><span class="p">,</span> <span class="kr">then</span> <span class="n">arrays</span> <span class="n">are</span> <span class="n">handled</span> <span class="n">via</span> <span class="n">axioms</span><span class="o">.</span>
  <span class="o">/</span><span class="n">useArrayAxioms</span>
                <span class="n">If</span> <span class="n">monomorphic</span> <span class="kr">type</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="n">used</span><span class="p">,</span> <span class="n">arrays</span> <span class="n">are</span> <span class="n">handled</span> <span class="kr">by</span> <span class="n">default</span> <span class="n">with</span>
                <span class="n">the</span> <span class="n">SMT</span> <span class="n">theory</span> <span class="n">of</span> <span class="n">arrays</span><span class="o">.</span> <span class="n">This</span> <span class="n">option</span> <span class="n">allows</span> <span class="n">the</span> <span class="n">use</span> <span class="n">of</span> <span class="n">axioms</span> <span class="n">instead</span><span class="o">.</span>
  <span class="o">/</span><span class="n">reflectAdd</span>   <span class="n">In</span> <span class="n">the</span> <span class="n">VC</span><span class="p">,</span> <span class="n">generate</span> <span class="n">an</span> <span class="n">auxiliary</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">elsewhere</span> <span class="n">defined</span>
                <span class="kr">to</span> <span class="n">be</span> <span class="o">+</span><span class="p">,</span> <span class="n">instead</span> <span class="n">of</span> <span class="o">+.</span>
  <span class="o">/</span><span class="n">prune</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="n">Turn</span> <span class="n">off</span> <span class="n">pruning</span><span class="o">.</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="n">Turn</span> <span class="n">on</span> <span class="n">pruning</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span><span class="o">.</span> <span class="n">Pruning</span> <span class="n">will</span> <span class="n">remove</span> <span class="n">any</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span>
                <span class="n">Boogie</span> <span class="n">declarations</span> <span class="n">that</span> <span class="n">are</span> <span class="n">not</span> <span class="n">accessible</span> <span class="kr">by</span> <span class="n">the</span> <span class="n">implementation</span>
                <span class="n">that</span> <span class="ow">is</span> <span class="n">about</span> <span class="kr">to</span> <span class="n">be</span> <span class="n">verified</span><span class="o">.</span> <span class="n">Without</span> <span class="n">pruning</span><span class="p">,</span> <span class="n">due</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">unstable</span>
                <span class="n">nature</span> <span class="n">of</span> <span class="n">SMT</span> <span class="n">solvers</span><span class="p">,</span> <span class="n">a</span> <span class="n">change</span> <span class="kr">to</span> <span class="n">any</span> <span class="n">part</span> <span class="n">of</span> <span class="n">a</span> <span class="n">Boogie</span> <span class="n">program</span>
                <span class="n">has</span> <span class="n">the</span> <span class="n">potential</span> <span class="kr">to</span> <span class="n">affect</span> <span class="n">the</span> <span class="n">verification</span> <span class="n">of</span> <span class="n">any</span> <span class="n">other</span> <span class="n">part</span> <span class="n">of</span>
                <span class="n">the</span> <span class="n">program</span><span class="o">.</span>

                <span class="n">Only</span> <span class="n">use</span> <span class="kr">this</span> <span class="kr">if</span> <span class="n">your</span> <span class="n">program</span> <span class="n">contains</span> <span class="n">uses</span> <span class="n">clauses</span>
                <span class="n">where</span> <span class="n">required</span><span class="p">,</span> <span class="n">otherwise</span> <span class="n">pruning</span> <span class="n">will</span> <span class="kr">break</span> <span class="n">your</span> <span class="n">program</span><span class="o">.</span>
                <span class="n">More</span> <span class="n">information</span> <span class="n">can</span> <span class="n">be</span> <span class="n">found</span> <span class="n">here</span><span class="o">:</span> <span class="n">https</span><span class="o">:</span><span class="c1">//github.com/boogie-org/boogie/blob/afe8eb0ffbb48d593de1ae3bf89712246444daa8/Source/ExecutionEngine/CommandLineOptions.cs#L160</span>
  <span class="o">/</span><span class="n">printPruned</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>
                <span class="n">After</span> <span class="n">pruning</span><span class="p">,</span> <span class="kr">print</span> <span class="n">the</span> <span class="n">Boogie</span> <span class="n">program</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">file</span><span class="o">.</span>
  <span class="o">/</span><span class="n">relaxFocus</span>   <span class="n">Process</span> <span class="n">foci</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">bottom</span><span class="o">-</span><span class="n">up</span> <span class="n">fashion</span><span class="o">.</span> <span class="n">This</span> <span class="n">way</span> <span class="n">only</span> <span class="n">generates</span>
                <span class="n">a</span> <span class="n">linear</span> <span class="n">number</span> <span class="n">of</span> <span class="n">splits</span><span class="o">.</span> <span class="n">The</span> <span class="n">default</span> <span class="n">way</span> <span class="p">(</span><span class="n">top</span><span class="o">-</span><span class="n">down</span><span class="p">)</span> <span class="ow">is</span> <span class="n">more</span>
                <span class="n">aggressive</span> <span class="n">and</span> <span class="n">it</span> <span class="n">may</span> <span class="n">create</span> <span class="n">an</span> <span class="n">exponential</span> <span class="n">number</span> <span class="n">of</span> <span class="n">splits</span><span class="o">.</span>
  <span class="o">/</span><span class="n">randomSeed</span><span class="o">:&lt;</span><span class="n">s</span><span class="o">&gt;</span>
                <span class="n">Supply</span> <span class="n">the</span> <span class="n">random</span> <span class="n">seed</span> <span class="kr">for</span> <span class="o">/</span><span class="n">randomizeVcIterations</span> <span class="n">option</span><span class="o">.</span>
  <span class="o">/</span><span class="n">randomizeVcIterations</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">Turn</span> <span class="n">on</span> <span class="n">randomization</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">that</span> <span class="n">Boogie</span> <span class="n">passes</span> <span class="kr">to</span> <span class="n">the</span>
                <span class="n">SMT</span> <span class="n">solver</span> <span class="n">and</span> <span class="n">turn</span> <span class="n">on</span> <span class="n">randomization</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">SMT</span> <span class="n">solver</span> <span class="n">itself</span><span class="o">.</span>
                <span class="n">Attempt</span> <span class="kr">to</span> <span class="n">randomize</span> <span class="n">and</span> <span class="n">prove</span> <span class="n">each</span> <span class="n">VC</span> <span class="n">n</span> <span class="n">times</span> <span class="n">using</span> <span class="n">the</span> <span class="n">random</span>
                <span class="n">seed</span> <span class="n">s</span> <span class="n">provided</span> <span class="kr">by</span> <span class="n">the</span> <span class="n">option</span> <span class="o">/</span><span class="n">randomSeed</span><span class="o">:&lt;</span><span class="n">s</span><span class="o">&gt;.</span> <span class="n">If</span> <span class="o">/</span><span class="n">randomSeed</span> <span class="n">option</span>
                <span class="ow">is</span> <span class="n">not</span> <span class="n">provided</span><span class="p">,</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">chosen</span> <span class="kr">to</span> <span class="n">be</span> <span class="n">zero</span><span class="o">.</span>

                <span class="n">Certain</span> <span class="n">Boogie</span> <span class="n">inputs</span> <span class="n">are</span> <span class="n">unstable</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">sense</span> <span class="n">that</span> <span class="n">changes</span> <span class="kr">to</span> 
                <span class="n">the</span> <span class="n">input</span> <span class="n">that</span> <span class="n">preserve</span> <span class="n">its</span> <span class="n">meaning</span> <span class="n">may</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">output</span> <span class="kr">to</span> <span class="n">change</span><span class="o">.</span>
                <span class="n">This</span> <span class="n">option</span> <span class="n">simulates</span> <span class="n">meaning</span><span class="o">-</span><span class="n">preserving</span> <span class="n">changes</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">input</span>
                <span class="n">without</span> <span class="n">requiring</span> <span class="n">the</span> <span class="n">user</span> <span class="kr">to</span> <span class="n">actually</span> <span class="n">make</span> <span class="n">those</span> <span class="n">changes</span><span class="o">.</span>
                <span class="n">This</span> <span class="n">option</span> <span class="ow">is</span> <span class="n">implemented</span> <span class="kr">by</span> <span class="n">renaming</span> <span class="n">variables</span> <span class="n">and</span> <span class="n">reordering</span>
                <span class="n">declarations</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">input</span><span class="p">,</span> <span class="n">and</span> <span class="kr">by</span> <span class="n">setting</span> <span class="n">solver</span> <span class="n">options</span> <span class="n">that</span> <span class="n">have</span>
                <span class="n">similar</span> <span class="n">effects</span><span class="o">.</span>
  <span class="o">/</span><span class="n">trackVerificationCoverage</span>
                <span class="n">Track</span> <span class="n">and</span> <span class="n">report</span> <span class="n">which</span> <span class="n">program</span> <span class="n">elements</span> <span class="n">labeled</span> <span class="n">with</span> <span class="n">an</span>
                <span class="p">`{</span><span class="o">:</span><span class="n">id</span> <span class="o">...</span><span class="p">}`</span> <span class="n">attribute</span> <span class="n">were</span> <span class="n">necessary</span> <span class="kr">to</span> <span class="n">complete</span> <span class="n">verification</span><span class="o">.</span>
                <span class="n">Assumptions</span><span class="p">,</span> <span class="n">assertions</span><span class="p">,</span> <span class="kr">requires</span> <span class="n">clauses</span><span class="p">,</span> <span class="kr">ensures</span> <span class="n">clauses</span><span class="p">,</span>
                <span class="n">assignments</span><span class="p">,</span> <span class="n">and</span> <span class="n">calls</span> <span class="n">can</span> <span class="n">be</span> <span class="n">labeled</span> <span class="kr">for</span> <span class="n">inclusion</span> <span class="ow">in</span> <span class="kr">this</span>
                <span class="n">report</span><span class="o">.</span> <span class="n">This</span> <span class="n">generalizes</span> <span class="n">and</span> <span class="n">replaces</span> <span class="n">the</span> <span class="n">previous</span>
                <span class="p">(</span><span class="n">undocumented</span><span class="p">)</span> <span class="p">`</span><span class="o">/</span><span class="n">printNecessaryAssertions</span><span class="p">`</span> <span class="n">option</span><span class="o">.</span>
  <span class="o">/</span><span class="n">warnVacuousProofs</span>
                <span class="n">Automatically</span> <span class="n">add</span> <span class="n">missing</span> <span class="p">`{</span><span class="o">:</span><span class="n">id</span> <span class="o">...</span><span class="p">}`</span> <span class="n">attributes</span> <span class="kr">to</span> <span class="n">assumptions</span><span class="p">,</span>
                <span class="n">assertions</span><span class="p">,</span> <span class="kr">requires</span> <span class="n">clauses</span><span class="p">,</span> <span class="kr">ensures</span> <span class="n">clauses</span><span class="p">,</span> <span class="n">and</span> <span class="n">calls</span><span class="p">;</span> <span class="n">enable</span> <span class="n">the</span>
                <span class="p">`</span><span class="o">/</span><span class="n">trackVerificationCoverage</span><span class="p">`</span> <span class="n">option</span><span class="p">;</span> <span class="n">and</span> <span class="n">warn</span> <span class="n">when</span> <span class="n">proof</span> <span class="n">goals</span> <span class="n">are</span>
                <span class="n">not</span> <span class="n">covered</span> <span class="kr">by</span> <span class="n">a</span> <span class="n">proof</span><span class="o">.</span>
  <span class="o">/</span><span class="n">keepQuantifier</span>
                <span class="n">If</span> <span class="n">pool</span><span class="o">-</span><span class="n">based</span> <span class="n">quantifier</span> <span class="n">instantiation</span> <span class="n">creates</span> <span class="n">instances</span> <span class="n">of</span> <span class="n">a</span> <span class="n">quantifier</span>
                <span class="kr">then</span> <span class="n">keep</span> <span class="n">the</span> <span class="n">quantifier</span> <span class="n">along</span> <span class="n">with</span> <span class="n">the</span> <span class="n">instances</span><span class="o">.</span> <span class="n">By</span> <span class="n">default</span><span class="p">,</span> <span class="n">the</span> <span class="n">quantifier</span>
                <span class="ow">is</span> <span class="n">dropped</span> <span class="kr">if</span> <span class="n">any</span> <span class="n">instances</span> <span class="n">are</span> <span class="n">created</span><span class="o">.</span>

  <span class="o">----</span> <span class="n">Verification</span><span class="o">-</span><span class="n">condition</span> <span class="n">splitting</span> <span class="o">--------------------------------------</span>

  <span class="o">/</span><span class="n">vcsMaxCost</span><span class="o">:&lt;</span><span class="n">f</span><span class="o">&gt;</span>
                <span class="n">VC</span> <span class="n">will</span> <span class="n">not</span> <span class="n">be</span> <span class="n">split</span> <span class="n">unless</span> <span class="n">the</span> <span class="n">cost</span> <span class="n">of</span> <span class="n">a</span> <span class="n">VC</span> <span class="n">exceeds</span> <span class="kr">this</span>
                <span class="n">number</span><span class="p">,</span> <span class="n">defaults</span> <span class="kr">to</span> <span class="mf">2000.0</span><span class="o">.</span> <span class="n">This</span> <span class="n">does</span> <span class="n">NOT</span> <span class="n">apply</span> <span class="ow">in</span> <span class="n">the</span>
                <span class="n">keep</span><span class="o">-</span><span class="n">going</span> <span class="n">mode</span> <span class="n">after</span> <span class="n">first</span> <span class="n">round</span> <span class="n">of</span> <span class="n">splitting</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsMaxSplits</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">Maximal</span> <span class="n">number</span> <span class="n">of</span> <span class="n">VC</span> <span class="n">generated</span> <span class="n">per</span> <span class="kr">method</span><span class="o">.</span> <span class="n">In</span> <span class="n">keep</span>
                <span class="n">going</span> <span class="n">mode</span> <span class="n">only</span> <span class="n">applies</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">first</span> <span class="n">round</span><span class="o">.</span>
                <span class="n">Defaults</span> <span class="kr">to</span> <span class="mi">1</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsMaxKeepGoingSplits</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">If</span> <span class="kt">set</span> <span class="kr">to</span> <span class="n">more</span> <span class="n">than</span> <span class="mi">1</span><span class="p">,</span> <span class="n">activates</span> <span class="n">the</span> <span class="n">keep</span>
                <span class="n">going</span> <span class="n">mode</span><span class="p">,</span> <span class="n">where</span> <span class="n">after</span> <span class="n">the</span> <span class="n">first</span> <span class="n">round</span> <span class="n">of</span> <span class="n">splitting</span><span class="p">,</span>
                <span class="n">VCs</span> <span class="n">that</span> <span class="n">timed</span> <span class="n">out</span> <span class="n">are</span> <span class="n">split</span> <span class="n">into</span> <span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span> <span class="n">pieces</span> <span class="n">and</span> <span class="n">retried</span>
                <span class="n">until</span> <span class="n">we</span> <span class="n">succeed</span> <span class="n">proving</span> <span class="n">them</span><span class="p">,</span> <span class="n">or</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">only</span> <span class="n">one</span>
                <span class="n">assertion</span> <span class="n">on</span> <span class="n">a</span> <span class="n">single</span> <span class="n">path</span> <span class="n">and</span> <span class="n">it</span> <span class="n">timeouts</span> <span class="p">(</span><span class="ow">in</span> <span class="n">which</span>
                <span class="kr">case</span> <span class="n">error</span> <span class="ow">is</span> <span class="n">reported</span> <span class="kr">for</span> <span class="n">that</span> <span class="n">assertion</span><span class="p">)</span><span class="o">.</span>
                <span class="n">Defaults</span> <span class="kr">to</span> <span class="mi">1</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsKeepGoingTimeout</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">Timeout</span> <span class="ow">in</span> <span class="n">seconds</span> <span class="kr">for</span> <span class="n">a</span> <span class="n">single</span> <span class="n">theorem</span> <span class="n">prover</span>
                <span class="n">invocation</span> <span class="ow">in</span> <span class="n">keep</span> <span class="n">going</span> <span class="n">mode</span><span class="p">,</span> <span class="n">except</span> <span class="kr">for</span> <span class="n">the</span> <span class="n">final</span>
                <span class="n">single</span><span class="o">-</span><span class="n">assertion</span> <span class="kr">case</span><span class="o">.</span> <span class="n">Defaults</span> <span class="kr">to</span> <span class="err">1s</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsFinalAssertTimeout</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">Timeout</span> <span class="ow">in</span> <span class="n">seconds</span> <span class="kr">for</span> <span class="n">the</span> <span class="n">single</span> <span class="n">last</span>
                <span class="n">assertion</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">keep</span> <span class="n">going</span> <span class="n">mode</span><span class="o">.</span> <span class="n">Defaults</span> <span class="kr">to</span> <span class="err">30s</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsPathJoinMult</span><span class="o">:&lt;</span><span class="n">f</span><span class="o">&gt;</span>
                <span class="n">If</span> <span class="n">more</span> <span class="n">than</span> <span class="n">one</span> <span class="n">path</span> <span class="n">join</span> <span class="n">at</span> <span class="n">a</span> <span class="n">block</span><span class="p">,</span> <span class="kr">by</span> <span class="n">how</span> <span class="n">much</span>
                <span class="n">multiply</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">paths</span> <span class="ow">in</span> <span class="n">that</span> <span class="n">block</span><span class="p">,</span> <span class="kr">to</span> <span class="n">accomodate</span>
                <span class="kr">for</span> <span class="n">the</span> <span class="n">fact</span> <span class="n">that</span> <span class="n">the</span> <span class="n">prover</span> <span class="n">will</span> <span class="n">learn</span> <span class="n">something</span> <span class="n">on</span> <span class="n">one</span>
                <span class="n">paths</span><span class="p">,</span> <span class="n">before</span> <span class="n">proceeding</span> <span class="kr">to</span> <span class="n">another</span><span class="o">.</span> <span class="n">Defaults</span> <span class="kr">to</span> <span class="mf">0.8</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsPathCostMult</span><span class="o">:&lt;</span><span class="n">f1</span><span class="o">&gt;</span>
  <span class="o">/</span><span class="n">vcsAssumeMult</span><span class="o">:&lt;</span><span class="n">f2</span><span class="o">&gt;</span>
                <span class="n">The</span> <span class="n">cost</span> <span class="n">of</span> <span class="n">a</span> <span class="n">block</span> <span class="ow">is</span>
                    <span class="p">(</span><span class="o">&lt;</span><span class="kr">assert</span><span class="o">-</span><span class="n">cost</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">&lt;</span><span class="n">f2</span><span class="o">&gt;*&lt;</span><span class="kr">assume</span><span class="o">-</span><span class="n">cost</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">*</span>
                    <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="o">&lt;</span><span class="n">f1</span><span class="o">&gt;*&lt;</span><span class="n">entering</span><span class="o">-</span><span class="n">paths</span><span class="o">&gt;</span><span class="p">)</span>
                <span class="o">&lt;</span><span class="n">f1</span><span class="o">&gt;</span> <span class="n">defaults</span> <span class="kr">to</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">f2</span><span class="o">&gt;</span> <span class="n">defaults</span> <span class="kr">to</span> <span class="mf">0.01</span><span class="o">.</span>
                <span class="n">The</span> <span class="n">cost</span> <span class="n">of</span> <span class="n">a</span> <span class="n">single</span> <span class="n">assertion</span> <span class="n">or</span> <span class="n">assumption</span> <span class="ow">is</span>
                <span class="n">currently</span> <span class="n">always</span> <span class="mf">1.0</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsPathSplitMult</span><span class="o">:&lt;</span><span class="n">f</span><span class="o">&gt;</span>
                <span class="n">If</span> <span class="n">the</span> <span class="n">best</span> <span class="n">path</span> <span class="n">split</span> <span class="n">of</span> <span class="n">a</span> <span class="n">VC</span> <span class="n">of</span> <span class="n">cost</span> <span class="n">A</span> <span class="ow">is</span> <span class="n">into</span>
                <span class="n">VCs</span> <span class="n">of</span> <span class="n">cost</span> <span class="n">B</span> <span class="n">and</span> <span class="n">C</span><span class="p">,</span> <span class="kr">then</span> <span class="n">the</span> <span class="n">split</span> <span class="ow">is</span> <span class="n">applied</span> <span class="kr">if</span>
                <span class="n">A</span> <span class="o">&gt;=</span> <span class="o">&lt;</span><span class="n">f</span><span class="o">&gt;*</span><span class="p">(</span><span class="n">B</span><span class="o">+</span><span class="n">C</span><span class="p">),</span> <span class="n">otherwise</span> <span class="n">assertion</span> <span class="n">splitting</span> <span class="n">will</span> <span class="n">be</span>
                <span class="n">applied</span><span class="o">.</span> <span class="n">Defaults</span> <span class="kr">to</span> <span class="mf">0.5</span> <span class="p">(</span><span class="n">always</span> <span class="n">do</span> <span class="n">path</span> <span class="n">splitting</span> <span class="kr">if</span>
                <span class="n">possible</span><span class="p">),</span> <span class="kt">set</span> <span class="kr">to</span> <span class="n">more</span> <span class="kr">to</span> <span class="n">do</span> <span class="n">less</span> <span class="n">path</span> <span class="n">splitting</span>
                <span class="n">and</span> <span class="n">more</span> <span class="n">assertion</span> <span class="n">splitting</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsSplitOnEveryAssert</span>
                <span class="n">Splits</span> <span class="n">every</span> <span class="n">VC</span> <span class="n">so</span> <span class="n">that</span> <span class="n">each</span> <span class="n">assertion</span> <span class="ow">is</span> <span class="n">isolated</span>
                <span class="n">into</span> <span class="n">its</span> <span class="n">own</span> <span class="n">VC</span><span class="o">.</span> <span class="n">May</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">VCs</span> <span class="n">without</span> <span class="n">any</span> <span class="n">assertions</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsDumpSplits</span>
                <span class="n">For</span> <span class="n">split</span> <span class="err">#</span><span class="n">n</span> <span class="n">dump</span> <span class="n">split</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">dot</span> <span class="n">and</span> <span class="n">split</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">bpl</span><span class="o">.</span>
                <span class="n">Warning</span><span class="o">:</span> <span class="n">Affects</span> <span class="n">error</span> <span class="n">reporting</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsCores</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="n">Try</span> <span class="kr">to</span> <span class="n">verify</span> <span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span> <span class="n">VCs</span> <span class="n">at</span> <span class="n">once</span><span class="o">.</span> <span class="n">Defaults</span> <span class="kr">to</span> <span class="mi">1</span><span class="o">.</span>
  <span class="o">/</span><span class="n">vcsLoad</span><span class="o">:&lt;</span><span class="n">f</span><span class="o">&gt;</span>  <span class="n">Sets</span> <span class="n">vcsCores</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">machine's</span> <span class="n">ProcessorCount</span> <span class="o">*</span> <span class="n">f</span><span class="p">,</span>
                <span class="n">rounded</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">nearest</span> <span class="n">integer</span> <span class="p">(</span><span class="n">where</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="mf">3.0</span><span class="p">),</span>
                <span class="n">but</span> <span class="n">never</span> <span class="kr">to</span> <span class="n">less</span> <span class="n">than</span> <span class="mi">1</span><span class="o">.</span>

  <span class="o">----</span> <span class="n">Prover</span> <span class="n">options</span> <span class="o">--------------------------------------------------------</span>

  <span class="o">/</span><span class="n">errorLimit</span><span class="o">:&lt;</span><span class="n">num</span><span class="o">&gt;</span>
                <span class="n">Limit</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">errors</span> <span class="n">produced</span> <span class="kr">for</span> <span class="n">each</span> <span class="n">procedure</span>
                <span class="p">(</span><span class="n">default</span> <span class="ow">is</span> <span class="mi">5</span><span class="p">,</span> <span class="n">some</span> <span class="n">provers</span> <span class="n">may</span> <span class="n">support</span> <span class="n">only</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span>
                <span class="n">Set</span> <span class="n">num</span> <span class="kr">to</span> <span class="mi">0</span> <span class="kr">to</span> <span class="n">find</span> <span class="ow">as</span> <span class="n">many</span> <span class="n">assertion</span> <span class="n">failures</span> <span class="ow">as</span> <span class="n">possible</span><span class="o">.</span>
  <span class="o">/</span><span class="n">timeLimit</span><span class="o">:&lt;</span><span class="n">num</span><span class="o">&gt;</span>
                <span class="n">Limit</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">seconds</span> <span class="n">spent</span> <span class="n">trying</span> <span class="kr">to</span> <span class="n">verify</span>
                <span class="n">each</span> <span class="n">procedure</span>
  <span class="o">/</span><span class="n">rlimit</span><span class="o">:&lt;</span><span class="n">num</span><span class="o">&gt;</span>
                <span class="n">Limit</span> <span class="n">the</span> <span class="n">Z3</span> <span class="n">resource</span> <span class="n">spent</span> <span class="n">trying</span> <span class="kr">to</span> <span class="n">verify</span> <span class="n">each</span> <span class="n">procedure</span><span class="o">.</span>
  <span class="o">/</span><span class="n">errorTrace</span><span class="o">:&lt;</span><span class="n">n</span><span class="o">&gt;</span>
                <span class="mi">0</span> <span class="o">-</span> <span class="n">no</span> <span class="n">Trace</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">error</span> <span class="n">output</span><span class="p">,</span>
                <span class="mi">1</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="kr">include</span> <span class="n">useful</span> <span class="n">Trace</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">error</span> <span class="n">output</span><span class="p">,</span>
                <span class="mi">2</span> <span class="o">-</span> <span class="kr">include</span> <span class="n">all</span> <span class="n">Trace</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">error</span> <span class="n">output</span>
  <span class="o">/</span><span class="n">vcBrackets</span><span class="o">:&lt;</span><span class="n">b</span><span class="o">&gt;</span>
                <span class="n">bracket</span> <span class="n">odd</span><span class="o">-</span><span class="n">charactered</span> <span class="n">identifier</span> <span class="n">names</span> <span class="n">with</span> <span class="o">|</span><span class="err">'s.  &lt;b&gt; is:</span>
                   <span class="mi">0</span> <span class="o">-</span> <span class="n">no</span> <span class="p">(</span><span class="n">default</span><span class="p">),</span>
                   <span class="mi">1</span> <span class="o">-</span> <span class="n">yes</span>
  <span class="o">/</span><span class="n">proverDll</span><span class="o">:&lt;</span><span class="n">tp</span><span class="o">&gt;</span>
                <span class="n">use</span> <span class="n">theorem</span> <span class="n">prover</span> <span class="o">&lt;</span><span class="n">tp</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">where</span> <span class="o">&lt;</span><span class="n">tp</span><span class="o">&gt;</span> <span class="ow">is</span> <span class="n">either</span> <span class="n">the</span> <span class="n">name</span> <span class="n">of</span>
                <span class="n">a</span> <span class="n">DLL</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">prover</span> <span class="n">interface</span> <span class="n">located</span> <span class="ow">in</span> <span class="n">the</span>
                <span class="n">Boogie</span> <span class="n">directory</span><span class="p">,</span> <span class="n">or</span> <span class="n">a</span> <span class="n">full</span> <span class="n">path</span> <span class="kr">to</span> <span class="n">a</span> <span class="n">DLL</span> <span class="n">containing</span> <span class="n">such</span>
                <span class="n">an</span> <span class="n">interface</span><span class="o">.</span> <span class="n">The</span> <span class="n">default</span> <span class="n">interface</span> <span class="n">shipped</span> <span class="ow">is</span><span class="o">:</span>
                    <span class="n">SMTLib</span> <span class="p">(</span><span class="n">uses</span> <span class="n">the</span> <span class="n">SMTLib2</span> <span class="n">format</span> <span class="n">and</span> <span class="n">calls</span> <span class="n">an</span> <span class="n">SMT</span> <span class="n">solver</span><span class="p">)</span>
  <span class="o">/</span><span class="n">proverOpt</span><span class="o">:</span><span class="n">KEY</span><span class="p">[</span><span class="o">=</span><span class="n">VALUE</span><span class="p">]</span>
                <span class="n">Provide</span> <span class="n">a</span> <span class="n">prover</span><span class="o">-</span><span class="n">specific</span> <span class="n">option</span> <span class="p">(</span><span class="n">short</span> <span class="n">form</span> <span class="o">/</span><span class="n">p</span><span class="p">)</span><span class="o">.</span>
  <span class="o">/</span><span class="n">proverHelp</span>   <span class="n">Print</span> <span class="n">prover</span><span class="o">-</span><span class="n">specific</span> <span class="n">options</span> <span class="n">supported</span> <span class="kr">by</span> <span class="o">/</span><span class="n">proverOpt</span><span class="o">.</span>
  <span class="o">/</span><span class="n">proverLog</span><span class="o">:&lt;</span><span class="n">file</span><span class="o">&gt;</span>
                <span class="n">Log</span> <span class="n">input</span> <span class="kr">for</span> <span class="n">the</span> <span class="n">theorem</span> <span class="n">prover</span><span class="o">.</span>  <span class="n">Like</span> <span class="n">filenames</span>
                <span class="n">supplied</span> <span class="ow">as</span> <span class="n">arguments</span> <span class="kr">to</span> <span class="n">other</span> <span class="n">options</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span> <span class="n">can</span> <span class="n">use</span> <span class="n">the</span>
                <span class="n">following</span> <span class="n">macros</span><span class="o">:</span>
                    <span class="err">@</span><span class="n">TIME</span><span class="err">@</span>    <span class="n">expands</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">current</span> <span class="n">time</span>
                    <span class="err">@</span><span class="n">PREFIX</span><span class="err">@</span>  <span class="n">expands</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">concatenation</span> <span class="n">of</span> <span class="n">strings</span> <span class="n">given</span>
                              <span class="kr">by</span> <span class="o">/</span><span class="n">logPrefix</span> <span class="n">options</span>
                    <span class="err">@</span><span class="n">FILE</span><span class="err">@</span>    <span class="n">expands</span> <span class="kr">to</span> <span class="n">the</span> <span class="n">last</span> <span class="n">filename</span> <span class="n">specified</span> <span class="n">on</span> <span class="n">the</span>
                              <span class="n">command</span> <span class="n">line</span>
                <span class="n">In</span> <span class="n">addition</span><span class="p">,</span> <span class="o">/</span><span class="n">proverLog</span> <span class="n">can</span> <span class="n">also</span> <span class="n">use</span> <span class="n">the</span> <span class="n">macro</span> <span class="err">'@PROC@'</span><span class="p">,</span>
                <span class="n">which</span> <span class="n">causes</span> <span class="n">there</span> <span class="kr">to</span> <span class="n">be</span> <span class="n">one</span> <span class="n">prover</span> <span class="n">log</span> <span class="n">file</span> <span class="n">per</span>
                <span class="n">verification</span> <span class="n">condition</span><span class="p">,</span> <span class="n">and</span> <span class="n">the</span> <span class="n">macro</span> <span class="kr">then</span> <span class="n">expands</span> <span class="kr">to</span> <span class="n">the</span>
                <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="n">procedure</span> <span class="n">that</span> <span class="n">the</span> <span class="n">verification</span> <span class="n">condition</span> <span class="ow">is</span> <span class="kr">for</span><span class="o">.</span>
  <span class="o">/</span><span class="n">logPrefix</span><span class="o">:&lt;</span><span class="n">str</span><span class="o">&gt;</span>
                <span class="n">Defines</span> <span class="n">the</span> <span class="n">expansion</span> <span class="n">of</span> <span class="n">the</span> <span class="n">macro</span> <span class="err">'@PREFIX@'</span><span class="p">,</span> <span class="n">which</span> <span class="n">can</span>
                <span class="n">be</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">various</span> <span class="n">filenames</span> <span class="n">specified</span> <span class="kr">by</span> <span class="n">other</span> <span class="n">options</span><span class="o">.</span>
  <span class="o">/</span><span class="n">proverLogAppend</span>
                <span class="n">Append</span> <span class="p">(</span><span class="n">not</span> <span class="n">overwrite</span><span class="p">)</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">prover</span> <span class="n">log</span> <span class="n">file</span>
  <span class="o">/</span><span class="n">proverWarnings</span>
                <span class="mi">0</span> <span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="o">-</span> <span class="n">don't</span> <span class="kr">print</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="kr">print</span> <span class="kr">to</span> <span class="n">stdout</span><span class="p">,</span>
                <span class="mi">2</span> <span class="o">-</span> <span class="kr">print</span> <span class="kr">to</span> <span class="n">stderr</span>
  <span class="o">/</span><span class="n">restartProver</span>
                <span class="n">Restart</span> <span class="n">the</span> <span class="n">prover</span> <span class="n">after</span> <span class="n">each</span> <span class="n">query</span>
</code></pre></div></div>
<p><!-- PDFOMIT --></p>

<!--PDF NEWPAGE-->
<h2 id="sec-grammar-details">17. Dafny Grammar</h2>

<p>The Dafny grammar has a traditional structure: a scanner tokenizes the textual input into a sequence of tokens; the parser consumes the tokens
to produce an AST. The AST is then passed on for name and type resolution and further processing.</p>

<p>Dafny uses the Coco/R lexer and parser generator for its lexer and parser
(<a href="http://www.ssw.uni-linz.ac.at/Research/Projects/Coco">http://www.ssw.uni-linz.ac.at/Research/Projects/Coco</a>)[@Linz:Coco].
See the <a href="http://www.ssw.uni-linz.ac.at/Research/Projects/Coco/Doc/UserManual.pdf">Coco/R Reference
manual</a>
for details.
The Dafny input file to Coco/R is the <code class="language-dafny highlighter-rouge"><span class="n">Dafny</span><span class="o">.</span><span class="n">atg</span></code> file in the source tree.</p>

<p>The grammar is an <em>attributed extended BNF</em> grammar.
The <em>attributed</em> adjective indicates that the BNF productions are
parameterized by boolean parameters that control variations of the 
production rules, such as whether a particular alternative is permitted or
not. Using such attributes allows combining non-terminals with quite
similar production rules, making a simpler, more compact and more
readable grammer.</p>

<p>The grammar rules presented here replicate those in the source
code, but omit semantic actions, error recovery markers, and
conflict resolution syntax. Some uses of the attribute
parameters are described informally.</p>

<p>The names of character sets and tokens start with a lower case
letter; the names of grammar non-terminals start with
an upper-case letter.</p>

<h3 id="171-dafny-syntax">17.1. Dafny Syntax</h3>

<p>This section gives the definitions of Dafny tokens.</p>

<h4 id="1711-classes-of-characters">17.1.1. Classes of characters</h4>

<p>These definitions define some names as representing subsets of the set of characters. Here,</p>

<ul>
  <li>double quotes enclose the set of characters constituting the class,</li>
  <li>single quotes enclose a single character (perhaps an escaped representation using <code class="language-dafny highlighter-rouge"><span class="err">\</span></code>),</li>
  <li>the binary <code class="language-dafny highlighter-rouge"><span class="o">+</span></code> indicates set union,</li>
  <li>binary <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> indicates set difference, and</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">ANY</span></code> indicates the set of all (unicode) characters.</li>
</ul>

<pre><code class="language-grammar">letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

digit = "0123456789"
posDigit = "123456789"
posDigitFrom2 = "23456789"

hexdigit = "0123456789ABCDEFabcdef"

special = "'_?"

cr        = '\r'

lf        = '\n'

tab       = '\t'

space     = ' '

nondigitIdChar = letter + special

idchar = nondigitIdChar + digit

nonidchar = ANY - idchar

charChar = ANY - '\'' - '\\' - cr - lf

stringChar = ANY - '"' - '\\' - cr - lf

verbatimStringChar = ANY - '"'
</code></pre>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">nonidchar</span></code> is any character except those that can be used in an identifier.
Here the scanner generator will interpret <code class="language-dafny highlighter-rouge"><span class="n">ANY</span></code> as any unicode character.
However, <code class="language-dafny highlighter-rouge"><span class="n">nonidchar</span></code> is used only to mark the end of the <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="ow">in</span></code> token;
in this context any character other than <a href="#sec-unicode">whitespace or printable ASCII</a>
will trigger a subsequent scanning or parsing error.</p>

<h4 id="sec-g-tokens">17.1.2. Definitions of tokens</h4>

<p>These definitions use</p>

<ul>
  <li>double-quotes to indicate a verbatim string (with no escaping of characters)</li>
  <li><code class="language-dafny highlighter-rouge"><span class="sc">'"'</span></code> to indicate a literal double-quote character</li>
  <li>vertical bar to indicate alternatives</li>
  <li>square brackets to indicate an optional part</li>
  <li>curly braces to indicate 0-or-more repetitions</li>
  <li>parentheses to indicate grouping</li>
  <li>a <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> sign to indicate set difference: any character sequence matched by the left operand except character sequences matched by the right operand</li>
  <li>a sequence of any of the above to indicate concatenation without whitespace</li>
</ul>

<pre><code class="language-grammar">reservedword =
    "abstract" | "allocated" | "as" | "assert" | "assume" |
    "bool" | "break" | "by" |
    "calc" | "case" | "char" | "class" | "codatatype" |
    "const" | "constructor" | "continue" |
    "datatype" | "decreases" |
    "else" | "ensures" | "exists" | "expect" | "export" | "extends" |
    "false" | "for" | "forall" | "fp32" | "fp64" | "fresh" | "function" | "ghost" |
    "if" | "imap" | "import" | "in" | "include" |
    "int" | "invariant" | "is" | "iset" | "iterator" |
    "label" | "lemma" | "map" | "match" | "method" |
    "modifies" | "modify" | "module" | "multiset" |
    "nameonly" | "nat" | "new" | "newtype" | "null" |
    "object" | "object?" | "old" | "opaque" | "opened" | "ORDINAL"
    "predicate" | "print" | "provides" |
    "reads" | "real" | "refines" | "requires" | "return" |
    "returns" | "reveal" | "reveals" |
    "seq" | "set" | "static" | "string" |
    "then" | "this" | "trait" | "true" | "twostate" | "type" |
    "unchanged" | "var" | "while" | "witness" |
    "yield" | "yields" |
    arrayToken | bvToken

arrayToken = "array" [ posDigitFrom2 | posDigit digit { digit }]["?"]

bvToken = "bv" ( 0 | posDigit { digit } )

ident = nondigitIdChar { idchar } - charToken - reservedword

digits = digit {["_"] digit}

hexdigits = "0x" hexdigit {["_"] hexdigit}

realnumber = digit {["_"] digit}
             ( '.' digit {["_"] digit} ['e' ['-'] digit {["_"] digit}]
             | 'e' ['-'] digit {["_"] digit}
             )

escapedChar =
    ( "\'" | "\"" | "\\" | "\0" | "\n" | "\r" | "\t"
      | "\u" hexdigit hexdigit hexdigit hexdigit
      | "\U{" hexdigit { hexdigit } "}"
    )

charToken = "'" ( charChar | escapedChar ) "'"

stringToken =
    '"' { stringChar | escapedChar }  '"'
  | "@" '"' { verbatimStringChar | '"' '"' } '"'

ellipsis = "..."
</code></pre>

<p>There are a few words that have a special meaning in certain contexts, but are not 
reserved words and can be used as identifiers outside of those contexts:</p>

<ul>
  <li><code class="language-dafny highlighter-rouge"><span class="kr">least</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">greatest</span></code> are recognized as adjectives to the keyword <code class="language-dafny highlighter-rouge"><span class="kr">predicate</span></code> (cf. <a href="#sec-extreme">Section 12.4</a>).</li>
  <li><code class="language-dafny highlighter-rouge"><span class="n">older</span></code> is a modifier for parameters of non-extreme predicates (cf. <a href="#sec-older-parameters">Section 6.4.6</a>).</li>
</ul>

<p>The <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">uXXXX</span></code> form of an <code class="language-dafny highlighter-rouge"><span class="n">escapedChar</span></code> is only used when the option <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span><span class="o">=</span><span class="kc">false</span></code> is set (which is the default for Dafny 3.x);
the <code class="language-dafny highlighter-rouge"><span class="err">\</span><span class="n">U</span><span class="p">{</span><span class="n">XXXXXX</span><span class="p">}</span></code> form of an <code class="language-dafny highlighter-rouge"><span class="n">escapedChar</span></code> is only used when the option <code class="language-dafny highlighter-rouge"><span class="o">--</span><span class="n">unicode</span><span class="o">-</span><span class="kt">char</span><span class="o">=</span><span class="kc">true</span></code> is set (which is the default for Dafny 4.x).</p>

<h3 id="172-dafny-grammar-productions">17.2. Dafny Grammar productions</h3>

<p>The grammar productions are presented in the following Extended BNF syntax:</p>

<ul>
  <li>identifiers starting with a lower case letter denote
terminal symbols (tokens) as defined in the <a href="#sec-g-tokens">previous subsection</a></li>
  <li>identifiers starting with an upper case letter denote nonterminal
symbols</li>
  <li>strings (a sequence of characters enclosed by double quote characters)
denote the sequence of enclosed characters</li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">=</span></code> separates the sides of a production, e.g. <code class="language-dafny highlighter-rouge"><span class="n">A</span> <span class="o">=</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="o">|</span></code> separates alternatives, e.g. <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">c</span> <span class="o">|</span> <span class="n">d</span> <span class="n">e</span></code> means <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="n">b</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">c</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">d</span> <span class="n">e</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">(</span></code> <code class="language-dafny highlighter-rouge"><span class="p">)</span></code> groups alternatives, e.g. <code class="language-dafny highlighter-rouge"><span class="p">(</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)</span> <span class="n">c</span></code> means <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="n">c</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">b</span> <span class="n">c</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">[</span> <span class="p">]</span></code> option, e.g. <code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="n">b</span></code> means <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="n">b</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">b</span></code></li>
  <li><code class="language-dafny highlighter-rouge"><span class="p">{</span> <span class="p">}</span></code> iteration (0 or more times), e.g. <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="n">a</span><span class="p">}</span> <span class="n">b</span></code> means <code class="language-dafny highlighter-rouge"><span class="n">b</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="n">b</span></code> or <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="n">a</span> <span class="n">b</span></code> or </li>
  <li>We allow <code class="language-dafny highlighter-rouge"><span class="o">|</span></code> inside <code class="language-dafny highlighter-rouge"><span class="p">[</span> <span class="p">]</span></code> and <code class="language-dafny highlighter-rouge"><span class="p">{</span> <span class="p">}</span></code>. So <code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">]</span></code> is short for <code class="language-dafny highlighter-rouge"><span class="p">[(</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)]</span></code>
and <code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">}</span></code> is short for <code class="language-dafny highlighter-rouge"><span class="p">{(</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">)}</span></code>.</li>
  <li><code class="language-dafny highlighter-rouge"><span class="c1">//</span></code> in a line introduces a comment that extends to the end-of-the line, but does not terminate the production</li>
  <li>The first production defines the name of the grammar, in this case <code class="language-dafny highlighter-rouge"><span class="n">Dafny</span></code>.</li>
</ul>

<p>In addition to the Coco rules, for the sake of readability we have adopted
these additional conventions.</p>

<ul>
  <li>We allow <code class="language-dafny highlighter-rouge"><span class="o">-</span></code> to be used. <code class="language-dafny highlighter-rouge"><span class="n">a</span> <span class="o">-</span> <span class="n">b</span></code> means it matches if it matches <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> but not <code class="language-dafny highlighter-rouge"><span class="n">b</span></code>.</li>
  <li>We omit the <code class="language-dafny highlighter-rouge"><span class="o">.</span></code> that marks the end of a CoCo/R production.</li>
  <li>we omit deprecated features.</li>
</ul>

<p>To aid in explaining the grammar we have added some additional productions
that are not present in the original grammar. We name these with a trailing
underscore. Inlining these where they are referenced will reconstruct the original grammar.</p>

<!-- A note on formatting the sections below: LaTex renders the 'discussion' link in line with the heading for level-4 and higher headings.
     I've not found a sensible way around it (and it is not worth much trouble). -->

<h4 id="g-program">17.2.1. Programs</h4>
<p>(<a href="#sec-program">discussion</a>)</p>

<pre><code class="language-grammar">Dafny = { IncludeDirective_ } { TopDecl(isTopLevel:true, isAbstract: false) } EOF
</code></pre>

<h5 id="g-include-directive">17.2.1.1. Include directives</h5>
<p>(<a href="#sec-include-directive">discussion</a>)</p>

<pre><code class="language-grammar">IncludeDirective_ = "include" stringToken
</code></pre>

<h5 id="g-top-level-declaration">17.2.1.2. Top-level declarations</h5>
<p>(<a href="#sec-top-level-declaration">discussion</a>)</p>

<pre><code class="language-grammar">TopDecl(isTopLevel, isAbstract) =
  { DeclModifier }
  ( SubModuleDecl(isTopLevel)
  | ClassDecl
  | DatatypeDecl
  | NewtypeDecl
  | SynonymTypeDecl  // includes abstract types
  | IteratorDecl
  | TraitDecl
  | ClassMemberDecl(allowConstructors: false, isValueType: true, moduleLevelDecl: true)
  )
</code></pre>

<h5 id="g-declaration-modifier">17.2.1.3. Declaration modifiers</h5>
<p>(<a href="#sec-declaration-modifier">discussion</a>)</p>

<pre><code class="language-grammar">DeclModifier = ( "abstract" | "ghost" | "static" | "opaque" )
</code></pre>

<h4 id="g-module">17.2.2. Modules</h4>

<pre><code class="language-grammar">SubModuleDecl(isTopLevel) = ( ModuleDefinition | ModuleImport | ModuleExport )
</code></pre>

<p>Module export declarations are not permitted if <code class="language-dafny highlighter-rouge"><span class="n">isTopLevel</span></code> is true.</p>

<h5 id="g-module-definition">17.2.2.1. Module Definitions</h5>
<p>(<a href="#sec-module-definition">discussion</a>)</p>

<pre><code class="language-grammar">ModuleDefinition(isTopLevel) = 
  "module" { Attribute } ModuleQualifiedName
  [ "refines" ModuleQualifiedName ]
  "{" { TopDecl(isTopLevel:false, isAbstract) } "}"
</code></pre>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">isAbstract</span></code> argument is true if the preceding <code class="language-dafny highlighter-rouge"><span class="n">DeclModifiers</span></code> include abstract.</p>

<h5 id="g-module-import">17.2.2.2. Module Imports</h5>
<p>(<a href="#sec-importing-modules">discussion</a>)</p>

<pre><code class="language-grammar">ModuleImport =
  "import"
  [ "opened" ]
  ( QualifiedModuleExport
  | ModuleName "=" QualifiedModuleExport
  | ModuleName ":" QualifiedModuleExport
  )

QualifiedModuleExport =
    ModuleQualifiedName [ "`" ModuleExportSuffix ]

ModuleExportSuffix =
  ( ExportId
  | "{" ExportId { "," ExportId } "}"
  )
</code></pre>

<h5 id="g-module-export">17.2.2.3. Module Export Definitions</h5>
<p>(<a href="#sec-export-sets">discussion</a>)</p>

<pre><code class="language-grammar">ModuleExport =
  "export"
  [ ExportId ]
  [ "..." ]
  {
    "extends"  ExportId { "," ExportId }
  | "provides" ( ExportSignature { "," ExportSignature } | "*" )
  | "reveals"  ( ExportSignature { "," ExportSignature } | "*" )
  }

ExportSignature = TypeNameOrCtorSuffix [ "." TypeNameOrCtorSuffix ]
</code></pre>

<h4 id="g-type">17.2.3. Types</h4>
<p>(<a href="#sec-types">discussion</a>)</p>

<pre><code class="language-grammar">Type = DomainType_ | ArrowType_

DomainType_ =
  ( BoolType_ | CharType_ | IntType_ | RealType_ | FloatType_
  | OrdinalType_ | BitVectorType_ | ObjectType_
  | FiniteSetType_ | InfiniteSetType_
  | MultisetType_
  | FiniteMapType_ | InfiniteMapType_
  | SequenceType_
  | NatType_
  | StringType_
  | ArrayType_
  | TupleType
  | NamedType
  )

NamedType = NameSegmentForTypeName { "." NameSegmentForTypeName }

NameSegmentForTypeName = Ident [ GenericInstantiation ]
</code></pre>

<h5 id="g-basic-type">17.2.3.1. Basic types</h5>
<p>(<a href="#sec-basic-type">discussion</a>)</p>

<pre><code class="language-grammar">BoolType_ = "bool"
IntType_ = "int"
RealType_ = "real"
FloatType_ = "fp32" | "fp64"
BitVectorType_ = bvToken
OrdinalType_ = "ORDINAL"
CharType_ = "char"
</code></pre>

<h5 id="g-generic-instantiation">17.2.3.2. Generic instantiation</h5>
<p>(<a href="#sec-generic-instantiation">discussion</a>)</p>

<pre><code class="language-grammar">GenericInstantiation = "&lt;" Type { "," Type } "&gt;"
</code></pre>

<h5 id="g-type-parameter">17.2.3.3. Type parameter</h5>
<p>(<a href="#sec-type-parameters">discussion</a>)</p>

<pre><code class="language-grammar">GenericParameters(allowVariance) =
  "&lt;" [ Variance ] TypeVariableName { TypeParameterCharacteristics }
  { "," [ Variance ] TypeVariableName { TypeParameterCharacteristics } }
  "&gt;"

// The optional Variance indicator is permitted only if allowVariance is true
Variance = ( "*" | "+" | "!" | "-" )

TypeParameterCharacteristics = "(" TPCharOption { "," TPCharOption } ")"

TPCharOption = ( "==" | "0" | "00" | "!" "new" )
</code></pre>

<h5 id="g-collection-type">17.2.3.4. Collection types</h5>
<p>(<a href="#sec-collection-types">discussion</a>)</p>

<pre><code class="language-grammar">FiniteSetType_ = "set" [ GenericInstantiation ]

InfiniteSetType_ = "iset" [ GenericInstantiation ]

MultisetType_ = "multiset" [ GenericInstantiation ]

SequenceType_ = "seq" [ GenericInstantiation ]

StringType_ = "string"

FiniteMapType_ = "map" [ GenericInstantiation ]

InfiniteMapType_ = "imap" [ GenericInstantiation ]
</code></pre>

<h5 id="g-type-definition">17.2.3.5. Type definitions</h5>
<p>(<a href="#sec-type-definition">discussion</a>)</p>

<pre><code class="language-grammar">SynonymTypeDecl =
  SynonymTypeDecl_ | OpaqueTypeDecl_ | SubsetTypeDecl_

SynonymTypeName = NoUSIdent

SynonymTypeDecl_ =
  "type" { Attribute } SynonymTypeName
   { TypeParameterCharacteristics }
   [ GenericParameters ]
   "=" Type

OpaqueTypeDecl_ =
  "type" { Attribute } SynonymTypeName
   { TypeParameterCharacteristics }
   [ GenericParameters ]
   [ TypeMembers ]

TypeMembers =
  "{"
  {
    { DeclModifier }
    ClassMemberDecl(allowConstructors: false,
                    isValueType: true,
                    moduleLevelDecl: false,
                    isWithinAbstractModule: module.IsAbstract)
  }
  "}"

SubsetTypeDecl_ =
  "type"
  { Attribute }
  SynonymTypeName [ GenericParameters ]
  "="
  LocalIdentTypeOptional
  "|"
  Expression(allowLemma: false, allowLambda: true)
  [ "ghost" "witness" Expression(allowLemma: false, allowLambda: true)
  | "witness" Expression((allowLemma: false, allowLambda: true)
  | "witness" "*"
  ]

NatType_ = "nat"

NewtypeDecl = "newtype" { Attribute } NewtypeName "="
  [ ellipsis ]
  ( LocalIdentTypeOptional
    "|"
    Expression(allowLemma: false, allowLambda: true)
    [ "ghost" "witness" Expression(allowLemma: false, allowLambda: true)
    | "witness" Expression((allowLemma: false, allowLambda: true)
    | "witness" "*"
    ]
  | Type
  )
  [ TypeMembers ]
</code></pre>

<h5 id="g-class-type">17.2.3.6. Class type</h5>
<p>(<a href="#sec-class-types">discussion</a>)</p>

<pre><code class="language-grammar">ClassDecl = "class" { Attribute } ClassName [ GenericParameters ]
  ["extends" Type {"," Type} | ellipsis ]
  "{" { { DeclModifier }
        ClassMemberDecl(modifiers,
                        allowConstructors: true,
                        isValueType: false,
                        moduleLevelDecl: false) 
      }
  "}"

ClassMemberDecl(modifiers, allowConstructors, isValueType, moduleLevelDecl) =
  ( FieldDecl(isValueType) // allowed iff moduleLevelDecl is false
  | ConstantFieldDecl(moduleLevelDecl)
  | FunctionDecl(isWithinAbstractModule)
  | MethodDecl(modifiers, allowConstructors)
  )
</code></pre>

<h5 id="g-trait-type">17.2.3.7. Trait types</h5>
<p>(<a href="#sec-trait-types">discussion</a>)</p>

<pre><code class="language-grammar">TraitDecl =
  "trait" { Attribute } ClassName [ GenericParameters ]
  [ "extends" Type { "," Type } | ellipsis ]
  "{"
   { { DeclModifier } ClassMemberDecl(allowConstructors: true,
                                      isValueType: false,
                                      moduleLevelDecl: false,
                                      isWithinAbstractModule: false) }
  "}"
</code></pre>

<h5 id="g-object-type">17.2.3.8. Object type</h5>
<p>(<a href="#sec-object-type">discussion</a>)</p>

<pre><code class="language-grammar">ObjectType_ = "object" | "object?"
</code></pre>

<h5 id="g-array-type">17.2.3.9. Array types</h5>
<p>(<a href="#sec-array-type">discussion</a>)</p>

<pre><code class="language-grammar">ArrayType_ = arrayToken [ GenericInstantiation ]
</code></pre>

<h5 id="g-iterator-type">17.2.3.10. Iterator types</h5>
<p>(<a href="#sec-iterator-types">discussion</a>)</p>

<pre><code class="language-grammar">IteratorDecl = "iterator" { Attribute } IteratorName
  ( [ GenericParameters ]
    Formals(allowGhostKeyword: true, allowNewKeyword: false, 
                                     allowOlderKeyword: false)
    [ "yields" Formals(allowGhostKeyword: true, allowNewKeyword: false, 
                                                allowOlderKeyword: false) ]
  | ellipsis
  )
  IteratorSpec
  [ BlockStmt ]
</code></pre>

<h5 id="g-arrow-type">17.2.3.11. Arrow types</h5>
<p>(<a href="#sec-arrow-types">discussion</a>)</p>

<pre><code class="language-grammar">ArrowType_ = ( DomainType_ "~&gt;" Type
             | DomainType_ "--&gt;" Type
             | DomainType_ "-&gt;" Type
             )
</code></pre>

<h5 id="g-datatype">17.2.3.12. Algebraic datatypes</h5>
<p>(<a href="#sec-datatype">discussion</a>)</p>

<pre><code class="language-grammar">DatatypeDecl =
  ( "datatype" | "codatatype" )
  { Attribute }
  DatatypeName [ GenericParameters ]
  "=" 
  [ ellipsis ]
  [ "|" ] DatatypeMemberDecl
  { "|" DatatypeMemberDecl }
  [ TypeMembers ]

DatatypeMemberDecl =
  { Attribute } DatatypeMemberName [ FormalsOptionalIds ]
</code></pre>

<h4 id="g-member-declaration">17.2.4. Type member declarations</h4>
<p>(<a href="#sec-member-declaration">discussion</a>)</p>

<h5 id="g-field-declaration">17.2.4.1. Fields</h5>
<p>(<a href="#sec-field-declaration">discussion</a>)</p>

<pre><code class="language-grammar">FieldDecl(isValueType) =
  "var" { Attribute } FIdentType { "," FIdentType }
</code></pre>

<p>A <code class="language-dafny highlighter-rouge"><span class="n">FieldDecl</span></code> is not permitted if <code class="language-dafny highlighter-rouge"><span class="n">isValueType</span></code> is true.</p>

<h5 id="g-const-declaration">17.2.4.2. Constant fields</h5>
<p>(<a href="#sec-constant-field-declaration">discussion</a>)</p>

<pre><code class="language-grammar">ConstantFieldDecl(moduleLevelDecl) =
  "const" { Attribute } CIdentType [ ellipsis ]
   [ ":=" Expression(allowLemma: false, allowLambda:true) ]
</code></pre>

<p>If <code class="language-dafny highlighter-rouge"><span class="n">moduleLevelDecl</span></code> is true, then the <code class="language-dafny highlighter-rouge"><span class="kr">static</span></code> modifier is not permitted
(the constant field is static implicitly).</p>

<h5 id="g-method-declaration">17.2.4.3. Method declarations</h5>
<p>(<a href="#sec-method-declaration">discussion</a>)</p>

<pre><code class="language-grammar">MethodDecl(isGhost, allowConstructors, isWithinAbstractModule) =
  MethodKeyword_ { Attribute } [ MethodFunctionName ]
  ( MethodSignature_(isGhost, isExtreme: true iff this is a least
                                   or greatest lemma declaration)
  | ellipsis
  )
  MethodSpec(isConstructor: true iff this is a constructor declaration)
  [ BlockStmt ]

MethodKeyword_ = ( "method"
                 | "constructor"
                 | "lemma"
                 | "twostate" "lemma"
                 | "least" "lemma"
                 | "greatest" "lemma"
                 )


MethodSignature_(isGhost, isExtreme) =
  [ GenericParameters ]
  [ KType ]    // permitted only if isExtreme == true
  Formals(allowGhostKeyword: !isGhost, allowNewKeyword: isTwostateLemma, 
          allowOlderKeyword: false, allowDefault: true)
  [ "returns" Formals(allowGhostKeyword: !isGhost, allowNewKeyword: false, 
                      allowOlderKeyword: false, allowDefault: false) ]

KType = "[" ( "nat" | "ORDINAL" ) "]"

Formals(allowGhostKeyword, allowNewKeyword, allowOlderKeyword, allowDefault) =
  "(" [ { Attribute } GIdentType(allowGhostKeyword, allowNewKeyword, allowOlderKeyword,
                   allowNameOnlyKeyword: true, allowDefault)
        { "," { Attribute } GIdentType(allowGhostKeyword, allowNewKeyword, allowOlderKeyword,
                         allowNameOnlyKeyword: true, allowDefault) }
      ]
  ")"
</code></pre>

<p>If <code class="language-dafny highlighter-rouge"><span class="n">isWithinAbstractModule</span></code> is false, then the method must have
a body for the program that contains the declaration to be compiled.</p>

<p>The <code class="language-dafny highlighter-rouge"><span class="n">KType</span></code> may be specified only for least and greatest lemmas.</p>

<h5 id="g-function-declaration">17.2.4.4. Function declarations</h5>
<p>(<a href="#sec-function-declaration">discussion</a>)</p>

<pre><code class="language-grammar">FunctionDecl(isWithinAbstractModule) =
  ( [ "twostate" ] "function" [ "method" ] { Attribute }
    MethodFunctionName
    FunctionSignatureOrEllipsis_(allowGhostKeyword:
                                           ("method" present),
                                 allowNewKeyword:
                                           "twostate" present)
  | "predicate" [ "method" ] { Attribute }
    MethodFunctionName
    PredicateSignatureOrEllipsis_(allowGhostKeyword:
                                           ("method" present),
                                  allowNewKeyword:
                                           "twostate" present,
                                  allowOlderKeyword: true)
  | ( "least" | "greatest" ) "predicate" { Attribute }
    MethodFunctionName
    PredicateSignatureOrEllipsis_(allowGhostKeyword: false,
                         allowNewKeyword: "twostate" present,
                         allowOlderKeyword: false))
  )
  FunctionSpec
  [ FunctionBody ]

FunctionSignatureOrEllipsis_(allowGhostKeyword) =
  FunctionSignature_(allowGhostKeyword) | ellipsis

FunctionSignature_(allowGhostKeyword, allowNewKeyword) =
  [ GenericParameters ]
  Formals(allowGhostKeyword, allowNewKeyword, allowOlderKeyword: true, 
          allowDefault: true)
  ":"
  ( Type
  | "(" GIdentType(allowGhostKeyword: false,
                   allowNewKeyword: false,
                   allowOlderKeyword: false,
                   allowNameOnlyKeyword: false,
                   allowDefault: false)
    ")"
  )

PredicateSignatureOrEllipsis_(allowGhostKeyword, allowNewKeyword, 
                              allowOlderKeyword) =
    PredicateSignature_(allowGhostKeyword, allowNewKeyword, allowOlderKeyword) 
  | ellipsis

PredicateSignature_(allowGhostKeyword, allowNewKeyword, allowOlderKeyword) =
  [ GenericParameters ]
  [ KType ]
  Formals(allowGhostKeyword, allowNewKeyword, allowOlderKeyword, 
          allowDefault: true)
  [
    ":"
    ( Type
    | "(" Ident ":" "bool" ")"
    )
  ]

FunctionBody = "{" Expression(allowLemma: true, allowLambda: true)
               "}" [ "by" "method" BlockStmt ]
</code></pre>

<h4 id="1725-specifications">17.2.5. Specifications</h4>

<h5 id="g-method-specification">17.2.5.1. Method specifications</h5>
<p>(<a href="#sec-method-specification">discussion</a>)</p>

<pre><code class="language-grammar">MethodSpec =
  { ModifiesClause(allowLambda: false)
  | RequiresClause(allowLabel: true)
  | EnsuresClause(allowLambda: false)
  | DecreasesClause(allowWildcard: true, allowLambda: false)
  }
</code></pre>

<h5 id="g-function-specification">17.2.5.2. Function specifications</h5>
<p>(<a href="#sec-function-specification">discussion</a>)</p>

<pre><code class="language-grammar">FunctionSpec =
  { RequiresClause(allowLabel: true)
  | ReadsClause(allowLemma: false, allowLambda: false, allowWild: true)
  | EnsuresClause(allowLambda: false)
  | DecreasesClause(allowWildcard: false, allowLambda: false)
  }
</code></pre>

<h5 id="g-lambda-specification">17.2.5.3. Lambda function specifications</h5>
<p>(<a href="#sec-lambda-specification">discussion</a>)</p>

<pre><code class="language-grammar">LambdaSpec =
  { ReadsClause(allowLemma: true, allowLambda: false, allowWild: true)
  | "requires" Expression(allowLemma: false, allowLambda: false)
  }
</code></pre>

<h5 id="g-iterator-specification">17.2.5.4. Iterator specifications</h5>
<p>(<a href="#sec-iterator-specification">discussion</a>)</p>

<pre><code class="language-grammar">IteratorSpec =
  { ReadsClause(allowLemma: false, allowLambda: false,
                                  allowWild: false)
  | ModifiesClause(allowLambda: false)
  | [ "yield" ] RequiresClause(allowLabel: !isYield)
  | [ "yield" ] EnsuresClause(allowLambda: false)
  | DecreasesClause(allowWildcard: false, allowLambda: false)
  }
</code></pre>

<h5 id="g-loop-specification">17.2.5.5. Loop specifications</h5>
<p>(<a href="#sec-loop-specification">discussion</a>)</p>

<pre><code class="language-grammar">LoopSpec =
  { InvariantClause_
  | DecreasesClause(allowWildcard: true, allowLambda: true)
  | ModifiesClause(allowLambda: true)
  }
</code></pre>

<h5 id="g-requires-clause">17.2.5.6. Requires clauses</h5>
<p>(<a href="#sec-requires-clause">discussion</a>)</p>

<pre><code class="language-grammar">RequiresClause(allowLabel) =
  "requires" { Attribute }
  [ LabelName ":" ]  // Label allowed only if allowLabel is true
  Expression(allowLemma: false, allowLambda: false)
</code></pre>

<h5 id="g-ensures-clause">17.2.5.7. Ensures clauses</h5>
<p>(<a href="#sec-ensures-clause">discussion</a>)</p>

<pre><code class="language-grammar">EnsuresClause(allowLambda) =
  "ensures" { Attribute } Expression(allowLemma: false, allowLambda)
</code></pre>

<h5 id="g-decreases-clause">17.2.5.8. Decreases clauses</h5>
<p>(<a href="#sec-decreases-clause">discussion</a>)</p>

<pre><code class="language-grammar">DecreasesClause(allowWildcard, allowLambda) =
  "decreases" { Attribute } DecreasesList(allowWildcard, allowLambda)

DecreasesList(allowWildcard, allowLambda) =
  PossiblyWildExpression(allowLambda, allowWildcard)
  { "," PossiblyWildExpression(allowLambda, allowWildcard) }

PossiblyWildExpression(allowLambda, allowWild) =
  ( "*"  // if allowWild is false, using '*' provokes an error
  | Expression(allowLemma: false, allowLambda)
  )
</code></pre>

<h5 id="g-modifies-clause">17.2.5.9. Modifies clauses</h5>
<p>(<a href="#sec-modifies-clause">discussion</a>)</p>

<pre><code class="language-grammar">ModifiesClause(allowLambda) =
  "modifies" { Attribute }
  FrameExpression(allowLemma: false, allowLambda)
  { "," FrameExpression(allowLemma: false, allowLambda) }
</code></pre>

<h5 id="g-invariant-clause">17.2.5.10. Invariant clauses</h5>
<p>(<a href="#sec-invariant-clause">discussion</a>)</p>

<pre><code class="language-grammar">InvariantClause_ =
  "invariant" { Attribute }
  Expression(allowLemma: false, allowLambda: true)
</code></pre>

<h5 id="g-reads-clause">17.2.5.11. Reads clauses</h5>
<p>(<a href="#sec-reads-clause">discussion</a>)</p>

<pre><code class="language-grammar">ReadsClause(allowLemma, allowLambda, allowWild) =
  "reads" { Attribute }
  PossiblyWildFrameExpression(allowLemma, allowLambda, allowWild)
  { "," PossiblyWildFrameExpression(allowLemma, allowLambda, allowWild) }
</code></pre>

<h5 id="g-frame-expression">17.2.5.12. Frame expressions</h5>
<p>(<a href="#sec-frame-expression">discussion</a>)</p>

<pre><code class="language-grammar">FrameExpression(allowLemma, allowLambda) =
  ( Expression(allowLemma, allowLambda) [ FrameField ]
  | FrameField
  )

FrameField = "`" IdentOrDigits

PossiblyWildFrameExpression(allowLemma, allowLambda, allowWild) =
  ( "*"  // error if !allowWild and '*'
  | FrameExpression(allowLemma, allowLambda)
  )
</code></pre>

<h4 id="g-statement">17.2.6. Statements</h4>

<h5 id="g-labeled-statement">17.2.6.1. Labeled statement</h5>

<p>(<a href="#sec-labeled-statement">discussion</a>)</p>

<pre><code class="language-grammar">Stmt = { "label" LabelName ":" } NonLabeledStmt
</code></pre>

<h5 id="g-nonlabeled-statement">17.2.6.2. Non-Labeled statement</h5>

<p>(<a href="#sec-statements">discussion</a>)</p>

<pre><code class="language-grammar">NonLabeledStmt =
  ( AssertStmt | AssumeStmt | BlockStmt | BreakStmt
  | CalcStmt | ExpectStmt | ForallStmt | IfStmt
  | MatchStmt | ModifyStmt
  | PrintStmt | ReturnStmt | RevealStmt
  | UpdateStmt | UpdateFailureStmt
  | VarDeclStatement | WhileStmt | ForLoopStmt | YieldStmt
  )
</code></pre>

<h5 id="g-break-continue-statement">17.2.6.3. Break and continue statements</h5>

<p>(<a href="#sec-break-continue-statement">discussion</a>)</p>

<pre><code class="language-grammar">BreakStmt =
  ( "break" LabelName ";"
  | "continue" LabelName ";"
  | { "break" } "break" ";"
  | { "break" } "continue" ";"
  )
</code></pre>

<h5 id="g-block-statement">17.2.6.4. Block statement</h5>

<p>(<a href="#sec-block-statement">discussion</a>)</p>

<pre><code class="language-grammar">BlockStmt = "{" { Stmt } "}"
</code></pre>

<h5 id="g-return-statement">17.2.6.5. Return statement</h5>

<p>(<a href="#sec-return-statement">discussion</a>)</p>

<pre><code class="language-grammar">ReturnStmt = "return" [ Rhs { "," Rhs } ] ";"
</code></pre>

<h5 id="g-yield-statement">17.2.6.6. Yield statement</h5>

<p>(<a href="#sec-yield-statement">discussion</a>)</p>

<pre><code class="language-grammar">YieldStmt = "yield" [ Rhs { "," Rhs } ] ";"
</code></pre>

<h5 id="g-update-and-call-statement">17.2.6.7. Update and call statement</h5>

<p>(<a href="#sec-update-and-call-statement">discussion</a>)</p>

<pre><code class="language-grammar">UpdateStmt =
  Lhs
  ( {Attribute} ";"
  |
    { "," Lhs }
    ( ":=" Rhs { "," Rhs }
    | ":|" [ "assume" ]
               Expression(allowLemma: false, allowLambda: true)
    )
    ";"
  )
</code></pre>

<h5 id="g-update-with-failure-statement">17.2.6.8. Update with failure statement</h5>

<p>(<a href="#sec-update-with-failure-statement">discussion</a>)</p>

<pre><code class="language-grammar">UpdateFailureStmt  =
  [ Lhs { "," Lhs } ]
  ":-"
  [ "expect"  | "assert" | "assume" ]
  Expression(allowLemma: false, allowLambda: false)
  { "," Rhs }
  ";"
</code></pre>

<h5 id="g-variable-declaration-statement">17.2.6.9. Variable declaration statement</h5>

<p>(<a href="#sec-variable-declaration-statement">discussion</a>)</p>

<pre><code class="language-grammar">VarDeclStatement =
  [ "ghost" ] "var" { Attribute }
  (
    LocalIdentTypeOptional
    { "," { Attribute } LocalIdentTypeOptional }
    [ ":="
      Rhs { "," Rhs }
    | ":-"
      [ "expect" | "assert" | "assume" ]
      Expression(allowLemma: false, allowLambda: false)
      { "," Rhs }
    | { Attribute }
      ":|"
      [ "assume" ] Expression(allowLemma: false, allowLambda: true)
    ]
  |
    CasePatternLocal
    ( ":=" | { Attribute } ":|" )
    Expression(allowLemma: false, allowLambda: true)
  )
  ";"

CasePatternLocal = 
  ( [ Ident ] "(" CasePatternLocal { "," CasePatternLocal } ")"
  | LocalIdentTypeOptional
  )
</code></pre>

<h5 id="g-guard">17.2.6.10. Guards</h5>

<p>(<a href="#sec-guard">discussion</a>)</p>

<pre><code class="language-grammar">Guard = ( "*"
        | "(" "*" ")"
        | Expression(allowLemma: true, allowLambda: true)
        )
</code></pre>

<h5 id="g-binding-guard">17.2.6.11. Binding guards</h5>

<p>(<a href="#sec-binding-guards">discussion</a>)</p>

<pre><code class="language-grammar">BindingGuard(allowLambda) =
  IdentTypeOptional { "," IdentTypeOptional }
  { Attribute }
  ":|"
  Expression(allowLemma: true, allowLambda)
</code></pre>

<h5 id="g-if-statement">17.2.6.12. If statement</h5>

<p>(<a href="#sec-if-statement">discussion</a>)</p>

<pre><code class="language-grammar">IfStmt = "if"
  ( AlternativeBlock(allowBindingGuards: true)
  |
    ( BindingGuard(allowLambda: true)
    | Guard
    )
    BlockStmt [ "else" ( IfStmt | BlockStmt ) ]
  )

AlternativeBlock(allowBindingGuards) =
  ( { AlternativeBlockCase(allowBindingGuards) }
  | "{" { AlternativeBlockCase(allowBindingGuards) } "}"
  )

AlternativeBlockCase(allowBindingGuards) =
  { "case"
    (
    BindingGuard(allowLambda: false) //permitted iff allowBindingGuards == true
    | Expression(allowLemma: true, allowLambda: false)
    ) "=&gt;" { Stmt }
  }
</code></pre>

<h5 id="g-while-statement">17.2.6.13. While Statement</h5>

<p>(<a href="#sec-while-statement">discussion</a>)</p>

<pre><code class="language-grammar">WhileStmt =
  "while"
  ( LoopSpec
    AlternativeBlock(allowBindingGuards: false)
  | Guard
    LoopSpec
    ( BlockStmt
    |           // no body
    )
  )
</code></pre>

<h5 id="g-for-statement">17.2.6.14. For statement</h5>

<p>(<a href="#sec-for-statement">discussion</a>)</p>

<pre><code class="language-grammar">ForLoopStmt =
  "for" IdentTypeOptional ":="
  Expression(allowLemma: false, allowLambda: false)
  ( "to" | "downto" )
  ( "*" | Expression(allowLemma: false, allowLambda: false)
  )
  LoopSpec
  ( BlockStmt
  |           // no body
  )
</code></pre>

<h5 id="g-match-statement">17.2.6.15. Match statement</h5>

<p>(<a href="#sec-match-statement">discussion</a>)</p>

<pre><code class="language-grammar">MatchStmt =
  "match"
  Expression(allowLemma: true, allowLambda: true)
  ( "{" { CaseStmt } "}"
  | { CaseStmt }
  )

CaseStmt = "case" ExtendedPattern "=&gt;" { Stmt }
</code></pre>

<h5 id="g-assert-statement">17.2.6.16. Assert statement</h5>

<p>(<a href="#sec-assert-statement">discussion</a>)</p>

<pre><code class="language-grammar">AssertStmt =
  "assert"
  { Attribute }
  [ LabelName ":" ]
  Expression(allowLemma: false, allowLambda: true)
  ( ";"
  | "by" BlockStmt
  )
</code></pre>

<h5 id="g-assume-statement">17.2.6.17. Assume statement</h5>

<p>(<a href="#sec-assume-statement">discussion</a>)</p>

<pre><code class="language-grammar">AssumeStmt =
  "assume"
  { Attribute }
  Expression(allowLemma: false, allowLambda: true)
  ";"
</code></pre>

<h5 id="g-expect-statement">17.2.6.18. Expect statement</h5>

<p>(<a href="#sec-expect-statement">discussion</a>)</p>

<pre><code class="language-grammar">ExpectStmt =
  "expect"
  { Attribute }
  Expression(allowLemma: false, allowLambda: true)
  [ "," Expression(allowLemma: false, allowLambda: true) ]
  ";"
</code></pre>

<h5 id="g-print-statement">17.2.6.19. Print statement</h5>

<p>(<a href="#sec-print-statement">discussion</a>)</p>

<pre><code class="language-grammar">PrintStmt =
  "print"
  Expression(allowLemma: false, allowLambda: true)
  { "," Expression(allowLemma: false, allowLambda: true) }
  ";"
</code></pre>

<h5 id="g-reveal-statement">17.2.6.20. Reveal statement</h5>

<p>(<a href="#sec-reveal-statement">discussion</a>)</p>

<pre><code class="language-grammar">RevealStmt =
  "reveal"
  Expression(allowLemma: false, allowLambda: true)
  { "," Expression(allowLemma: false, allowLambda: true) }
  ";"
</code></pre>
<h5 id="g-forall-statement">17.2.6.21. Forall statement</h5>

<p>(<a href="#sec-forall-statement">discussion</a>)</p>

<pre><code class="language-grammar">ForallStmt =
  "forall"
  ( "(" [ QuantifierDomain ] ")"
  | [ QuantifierDomain ]
  )
  { EnsuresClause(allowLambda: true) }
  [ BlockStmt ]
</code></pre>
<h5 id="g-modify-statement">17.2.6.22. Modify statement</h5>

<p>(<a href="#sec-modify-statement">discussion</a>)</p>

<pre><code class="language-grammar">ModifyStmt =
  "modify"
  { Attribute }
  FrameExpression(allowLemma: false, allowLambda: true)
  { "," FrameExpression(allowLemma: false, allowLambda: true) }
  ";"
</code></pre>

<h5 id="g-calc-statement">17.2.6.23. Calc statement</h5>

<p>(<a href="#sec-calc-statement">discussion</a>)</p>

<pre><code class="language-grammar">CalcStmt = "calc" { Attribute } [ CalcOp ] "{" CalcBody_ "}"

CalcBody_ = { CalcLine_ [ CalcOp ] Hints_ }

CalcLine_ = Expression(allowLemma: false, allowLambda: true) ";"

Hints_ = { ( BlockStmt | CalcStmt ) }

CalcOp =
  ( "==" [ "#" "["
           Expression(allowLemma: true, allowLambda: true) "]" ]
  | "&lt;" | "&gt;"
  | "!=" | "&lt;=" | "&gt;="
  | "&lt;==&gt;" | "==&gt;" | "&lt;=="
  )
</code></pre>

<h5 id="g-opaque-block">17.2.6.24. Opaque block</h5>

<p>(<a href="#sec-opaque-block">discussion</a>)</p>

<pre><code class="language-grammar">OpaqueBlock = "opaque" OpaqueSpec BlockStmt
  
OpaqueSpec = {
  | ModifiesClause(allowLambda: false)
  | EnsuresClause(allowLambda: false)
}
</code></pre>

<h4 id="1727-expressions">17.2.7. Expressions</h4>

<h5 id="g-top-level-expression">17.2.7.1. Top-level expression</h5>

<p>(<a href="#sec-top-level-expression">discussion</a>)</p>

<pre><code class="language-grammar">Expression(allowLemma, allowLambda, allowBitwiseOps = true) =
  EquivExpression(allowLemma, allowLambda, allowBitwiseOps)
  [ ";" Expression(allowLemma, allowLambda, allowBitwiseOps) ]
</code></pre>

<p>The allowLemma argument says whether or not the expression
to be parsed is allowed to have the form <code class="language-dafny highlighter-rouge"><span class="n">S</span><span class="p">;</span><span class="n">E</span></code> where <code class="language-dafny highlighter-rouge"><span class="n">S</span></code> is a call to a lemma.
allowLemma should be passed in as false whenever the expression to
be parsed sits in a context that itself is terminated by a semi-colon.</p>

<p>The allowLambda says whether or not the expression to be parsed is
allowed to be a lambda expression.  More precisely, an identifier or
parenthesized, comma-delimited list of identifiers is allowed to
continue as a lambda expression (that is, continue with a <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code>, <code class="language-dafny highlighter-rouge"><span class="kr">requires</span></code>,
or <code class="language-dafny highlighter-rouge"><span class="o">=&gt;</span></code>) only if allowLambda is true.  This affects function/method/iterator
specifications, if/while statements with guarded alternatives, and expressions
in the specification of a lambda expression itself.</p>

<h5 id="g-equivalence-expression">17.2.7.2. Equivalence expression</h5>

<p>(<a href="#sec-equivalence-expression">discussion</a>)</p>

<pre><code class="language-grammar">EquivExpression(allowLemma, allowLambda, allowBitwiseOps) =
  ImpliesExpliesExpression(allowLemma, allowLambda, allowBitwiseOps)
  { "&lt;==&gt;" ImpliesExpliesExpression(allowLemma, allowLambda, allowBitwiseOps) }
</code></pre>

<h5 id="g-implies-expression">17.2.7.3. Implies expression</h5>

<p>(<a href="#sec-implies-expression">discussion</a>)</p>

<pre><code class="language-grammar">ImpliesExpliesExpression(allowLemma, allowLambda, allowBitwiseOps) =
  LogicalExpression(allowLemma, allowLambda)
  [ (  "==&gt;" ImpliesExpression(allowLemma, allowLambda, allowBitwiseOps)
    | "&lt;==" LogicalExpression(allowLemma, allowLambda, allowBitwiseOps)
            { "&lt;==" LogicalExpression(allowLemma, allowLambda, allowBitwiseOps) }
    )
  ]

ImpliesExpression(allowLemma, allowLambda, allowBitwiseOps) =
  LogicalExpression(allowLemma, allowLambda, allowBitwiseOps)
  [  "==&gt;" ImpliesExpression(allowLemma, allowLambda, allowBitwiseOps) ]
</code></pre>

<h5 id="g-logical-expression">17.2.7.4. Logical expression</h5>

<p>(<a href="#sec-logical-expression">discussion</a>)</p>

<pre><code class="language-grammar">LogicalExpression(allowLemma, allowLambda, allowBitwiseOps) =
  [ "&amp;&amp;" | "||" ]
  RelationalExpression(allowLemma, allowLambda, allowBitwiseOps)
  { ( "&amp;&amp;" | "||" )
    RelationalExpression(allowLemma, allowLambda, allowBitwiseOps)
  }
</code></pre>

<h5 id="g-relational-expression">17.2.7.5. Relational expression</h5>

<p>(<a href="#sec-relational-expression">discussion</a>)</p>

<pre><code class="language-grammar">RelationalExpression(allowLemma, allowLambda, allowBitwiseOps) =
  ShiftTerm(allowLemma, allowLambda, allowBitwiseOps)
  { RelOp ShiftTerm(allowLemma, allowLambda, allowBitwiseOps) }

RelOp =
  ( "=="
    [ "#" "[" Expression(allowLemma: true, allowLambda: true) "]" ]
  | "!="
    [ "#" "[" Expression(allowLemma: true, allowLambda: true) "]" ]
  | "&lt;" | "&gt;" | "&lt;=" | "&gt;="
  | "in"
  | "!in"
  | "!!"
  )
</code></pre>

<h5 id="g-bit-shift-expression">17.2.7.6. Bit-shift expression</h5>

<p>(<a href="#sec-bit-shift-expression">discussion</a>)</p>

<pre><code class="language-grammar">ShiftTerm(allowLemma, allowLambda, allowBitwiseOps) =
  Term(allowLemma, allowLambda, allowBitwiseOps)
  { ShiftOp Term(allowLemma, allowLambda, allowBitwiseOps) }

ShiftOp = ( "&lt;&lt;" | "&gt;&gt;" )
</code></pre>

<h5 id="g-term">17.2.7.7. Term (addition operations)</h5>

<p>(<a href="#sec-addition-expression">discussion</a>)</p>

<pre><code class="language-grammar">Term(allowLemma, allowLambda, allowBitwiseOps) =
  Factor(allowLemma, allowLambda, allowBitwiseOps)
  { AddOp Factor(allowLemma, allowLambda, allowBitwiseOps) }

AddOp = ( "+" | "-" )
</code></pre>

<h5 id="g-factor">17.2.7.8. Factor (multiplication operations)</h5>

<p>(<a href="#sec-multiplication-expression">discussion</a>)</p>

<pre><code class="language-grammar">Factor(allowLemma, allowLambda, allowBitwiseOps) =
  BitvectorFactor(allowLemma, allowLambda, allowBitwiseOps)
  { MulOp BitvectorFactor(allowLemma, allowLambda, allowBitwiseOps) }

MulOp = ( "*" | "/" | "%" )
</code></pre>

<h5 id="g-bit-vector-expression">17.2.7.9. Bit-vector expression</h5>
<p>(<a href="#sec-bitvector-expression">discussion</a>)</p>

<pre><code class="language-grammar">BitvectorFactor(allowLemma, allowLambda, allowBitwiseOps) =
  AsExpression(allowLemma, allowLambda, allowBitwiseOps)
  { BVOp AsExpression(allowLemma, allowLambda, allowBitwiseOps) }

BVOp = ( "|" | "&amp;" | "^" )
</code></pre>

<p>If <code class="language-dafny highlighter-rouge"><span class="n">allowBitwiseOps</span></code> is false, it is an error to have a bitvector operation.</p>

<h5 id="g-as-is-expression">17.2.7.10. As/Is expression</h5>
<p>(<a href="#sec-as-is-expression">discussion</a>)</p>

<pre><code class="language-grammar">AsExpression(allowLemma, allowLambda, allowBitwiseOps) =
  UnaryExpression(allowLemma, allowLambda, allowBitwiseOps)
  { ( "as" | "is" ) Type }
</code></pre>

<h5 id="g-unary-expression">17.2.7.11. Unary expression</h5>
<p>(<a href="#sec-unary-expression">discussion</a>)</p>

<pre><code class="language-grammar">UnaryExpression(allowLemma, allowLambda, allowBitwiseOps) =
  ( "-" UnaryExpression(allowLemma, allowLambda, allowBitwiseOps)
  | "!" UnaryExpression(allowLemma, allowLambda, allowBitwiseOps)
  | PrimaryExpression(allowLemma, allowLambda, allowBitwiseOps)
  )
</code></pre>

<h5 id="g-primary-expression">17.2.7.12. Primary expression</h5>
<p>(<a href="#sec-primary-expression">discussion</a>)</p>

<pre><code class="language-grammar">PrimaryExpression(allowLemma, allowLambda, allowBitwiseOps) =
  ( NameSegment { Suffix }
  | LambdaExpression(allowLemma, allowBitwiseOps)
  | MapDisplayExpr { Suffix }
  | SeqDisplayExpr { Suffix }
  | SetDisplayExpr { Suffix }
  | EndlessExpression(allowLemma, allowLambda, allowBitwiseOps)
  | ConstAtomExpression { Suffix }
  )
</code></pre>

<h5 id="g-lambda-expression">17.2.7.13. Lambda expression</h5>
<p>(<a href="#sec-lambda-expression">discussion</a>)</p>

<pre><code class="language-grammar">LambdaExpression(allowLemma, allowBitwiseOps) =
  ( WildIdent
  | "(" [ IdentTypeOptional { "," IdentTypeOptional } ] ")"
  )
  LambdaSpec
  "=&gt;"
  Expression(allowLemma, allowLambda: true, allowBitwiseOps)
</code></pre>

<h5 id="g-lhs-expression">17.2.7.14. Left-hand-side expression</h5>
<p>(<a href="#sec-lhs-expression">discussion</a>) {</p>

<pre><code class="language-grammar">Lhs =
  ( NameSegment { Suffix }
  | ConstAtomExpression Suffix { Suffix }
  )
</code></pre>

<h5 id="g-rhs-expression">17.2.7.15. Right-hand-side expression</h5>
<p>(<a href="#sec-rhs-expression">discussion</a>)</p>

<pre><code class="language-grammar">Rhs =
    ArrayAllocation
  | ObjectAllocation_
  | Expression(allowLemma: false, allowLambda: true, allowBitwiseOps: true)
  | HavocRhs_
  )
  { Attribute }
</code></pre>

<h5 id="g-array-allocation-expression">17.2.7.16. Array allocation right-hand-side expression</h5>
<p>(<a href="#sec-array-allocation">discussion</a>)</p>

<pre><code class="language-grammar">ArrayAllocation_ =
  "new" [ Type ] "[" [ Expressions ] "]"
  [ "(" Expression(allowLemma: true, allowLambda: true) ")"
  | "[" [ Expressions ] "]"
  ]
</code></pre>

<h5 id="g-object-allocation-expression">17.2.7.17. Object allocation right-hand-side expression</h5>
<p>(<a href="#sec-object-allocation">discussion</a>)</p>

<pre><code class="language-grammar">ObjectAllocation_ = "new" Type [ "." TypeNameOrCtorSuffix ]
                               [ "(" [ Bindings ] ")" ]
</code></pre>

<h5 id="g-havoc-expression">17.2.7.18. Havoc right-hand-side expression</h5>
<p>(<a href="#sec-havoc-expression">discussion</a>)</p>

<pre><code class="language-grammar">HavocRhs_ = "*"
</code></pre>

<h5 id="g-atomic-expression">17.2.7.19. Atomic expressions</h5>
<p>(<a href="#sec-atomic-expression">discussion</a>)</p>

<pre><code class="language-grammar">ConstAtomExpression =
  ( LiteralExpression
  | ThisExpression_
  | FreshExpression_
  | AllocatedExpression_
  | UnchangedExpression_
  | OldExpression_
  | CardinalityExpression_
  | ParensExpression
  )
</code></pre>

<h5 id="g-literal-expression">17.2.7.20. Literal expressions</h5>
<p>(<a href="#sec-literal-expression">discussion</a>)</p>

<pre><code class="language-grammar">LiteralExpression =
 ( "false" | "true" | "null" | Nat | Dec | ApproxLiteral |
   charToken | stringToken )

ApproxLiteral = "~" [ "-" ] Dec

Nat = ( digits | hexdigits )

Dec = ( realnumber | digits "." | "." ( digits | realnumber ) )
</code></pre>

<h5 id="g-this-expression">17.2.7.21. This expression</h5>
<p>(<a href="#sec-this-expression">discussion</a>)</p>

<pre><code class="language-grammar">ThisExpression_ = "this"
</code></pre>

<h5 id="g-old-expression">17.2.7.22. Old and Old@ Expressions</h5>
<p>(<a href="#sec-old-expression">discussion</a>)</p>

<pre><code class="language-grammar">OldExpression_ =
  "old" [ "@" LabelName ]
  "(" Expression(allowLemma: true, allowLambda: true) ")"
</code></pre>

<h5 id="g-fresh-expression">17.2.7.23. Fresh Expressions</h5>
<p>(<a href="#sec-fresh-expression">discussion</a>)</p>

<pre><code class="language-grammar">FreshExpression_ =
  "fresh" [ "@" LabelName ]
  "(" Expression(allowLemma: true, allowLambda: true) ")"
</code></pre>

<h5 id="g-allocated-expression">17.2.7.24. Allocated Expressions</h5>
<p>(<a href="#sec-allocated-expression">discussion</a>)</p>

<pre><code class="language-grammar">AllocatedExpression_ =
  "allocated" "(" Expression(allowLemma: true, allowLambda: true) ")"
</code></pre>

<h5 id="g-unchanged-expression">17.2.7.25. Unchanged Expressions</h5>
<p>(<a href="#sec-unchanged-expression">discussion</a>)</p>

<pre><code class="language-grammar">UnchangedExpression_ =
  "unchanged" [ "@" LabelName ]
  "(" FrameExpression(allowLemma: true, allowLambda: true)
      { "," FrameExpression(allowLemma: true, allowLambda: true) }
  ")"
</code></pre>

<h5 id="g-cardinality-expression">17.2.7.26. Cardinality Expressions</h5>
<p>(<a href="#sec-cardinality-expression">discussion</a>)</p>

<pre><code class="language-grammar">CardinalityExpression_ =
  "|" Expression(allowLemma: true, allowLambda: true) "|"
</code></pre>

<h5 id="g-parenthesized-expression">17.2.7.27. Parenthesized Expression</h5>
<p>(<a href="#sec-parenthesized-expression">discussion</a>)</p>

<pre><code class="language-grammar">ParensExpression =
  "(" [ TupleArgs ] ")"

TupleArgs =
  [ "ghost" ]
  ActualBinding(isGhost) // argument is true iff the ghost modifier is present
  { ","
    [ "ghost" ]
    ActualBinding(isGhost) // argument is true iff the ghost modifier is present
  }
</code></pre>

<h5 id="g-sequence-display-expression">17.2.7.28. Sequence Display Expression</h5>
<p>(<a href="#sec-seq-comprehension">discussion</a>)</p>

<pre><code class="language-grammar">SeqDisplayExpr =
  ( "[" [ Expressions ] "]"
  | "seq" [ GenericInstantiation ]
    "(" Expression(allowLemma: true, allowLambda: true)
    "," Expression(allowLemma: true, allowLambda: true)
    ")"
  )
</code></pre>

<h5 id="g-set-display-expression">17.2.7.29. Set Display Expression</h5>
<p>(<a href="#sec-set-display-expression">discussion</a>)</p>

<pre><code class="language-grammar">SetDisplayExpr =
  ( [ "iset" | "multiset" ] "{" [ Expressions ] "}"
  | "multiset" "(" Expression(allowLemma: true,
                              allowLambda: true) ")"
  )
</code></pre>

<h5 id="g-map-display-expression">17.2.7.30. Map Display Expression</h5>
<p>(<a href="#sec-map-display-expression">discussion</a>)</p>

<pre><code class="language-grammar">MapDisplayExpr =
  ("map" | "imap" ) "[" [ MapLiteralExpressions ] "]"

MapLiteralExpressions =
  Expression(allowLemma: true, allowLambda: true)
  ":=" 
  Expression(allowLemma: true, allowLambda: true)
  { "," 
    Expression(allowLemma: true, allowLambda: true)
    ":=" 
    Expression(allowLemma: true, allowLambda: true)
  }
</code></pre>

<h5 id="g-endless-expression">17.2.7.31. Endless Expression</h5>
<p>(<a href="#sec-endless-expression">discussion</a>)</p>

<pre><code class="language-grammar">EndlessExpression(allowLemma, allowLambda, allowBitwiseOps) =
  ( IfExpression(allowLemma, allowLambda, allowBitwiseOps)
  | MatchExpression(allowLemma, allowLambda, allowBitwiseOps)
  | QuantifierExpression(allowLemma, allowLambda)
  | SetComprehensionExpr(allowLemma, allowLambda, allowBitwiseOps)
  | StmtInExpr
    Expression(allowLemma, allowLambda, allowBitwiseOps)
  | LetExpression(allowLemma, allowLambda, allowBitwiseOps)
  | MapComprehensionExpr(allowLemma, allowLambda, allowBitwiseOps)
  )
</code></pre>

<h5 id="g-if-expression">17.2.7.32. If expression</h5>
<p>(<a href="#sec-if-expression">discussion</a>)</p>

<pre><code class="language-grammar">IfExpression(allowLemma, allowLambda, allowBitwiseOps) =
    "if" ( BindingGuard(allowLambda: true)
         | Expression(allowLemma: true, allowLambda: true, allowBitwiseOps: true)
         )
    "then" Expression(allowLemma: true, allowLambda: true, allowBitwiseOps: true)
    "else" Expression(allowLemma, allowLambda, allowBitwiseOps)
</code></pre>

<h5 id="g-match-expression">17.2.7.33. Match Expression</h5>
<p>(<a href="#sec-match-expression">discussion</a>)</p>

<pre><code class="language-grammar">MatchExpression(allowLemma, allowLambda, allowBitwiseOps) =
  "match"
  Expression(allowLemma, allowLambda, allowBitwiseOps)
  ( "{" { CaseExpression(allowLemma: true, allowLambda, allowBitwiseOps: true) } "}"
  | { CaseExpression(allowLemma, allowLambda, allowBitwiseOps) }
  )

CaseExpression(allowLemma, allowLambda, allowBitwiseOps) =
  "case" { Attribute } ExtendedPattern "=&gt;" Expression(allowLemma, allowLambda, allowBitwiseOps)
</code></pre>

<h5 id="g-pattern">17.2.7.34. Case and Extended Patterns</h5>
<p>(<a href="#sec-case-pattern">discussion</a>)</p>

<pre><code class="language-grammar">CasePattern =
  ( IdentTypeOptional
  | [Ident] "(" [ CasePattern { "," CasePattern } ] ")"
  )

SingleExtendedPattern =
  ( PossiblyNegatedLiteralExpression
  | IdentTypeOptional
  | [ Ident ] "(" [ SingleExtendedPattern { "," SingleExtendedPattern } ] ")"
  )

ExtendedPattern =
  ( [ "|" ] SingleExtendedPattern { "|" SingleExtendedPattern } )

PossiblyNegatedLiteralExpression =
  ( "-" ( Nat | Dec )
  | LiteralExpression
  )
</code></pre>

<h5 id="g-quantifier-expression">17.2.7.35. Quantifier expression</h5>
<p>(<a href="#sec-quantifier-expression">discussion</a>)</p>

<pre><code class="language-grammar">QuantifierExpression(allowLemma, allowLambda) =
  ( "forall" | "exists" ) QuantifierDomain "::"
  Expression(allowLemma, allowLambda)
</code></pre>

<h5 id="g-set-comprehension-expression">17.2.7.36. Set Comprehension Expressions</h5>
<p>(<a href="#sec-set-comprehension-expression">discussion</a>)</p>

<pre><code class="language-grammar">SetComprehensionExpr(allowLemma, allowLambda) =
  [ "set" | "iset" ]
  QuantifierDomain(allowLemma, allowLambda)
  [ "::" Expression(allowLemma, allowLambda) ]
</code></pre>

<h5 id="g-map-comprehension-expression">17.2.7.37. Map Comprehension Expression</h5>
<p>(<a href="#sec-map-comprehension-expression">discussion</a>)</p>

<pre><code class="language-grammar">MapComprehensionExpr(allowLemma, allowLambda) =
  ( "map" | "imap" )
  QuantifierDomain(allowLemma, allowLambda)
  "::"
  Expression(allowLemma, allowLambda)
  [ ":=" Expression(allowLemma, allowLambda) ]
</code></pre>

<h5 id="g-statement-in-expression">17.2.7.38. Statements in an Expression</h5>
<p>(<a href="#sec-statement-in-an-expression">discussion</a>)</p>

<pre><code class="language-grammar">StmtInExpr = ( AssertStmt | AssumeStmt | ExpectStmt
             | RevealStmt | CalcStmt | ForallStmt
             )
</code></pre>

<h5 id="g-let-expression">17.2.7.39. Let and Let or Fail Expression</h5>
<p>(<a href="#sec-let-expression">discussion</a>)</p>

<pre><code class="language-grammar">LetExpression(allowLemma, allowLambda) =
  (
    [ "ghost" ] "var" CasePattern { "," CasePattern }
    ( ":=" | ":-" | { Attribute } ":|" )
    Expression(allowLemma: false, allowLambda: true)
    { "," Expression(allowLemma: false, allowLambda: true) }
  |
    ":-"
    Expression(allowLemma: false, allowLambda: true)
  )
  ";"
  Expression(allowLemma, allowLambda)
</code></pre>

<h5 id="g-name-segment">17.2.7.40. Name Segment</h5>
<p>(<a href="#sec-name-segment">discussion</a>)</p>

<pre><code class="language-grammar">NameSegment = Ident [ GenericInstantiation | HashCall ]
</code></pre>

<h5 id="g-hash-call">17.2.7.41. Hash Call</h5>
<p>(<a href="#sec-hash-call">discussion</a>)</p>

<pre><code class="language-grammar">HashCall = "#" [ GenericInstantiation ]
  "[" Expression(allowLemma: true, allowLambda: true) "]"
  "(" [ Bindings ] ")"
</code></pre>

<h5 id="g-suffix">17.2.7.42. Suffix</h5>
<p>(<a href="#sec-suffix">discussion</a>)</p>

<pre><code class="language-grammar">Suffix =
  ( AugmentedDotSuffix_
  | DatatypeUpdateSuffix_
  | SubsequenceSuffix_
  | SlicesByLengthSuffix_
  | SequenceUpdateSuffix_
  | SelectionSuffix_
  | ArgumentListSuffix_
  )
</code></pre>

<h5 id="g-augmented-dot-suffix">17.2.7.43. Augmented Dot Suffix</h5>
<p>(<a href="#sec-augmented-dot-suffix">discussion</a>)</p>

<pre><code class="language-grammar">AugmentedDotSuffix_ = "." DotSuffix
                      [ GenericInstantiation | HashCall ]
</code></pre>

<h5 id="g-datatype-update-suffix">17.2.7.44. Datatype Update Suffix</h5>
<p>(<a href="#sec-datatype-update-suffix">discussion</a>)</p>

<pre><code class="language-grammar">DatatypeUpdateSuffix_ =
  "." "(" MemberBindingUpdate { "," MemberBindingUpdate } ")"

MemberBindingUpdate =
  ( ident | digits )
  ":=" Expression(allowLemma: true, allowLambda: true)
</code></pre>

<h5 id="g-subsequence-suffix">17.2.7.45. Subsequence Suffix</h5>
<p>(<a href="#sec-subsequence-suffix">discussion</a>)</p>

<pre><code class="language-grammar">SubsequenceSuffix_ =
  "[" [ Expression(allowLemma: true, allowLambda: true) ]
      ".." [ Expression(allowLemma: true, allowLambda: true) ]
  "]"
</code></pre>

<h5 id="g-subsequence-slices-suffix">17.2.7.46. Subsequence Slices Suffix</h5>
<p>(<a href="#sec-subsequence-slices-suffix">discussion</a>)</p>

<pre><code class="language-grammar">SlicesByLengthSuffix_ =
  "[" Expression(allowLemma: true, allowLambda: true) ":"
      [
        Expression(allowLemma: true, allowLambda: true)
        { ":" Expression(allowLemma: true, allowLambda: true) }
        [ ":" ]
      ]
  "]"
</code></pre>

<h5 id="g-sequence-update-suffix">17.2.7.47. Sequence Update Suffix</h5>
<p>(<a href="#sec-sequence-update-suffix">discussion</a>)</p>

<pre><code class="language-grammar">SequenceUpdateSuffix_ =
  "[" Expression(allowLemma: true, allowLambda: true)
      ":=" Expression(allowLemma: true, allowLambda: true)
  "]"
</code></pre>

<h5 id="g-selection-suffix">17.2.7.48. Selection Suffix</h5>
<p>(<a href="#sec-selection-suffix">discussion</a>)</p>

<pre><code class="language-grammar">SelectionSuffix_ =
  "[" Expression(allowLemma: true, allowLambda: true)
      { "," Expression(allowLemma: true, allowLambda: true) }
  "]"
</code></pre>

<h5 id="g-argument-list-suffix">17.2.7.49. Argument List Suffix</h5>
<p>(<a href="#sec-argument-list-suffix">discussion</a>)</p>

<pre><code class="language-grammar">ArgumentListSuffix_ = "(" [ Expressions ] ")"
</code></pre>

<h5 id="g-expression-list">17.2.7.50. Expression Lists</h5>
<p>(<a href="#sec-expression-list">discussion</a>)</p>

<pre><code class="language-grammar">Expressions =
  Expression(allowLemma: true, allowLambda: true)
  { "," Expression(allowLemma: true, allowLambda: true) }
</code></pre>

<h5 id="g-parameter-bindings">17.2.7.51. Parameter Bindings</h5>
<p>(<a href="#sec-parameter-bindings">discussion</a>)</p>

<pre><code class="language-grammar">ActualBindings =
  ActualBinding
  { "," ActualBinding }

ActualBinding(isGhost = false) =
  [ NoUSIdentOrDigits ":=" ]
  Expression(allowLemma: true, allowLambda: true)
</code></pre>

<h5 id="g-quantifier-domain">17.2.7.52. Quantifier domains</h5>

<pre><code class="language-grammar">QuantifierDomain(allowLemma, allowLambda) =
  QuantifierVarDecl(allowLemma, allowLambda) 
  { "," QuantifierVarDecl(allowLemma, allowLambda) }

QuantifierVarDecl(allowLemma, allowLambda) =
  IdentTypeOptional
  [ "&lt;-" Expression(allowLemma, allowLambda) ]
  { Attribute }
  [ | Expression(allowLemma, allowLambda) ]
</code></pre>

<h5 id="172753-basic-name-and-type-combinations">17.2.7.53. Basic name and type combinations</h5>

<pre><code class="language-grammar">Ident = ident

DotSuffix = ( ident | digits | "requires" | "reads" )

NoUSIdent = ident - "_" { idchar }

WildIdent = NoUSIdent | "_"

IdentOrDigits = Ident | digits
NoUSIdentOrDigits = NoUSIdent | digits
ModuleName = NoUSIdent
ClassName = NoUSIdent    // also traits
DatatypeName = NoUSIdent
DatatypeMemberName = NoUSIdentOrDigits
NewtypeName = NoUSIdent
SynonymTypeName = NoUSIdent
IteratorName = NoUSIdent
TypeVariableName = NoUSIdent
MethodFunctionName = NoUSIdentOrDigits
LabelName = NoUSIdentOrDigits
AttributeName = NoUSIdent
ExportId = NoUSIdentOrDigits
TypeNameOrCtorSuffix = NoUSIdentOrDigits

ModuleQualifiedName = ModuleName { "." ModuleName }

IdentType = WildIdent ":" Type

FIdentType = NoUSIdentOrDigits ":" Type

CIdentType = NoUSIdentOrDigits [ ":" Type ]

GIdentType(allowGhostKeyword, allowNewKeyword, allowOlderKeyword, allowNameOnlyKeyword, allowDefault) =
  { "ghost" | "new" | "nameonly" | "older" } IdentType
  [ ":=" Expression(allowLemma: true, allowLambda: true) ]

LocalIdentTypeOptional = WildIdent [ ":" Type ]

IdentTypeOptional = WildIdent [ ":" Type ]

TypeIdentOptional =
  { Attribute }
  { "ghost" | "nameonly" } [ NoUSIdentOrDigits ":" ] Type
  [ ":=" Expression(allowLemma: true, allowLambda: true) ]

FormalsOptionalIds = "(" [ TypeIdentOptional
                           { "," TypeIdentOptional } ] ")"

</code></pre>

<!--PDF NEWPAGE-->
<h2 id="18-testing-syntax-rendering">18. Testing syntax rendering</h2>

<p>Sample math B: $a \to b$ or</p>
<p style="text-align: center;">$$ a \to \pi $$</p>
<p>or ( a \top ) or [ a \to \pi ]</p>

<p>Colors
<!-- %no-check --></p>
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">integer</span> <span class="n">literal</span><span class="o">:</span>  <span class="mi">10</span>
<span class="n">hex</span> <span class="n">literal</span><span class="o">:</span>      <span class="mh">0xDEAD</span>
<span class="kt">real</span> <span class="n">literal</span><span class="o">:</span>     <span class="mf">1.1</span>
<span class="n">boolean</span> <span class="n">literal</span><span class="o">:</span>  <span class="kc">true</span> <span class="kc">false</span>
<span class="kt">char</span> <span class="n">literal</span><span class="o">:</span>     <span class="sc">'c'</span>
<span class="kt">string</span> <span class="n">literal</span><span class="o">:</span>   <span class="s2">"abc"</span>
<span class="n">verbatim</span> <span class="kt">string</span><span class="o">:</span>  <span class="sx">@"abc"</span>
<span class="n">ident</span><span class="o">:</span>            <span class="n">ijk</span>
<span class="kr">type</span><span class="o">:</span>             <span class="kt">int</span>
<span class="n">generic</span> <span class="kr">type</span><span class="o">:</span>     <span class="kt">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">operator</span><span class="o">:</span>         <span class="o">&lt;=</span>
<span class="n">punctuation</span><span class="o">:</span>      <span class="p">{</span> <span class="p">}</span>
<span class="n">keyword</span><span class="o">:</span>          <span class="kr">while</span>
<span class="n">spec</span><span class="o">:</span>             <span class="kr">requires</span>
<span class="n">comment</span><span class="o">:</span>          <span class="c1">// comment</span>
<span class="n">attribute</span>         <span class="p">{</span><span class="o">:</span> <span class="n">name</span> <span class="p">}</span>
<span class="n">error</span><span class="o">:</span>            <span class="err">$</span>
</code></pre></div></div>

<p>Syntax color tests:</p>

<!-- %no-check -->
<div class="language-dafny highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="n">integer</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">00</span> <span class="mi">20</span> <span class="mi">01</span> <span class="mi">0_1</span>
<span class="n">float</span><span class="o">:</span>   <span class="o">.</span><span class="mi">0</span> <span class="mf">1.0</span> <span class="mi">1</span><span class="o">.</span> <span class="mf">0_1.1_0</span>
<span class="n">bad</span><span class="o">:</span>    <span class="err">0_</span>
<span class="n">hex</span><span class="o">:</span>    <span class="mh">0x10_abcdefABCDEF</span>
<span class="kt">string</span><span class="o">:</span>   <span class="s2">"string \n \t \r \0"</span> <span class="s2">"a\"b"</span> <span class="s2">"'"</span> <span class="s2">"\'"</span> <span class="s2">""</span>
<span class="kt">string</span><span class="o">:</span>   <span class="s2">"!@#$%^&amp;*()_-+={}[]|:;\\&lt;&gt;,.?/~`"</span>
<span class="kt">string</span><span class="o">:</span>   <span class="s2">"\u1234 "</span>
<span class="kt">string</span><span class="o">:</span>   <span class="s2">"     "</span> <span class="o">:</span> <span class="s2">"\0\n\r\t\'\"\\"</span>
<span class="n">notstring</span><span class="o">:</span> <span class="err">"abcde</span>
<span class="n">notstring</span><span class="o">:</span> <span class="err">"\u123 " : "x\Zz" : "x\ux"</span>
<span class="n">vstring</span><span class="o">:</span>  <span class="sx">@""</span> <span class="sx">@"a"</span> <span class="sx">@""""</span> <span class="sx">@"'\"</span> <span class="sx">@"\u"</span>
<span class="n">vstring</span><span class="o">:</span>  <span class="sx">@"xx""y y""zz "</span>
<span class="n">vstring</span><span class="o">:</span>  <span class="sx">@" "</span> <span class="sx">@"       "</span>
<span class="n">vstring</span><span class="o">:</span>  <span class="sx">@"x
x"</span>
<span class="n">bad</span><span class="o">:</span>      <span class="err">@</span><span class="o">!</span>
<span class="kt">char</span><span class="o">:</span>    <span class="sc">'a'</span> <span class="sc">'\n'</span> <span class="sc">'\''</span> <span class="sc">'"'</span> <span class="sc">'\"'</span> <span class="sc">' '</span> <span class="sc">'\\'</span>
<span class="kt">char</span><span class="o">:</span>    <span class="sc">'\0'</span> <span class="sc">'\r'</span> <span class="sc">'\t'</span>  <span class="sc">'\u1234'</span>
<span class="n">badchar</span><span class="o">:</span>  <span class="err">$</span> <span class="p">`</span>
<span class="n">ids</span><span class="o">:</span>  <span class="err">'\u123'</span>   <span class="err">'\Z'</span>  <span class="err">'\u'</span>  <span class="err">'\u2222Z'</span>
<span class="n">ids</span><span class="o">:</span>  <span class="err">'\u123ZZZ'</span>     <span class="err">'\u2222Z'</span>
<span class="n">ids</span><span class="o">:</span> <span class="err">'a : a'</span> <span class="o">:</span> <span class="err">'ab'</span> <span class="o">:</span>  <span class="sc">'a'</span><span class="n">b'</span> <span class="o">:</span> <span class="sc">'a''b'</span>
<span class="n">ids</span><span class="o">:</span>  <span class="n">a_b</span> <span class="err">_</span><span class="n">ab</span> <span class="n">ab?</span> <span class="err">_0</span>
<span class="n">id</span><span class="o">-</span><span class="kr">label</span><span class="o">:</span>  <span class="n">a</span><span class="err">@</span><span class="kr">label</span>
<span class="n">literal</span><span class="o">:</span>  <span class="kc">true</span> <span class="kc">false</span> <span class="kc">null</span>
<span class="n">op</span><span class="o">:</span>      <span class="o">-</span> <span class="o">!</span> <span class="err">~</span> <span class="n">x</span>  <span class="o">-!</span><span class="err">~</span><span class="n">x</span>
<span class="n">op</span><span class="o">:</span>      <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span> <span class="o">/</span> <span class="n">e</span> <span class="o">%</span> <span class="n">f</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="n">e</span><span class="o">%</span><span class="n">f</span>
<span class="n">op</span><span class="o">:</span>      <span class="o">&lt;=</span> <span class="o">&gt;=</span> <span class="o">&lt;</span> <span class="o">&gt;</span> <span class="o">==</span> <span class="o">!=</span> <span class="n">b</span><span class="o">&amp;&amp;</span><span class="n">c</span> <span class="o">||</span> <span class="o">==&gt;</span> <span class="o">&lt;==&gt;</span> <span class="o">&lt;==</span>
<span class="n">op</span><span class="o">:</span>      <span class="o">!=</span><span class="err">#</span> <span class="o">!!</span> <span class="ow">in</span> <span class="o">!</span><span class="ow">in</span>
<span class="n">op</span><span class="o">:</span>      <span class="o">!</span><span class="ow">in</span><span class="err"></span>  <span class="o">!</span><span class="ow">in</span><span class="err"></span>
<span class="n">not</span> <span class="n">op</span><span class="o">:</span>  <span class="o">!</span><span class="n">inx</span>
<span class="n">punc</span><span class="o">:</span>    <span class="o">.</span> <span class="p">,</span> <span class="o">::</span> <span class="o">|</span> <span class="o">:|</span> <span class="o">:=</span> <span class="p">(</span> <span class="p">)</span> <span class="p">[</span> <span class="p">]</span> <span class="p">{</span> <span class="p">}</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">int</span> <span class="kt">real</span> <span class="kt">string</span> <span class="kt">char</span> <span class="kt">bool</span> <span class="kt">nat</span> <span class="kt">ORDINAL</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">object</span> <span class="kt">object?</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">bv1</span> <span class="kt">bv10</span> <span class="kt">bv0</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">array</span> <span class="kt">array2</span> <span class="kt">array20</span> <span class="kt">array10</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">array?</span> <span class="kt">array2?</span> <span class="kt">array20?</span> <span class="kt">array10?</span>
<span class="n">ids</span><span class="o">:</span>     <span class="n">array1</span> <span class="n">array0</span> <span class="n">array02</span> <span class="n">bv02</span> <span class="n">bv_1</span>
<span class="n">ids</span><span class="o">:</span>     <span class="n">intx</span> <span class="n">natx</span> <span class="n">int0</span> <span class="n">int_</span> <span class="n">int?</span> <span class="n">bv1_</span> <span class="n">bv1x</span> <span class="n">array2x</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="kt">set</span> <span class="o">&lt;</span> <span class="kt">bool</span> <span class="o">&gt;</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">map</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="kt">bool</span><span class="o">&gt;</span>  <span class="kt">imap</span> <span class="o">&lt;</span> <span class="kt">bool</span> <span class="p">,</span> <span class="kt">bool</span> <span class="o">&gt;</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">seq</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="kt">seq</span><span class="o">&lt;</span> <span class="n">Node</span> <span class="o">&gt;</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">set</span><span class="o">&lt;</span> <span class="kt">real</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">map</span><span class="o">&lt;</span><span class="kt">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="kt">seq</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span>
<span class="n">types</span><span class="o">:</span>   <span class="n">G</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">,</span><span class="n">G</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span>
<span class="n">types</span><span class="o">:</span>   <span class="kt">seq</span> <span class="kt">map</span> <span class="kt">imap</span> <span class="kt">set</span> <span class="kt">iset</span> <span class="kt">multiset</span>
<span class="n">ids</span><span class="o">:</span>     <span class="n">seqx</span> <span class="n">mapx</span>
<span class="n">no</span> <span class="n">arg</span><span class="o">:</span>  <span class="kt">seq</span> <span class="o">&lt;</span> <span class="o">&gt;</span>  <span class="kt">seq</span> <span class="o">&lt;</span> <span class="p">,</span> <span class="o">&gt;</span>  <span class="kt">seq</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="p">,</span> <span class="p">,</span> <span class="kt">bool</span> <span class="o">&gt;</span>  <span class="kt">seq</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="o">&gt;</span>
<span class="n">keywords</span><span class="o">:</span> <span class="kr">if</span> <span class="kr">while</span> <span class="kr">assert</span> <span class="kr">assume</span>
<span class="n">spec</span><span class="o">:</span>    <span class="kr">requires</span>  <span class="kr">reads</span> <span class="kr">modifies</span>
<span class="n">attribute</span><span class="o">:</span>  <span class="p">{</span><span class="o">:</span> <span class="n">MyAttribute</span> <span class="s2">"asd"</span><span class="p">,</span> <span class="mi">34</span> <span class="p">}</span>
<span class="n">attribute</span><span class="o">:</span>  <span class="p">{</span><span class="o">:</span> <span class="n">MyAttribute</span> <span class="p">}</span>
<span class="n">comment</span><span class="o">:</span>  <span class="c1">// comment</span>
<span class="n">comment</span><span class="o">:</span>  <span class="cm">/* comment */</span> <span class="n">after</span>
<span class="n">comment</span><span class="o">:</span>  <span class="c1">// comment /* asd */ dfg</span>
<span class="n">comment</span><span class="o">:</span>  <span class="cm">/* comment /* embedded */ tail */</span> <span class="n">after</span>
<span class="n">comment</span><span class="o">:</span>  <span class="cm">/* comment // embedded */</span> <span class="n">after</span>
<span class="n">comment</span><span class="o">:</span> <span class="cm">/* comment
   /* inner comment
   */
   outer comment
   */</span> <span class="n">after</span>
   <span class="n">more</span> <span class="n">after</span>
</code></pre></div></div>

<!--PDF NEWPAGE-->

<h2 id="19-references">19. References</h2>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:binding" role="doc-endnote">
      <p>The binding power of shift and bit-wise operations is different than in C-like languages.<a href="#fnref:binding" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn-map-display" role="doc-endnote">
      <p>This is likely to change in the future to disallow
multiple occurrences of the same key.<a href="#fnref:fn-map-display" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn-map-membership" role="doc-endnote">
      <p>This is likely to change in the future as
follows:  The <code class="language-dafny highlighter-rouge"><span class="ow">in</span></code> and <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="ow">in</span></code> operations will no longer be
supported on maps, with <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">in</span> <span class="n">m</span></code> replaced by <code class="language-dafny highlighter-rouge"><span class="n">x</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">Keys</span></code>,
and similarly for <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="ow">in</span></code>.<a href="#fnref:fn-map-membership" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn-traits" role="doc-endnote">
      <p>Traits are new to Dafny and are likely to evolve for a while.<a href="#fnref:fn-traits" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:overload" role="doc-endnote">
      <p>It is possible to conceive of a mechanism for disambiguating conflicting names, but this would add complexity to the language that does not appear to be needed, at least as yet.<a href="#fnref:overload" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn-iterator-field-names" role="doc-endnote">
      <p>It would make sense to rename the special
fields <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="kr">reads</span></code> and <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="kr">modifies</span></code> to have the same names as the
corresponding keywords, <code class="language-dafny highlighter-rouge"><span class="kr">reads</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">modifies</span></code>, as is done for
function values.  Also, the various <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="kr">decreases</span><span class="err">\</span><span class="p">(</span><span class="err">_</span><span class="n">i_</span><span class="err">\</span><span class="p">)</span></code> fields can be
combined into one field named <code class="language-dafny highlighter-rouge"><span class="kr">decreases</span></code> whose type is a
<em>n</em>-tuple. These changes may be incorporated into a future version
of Dafny.<a href="#fnref:fn-iterator-field-names" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn-copredicate-restriction" role="doc-endnote">
      <p>To be specific, Dafny has two forms of<a href="#fnref:fn-copredicate-restriction" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn-co-predicate-co-lemma-diffs" role="doc-endnote">
      <p>Note, two places where co-predicates
and co-lemmas are not analogous are (a) co-predicates must not make
recursive calls to their prefix predicates and (b) co-predicates cannot
mention <code class="language-dafny highlighter-rouge"><span class="err">_</span><span class="n">k</span></code>.<a href="#fnref:fn-co-predicate-co-lemma-diffs" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:elephant" role="doc-endnote">
      <p>The <code class="language-dafny highlighter-rouge"><span class="o">:-</span></code> token is called the elephant symbol or operator.<a href="#fnref:elephant" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Old" role="doc-endnote">
      <p>The semantics of <code class="language-dafny highlighter-rouge"><span class="kr">old</span></code> in Dafny differs from similar constructs in other specification languages like ACSL or JML.<a href="#fnref:Old" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:set-of-objects-not-in-functions" role="doc-endnote">
      <p>In order to be deterministic, the result of a function should only depend on the arguments and of the objects  it <a href="#sec-reads-clause">reads</a>, and Dafny does not provide a way to explicitly pass the entire heap as the argument to a function. See <a href="https://github.com/dafny-lang/dafny/issues/1366">this post</a> for more insights.<a href="#fnref:set-of-objects-not-in-functions" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:CTC" role="doc-endnote">
      <p>This set of operations that are constant-folded may be enlarged in future versions of <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code>.<a href="#fnref:CTC" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:boogie-attributes" role="doc-endnote">
      <p>All entities that Dafny translates to Boogie have their attributes passed on to Boogie except for the <a href="#sec-axiom"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">axiom</span><span class="p">}</span></code></a> attribute (which conflicts with Boogie usage) and the <a href="#sec-trigger"><code class="language-dafny highlighter-rouge"><span class="p">{</span><span class="o">:</span><span class="n">trigger</span><span class="p">}</span></code></a> attribute which is instead converted into a Boogie quantifier <em>trigger</em>. See Section 11 of [@Leino:Boogie2-RefMan].<a href="#fnref:boogie-attributes" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:why-after-type-inference" role="doc-endnote">
      <p>Ghost inference has to be performed after type inference, at least because it is not possible to determine if a member access <code class="language-dafny highlighter-rouge"><span class="n">a</span><span class="o">.</span><span class="n">b</span></code> refers to a ghost variable until the type of <code class="language-dafny highlighter-rouge"><span class="n">a</span></code> is determined.<a href="#fnref:why-after-type-inference" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fn-duplicate-files" role="doc-endnote">
      <p>File names are considered equal if they have the same absolute path, compared as case-sensitive strings (regardless of whether the underlying file-system is case sensitive).  Using symbolic links may make the same file have a different absolute path; this will generally cause duplicate declaration errors.<a href="#fnref:fn-duplicate-files" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:incomplete" role="doc-endnote">
      <p>Unlike some languages, Dafny does not allow separation of<a href="#fnref:incomplete" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:smt-encoding" role="doc-endnote">
      <p>The formula sent to the underlying SMT solver is the negation of the formula that the verifier wants to prove - also called a VC or verification condition. Hence, if the SMT solver returns unsat, it means that the SMT formula is always false, meaning the verifiers formula is always true. On the other side, if the SMT solver returns sat, it means that the SMT formula can be made true with a special variable assignment, which means that the verifiers formula is false under that same variable assignment, meaning its a counter-example for the verifier. In practice and because of quantifiers, the SMT solver will usually return unknown instead of sat, but will still provide a variable assignment that it couldnt prove that it does not make the formula true. <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> reports it as a counter-example but it might not be a real counter-example, only provide hints about what <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> knows.<a href="#fnref:smt-encoding" class="reversefootnote" role="doc-backlink">&#8617;</a><a href="#fnref:smt-encoding:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a><a href="#fnref:smt-encoding:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:explainer-assume-false" role="doc-endnote">
      <p><code class="language-dafny highlighter-rouge"><span class="kr">assume</span> <span class="kc">false</span></code> tells the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> verifier Assume everything is true from this point of the program. The reason is that, false proves anything. For example, <code class="language-dafny highlighter-rouge"><span class="kc">false</span> <span class="o">==&gt;</span> <span class="n">A</span></code> is always true because it is equivalent to <code class="language-dafny highlighter-rouge"><span class="o">!</span><span class="kc">false</span> <span class="o">||</span> <span class="n">A</span></code>, which reduces to <code class="language-dafny highlighter-rouge"><span class="kc">true</span> <span class="o">||</span> <span class="n">A</span></code>, which reduces to <code class="language-dafny highlighter-rouge"><span class="kc">true</span></code>.<a href="#fnref:explainer-assume-false" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:answer-slowdown" role="doc-endnote">
      <p><code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">P</span><span class="p">;</span></code>.<a href="#fnref:answer-slowdown" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:verifier-lost" role="doc-endnote">
      <p>By default, the expression of an assertion or a precondition is added to the knowledge base of the <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> verifier for further assertions or postconditions. However, this is not always desirable, because if the verifier has too much knowledge, it might get lost trying to prove something in the wrong direction.<a href="#fnref:verifier-lost" class="reversefootnote" role="doc-backlink">&#8617;</a><a href="#fnref:verifier-lost:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a><a href="#fnref:verifier-lost:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a><a href="#fnref:verifier-lost:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:precision-requires-clause" role="doc-endnote">
      <p><code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> actually breaks things down further. For example, a precondition <code class="language-dafny highlighter-rouge"><span class="kr">requires</span> <span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span></code> or an assert statement <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">B</span><span class="p">;</span></code> turns into two assertions, more or less like <code class="language-dafny highlighter-rouge"><span class="kr">requires</span> <span class="n">A</span> <span class="kr">requires</span> <span class="n">B</span></code> and <code class="language-dafny highlighter-rouge"><span class="kr">assert</span> <span class="n">A</span><span class="p">;</span> <span class="kr">assert</span> <span class="n">B</span><span class="p">;</span></code>.<a href="#fnref:precision-requires-clause" class="reversefootnote" role="doc-backlink">&#8617;</a><a href="#fnref:precision-requires-clause:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:complexity-path-encoding" role="doc-endnote">
      <p>All the complexities of the execution paths (if-then-else, loops, goto, break.) are, down the road and for verification purposes, cleverly encoded with variables recording the paths and guarding assumptions made on each path. In practice, a second clever encoding of variables enables grouping many assertions together, and recovers which assertion is failing based on the value of variables that the SMT solver returns.<a href="#fnref:complexity-path-encoding" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:example-assertion-turned-into-assumption" role="doc-endnote">
      <p>This <a href="https://github.com/dafny-lang/dafny/discussions/1898">post</a> gives an overview of how assertions are turned into assumptions for verification purposes.<a href="#fnref:example-assertion-turned-into-assumption" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:caveat-about-assertion-and-assumption" role="doc-endnote">
      <p>Caveat about assertion and assumption: One big difference between an assertion transformed in an assumption and the original assertion is that the original assertion can unroll functions twice, whereas the assumed assertion can unroll them only once. Hence, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> can still continue to analyze assertions after a failing assertion without automatically proving false (which would make all further assertions vacuous).<a href="#fnref:caveat-about-assertion-and-assumption" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:smaller-batches" role="doc-endnote">
      <p>To create a smaller batch, <code class="language-dafny highlighter-rouge"><span class="n">dafny</span></code> duplicates the assertion batch, and arbitrarily transforms the clones of an assertion into assumptions except in exactly one batch, so that each assertion is verified only in one batch. This results in easier formulas for the verifier because it has less to prove, but it takes more overhead because every verification instance have a common set of axioms and there is no knowledge sharing between instances because they run independently.<a href="#fnref:smaller-batches" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:compiler-feature-forall-note" role="doc-endnote">
      <p>Sequentializing a <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statement refers to compiling it directly to a series of nested loops
with the statements body directly inside. The alternative, default compilation strategy
is to calculate the quantified variable bindings separately as a collection of tuples,
and then execute the statements body for each tuple.
Not all <code class="language-dafny highlighter-rouge"><span class="kr">forall</span></code> statements can be sequentialized.<a href="#fnref:compiler-feature-forall-note" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:compiler-sequence-display-of-characters-note" role="doc-endnote">
      <p>This refers to an expression such as <code class="language-dafny highlighter-rouge"><span class="p">[</span><span class="sc">'H'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">]</span></code>, as opposed to a string literal such as <code class="language-dafny highlighter-rouge"><span class="s2">"Hello"</span></code>.<a href="#fnref:compiler-sequence-display-of-characters-note" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:compiler-infinite-assign-such-that-note" role="doc-endnote">
      <p>This refers to assign-such-that statements with multiple variables,
and where at least one variable has potentially infinite bounds.
For example, the implementation of the statement <code class="language-dafny highlighter-rouge"><span class="kr">var</span> <span class="n">x</span><span class="o">:</span> <span class="kt">nat</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="kt">nat</span> <span class="o">:|</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code>
needs to avoid the naive approach of iterating all possible values of <code class="language-dafny highlighter-rouge"><span class="n">x</span></code> and <code class="language-dafny highlighter-rouge"><span class="n">y</span></code> in a nested loop.<a href="#fnref:compiler-infinite-assign-such-that-note" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:compiler-sequence-display-nolambda-note" role="doc-endnote">
      <p>Sequence construction expressions often use a direct lambda expression, as in <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span></code>,
but they can also be used with arbitrary function values, as in <code class="language-dafny highlighter-rouge"><span class="kt">seq</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">squareFn</span><span class="p">)</span></code>.<a href="#fnref:compiler-sequence-display-nolambda-note" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </div>
  </main><footer class="site-footer h-card">

</footer>
</body>

</html>
